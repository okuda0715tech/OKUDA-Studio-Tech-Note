<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [パスワードを安全に保存するベストプラクティス](#パスワードを安全に保存するベストプラクティス)
  - [概略](#概略)
  - [なぜ暗号化ではなく、ハッシュ化なのか](#なぜ暗号化ではなくハッシュ化なのか)
    - [ログイン認証においては、パスワードを復元する必要がない。](#ログイン認証においてはパスワードを復元する必要がない)
  - [オフライン攻撃の前提「すべてばれている」](#オフライン攻撃の前提すべてばれている)
  - [ユーザには安全なパスワードを設定する責任がある](#ユーザには安全なパスワードを設定する責任がある)
  - [場合によっては、ハッシュ値をさらに暗号化することも可](#場合によってはハッシュ値をさらに暗号化することも可)
  - [ハッシュ値を保存することによる制約](#ハッシュ値を保存することによる制約)
    - [パスワードリマインダを実装できない](#パスワードリマインダを実装できない)
    - [パスワードの保存方法の変更が難しくなる](#パスワードの保存方法の変更が難しくなる)
<!-- TOC END -->


# パスワードを安全に保存するベストプラクティス

## 概略

パスワードを安全に保存するベストプラクティスは、 **「ソルト＋ハッシュ化＋ストレッチング」** です。


## なぜ暗号化ではなく、ハッシュ化なのか

※ 詳しく書かれている元ネタがあまりないので、以下は想像も入った考察です。

### ログイン認証においては、パスワードを復元する必要がない。

ログイン認証においては、パスワードを復元する必要がないため、より高速に処理できる  
ハッシュ化が利用される。

一方、クレジットカード番号などは、復元しなければ使用できないため、ハッシュ化では保存ができず、  
暗号化が使用される。

暗号化した場合は、鍵も保存することになるため、鍵が盗まれることのないように厳重に管理する必要がある。


## オフライン攻撃の前提「すべてばれている」

オフライン攻撃に対する対策を考える際には、前提として、 **すべてが攻撃者にばれている** と想定します。

すなわち、ハッシュ値のほか、ハッシュアルゴリズム、ソルト、ストレッチングの有無や回数は、  
すべて攻撃者に「ばれている」状態で、それでも元の（平文の）パスワードが保護できるかを考えるべきです。  
その状況下でも、パスワードだけは保護できるかどうかが論点になります。

一方、もしも攻撃者が絶対に取得できない情報保管手段があると前提してもよいのであれば、  
その方法でパスワード自体を保存するか、安全な方法で暗号鍵を保存してパスワードを暗号化すればよいことになり、  
必ずしもハッシュを用いる必要はありません。

しかし現実には、そのような便利な手段は、特殊なためあまり普及していません。  
ですので、すべてが「ばれている」という前提で考えるわけです。


## ユーザには安全なパスワードを設定する責任がある

パスワード認証の大前提は、「パスワードは利用者本人しか知らないはずの文字列を指定しているから  
正当な利用者と認証する」ものであって、 **安全なパスワードを指定するのは利用者の責任** であるということです。

たまに、パスワードの漏えい事件後にパスワードの統計情報が公表されることがあります。  
そこでは、よく使われているパスワードの常連として、password、abcdef、qwerty、123456などの文字列が  
並んでいます。これらの「ありがちな」パスワードの利用者は、上記の責任を放棄していることになりますが、  
なかなかそのような利用者を減らすことができないのも事実です。

また、開発者ができることとして、 **「複雑なパスワードを設定したくても設定できない状況を作らない」**  
ということが大切になってきます。例えば、「パスワードの文字数上限を 8 文字までにする」  
ということはあってはなりません。 Amazon では、 128 文字までのパスワードを設定することができるくらいです。


## 場合によっては、ハッシュ値をさらに暗号化することも可

場合によっては、ハッシュ値をさらに暗号化するという方法も考えられます。  
その場合は、暗号鍵はハッシュ値とは別の方法で保存するのが良いでしょう。  
例えば、ハッシュ値は 「DB」 に保存し、暗号鍵は 「設定ファイル」 に保存するという具合にします。


## ハッシュ値を保存することによる制約

### パスワードリマインダを実装できない

利用者がパスワードを忘れた際に、メールなどでパスワードを通知する機能を「パスワードリマインダ」  
と呼びます。パスワードをハッシュ値で保存すると、パスワードリマインダを実装できなくなるため、  
利用者がパスワードを変更できる機能（パスワードリセット）で代替します。


### パスワードの保存方法の変更が難しくなる

ハッシュアルゴリズムに脆弱性が見つかったのでハッシュアルゴリズムを変更したい場合、あるいは  
GPUの性能向上に合わせてストレッチングの回数を増やしたいという状況は、あらかじめ想定しなければなりません。

パスワードを（復号可能な）暗号化している場合は、いったんパスワードを復号して、新しい方式で  
暗号化する再暗号化という方法が取れます。しかし、ハッシュの場合は復号ができないので、  
再暗号化は不可能です。このため、以下のような方式が考えられます。

まず、ハッシュ方式の変更に緊急性がない場合は、ユーザーが認証したタイミングでハッシュ方式を  
変更することができます。認証成功時にはパスワードが分かるので、そのパスワードを新しい  
ハッシュ方式に変換し、保存します。

パスワード情報が漏えいし、ハッシュも解読された可能性が高い場合など、緊急にパスワードを  
変更しなければならない場合もあります。その場合は、現在のパスワードをいったん無効にして、  
パスワードリセットにより新しいパスワードを利用者に付けてもらうようにします。  
↑ この場合は、おそらく、パスワードの無効化だけを即日実行し、新しいパスワードの再設定は、  
登録されたメールアドレスに対して「再設定用のWebページへのリンク」などを添付して、  
そこから新しいパスワードを設定してもらうことになるのかな？新しいパスワードの再設定方法  
については、さらによく調査する必要がありそう。

このような状況に備えるため、ハッシュ値の保存時に、パスワードの保存方式を示すマークを付けて  
おくとよいでしょう。よく用いられる形式は、「$1$」などと、ハッシュ値の先頭に「$」などの記号で  
方式番号を付けておく方法ですが、それ以外の方法でも構いません。
