- [onClickListener はメモリリークするのか](#onclicklistener-はメモリリークするのか)
  - [概要](#概要)
  - [Android のメモリ管理手法は「マーク＆スイープ」方式](#android-のメモリ管理手法はマークスイープ方式)
  - [GC ルート](#gc-ルート)
    - [アクティブなスレッド](#アクティブなスレッド)
    - [static 変数](#static-変数)
    - [アクティブなコンポーネント](#アクティブなコンポーネント)
    - [JNI（Java Native Interface）参照](#jnijava-native-interface参照)
  - [Application は GC ルートではない](#application-は-gc-ルートではない)
  - [WeakReference は基本的には使うべきではない](#weakreference-は基本的には使うべきではない)
  - [参考資料](#参考資料)


# onClickListener はメモリリークするのか

## 概要

`View.OnClickListener` インターフェースを実装したインスタンスは、  
包含クラス (多くの場合、 Activity や Fragment ) への参照を  
暗黙的に保持しています。

しかし、普段、ネット上の記事や、実務中のプログラムでは、  
上記のリスナーを明示的に破棄するような実装は見たことがありません。

Activity や Fragment がメモリリークすることはないのか？  
と疑問に思っていたので、詳しく調べてみました。


## Android のメモリ管理手法は「マーク＆スイープ」方式

Android のメモリ管理手法は 「マーク＆スイープ」 方式です。  
(正式には Concurrent Mark-Sweep というらしい。)

GC ルートから到達可能なオブジェクトのみ  
ガベージコレクションが実行されても残り続けます。


## GC ルート

マークスイープ方式では、 GC ルートと呼ばれる、  
参照の大元となるオブジェクトを定義する必要があります。

GC ルートには以下のものがあります。  
(ChatGPT からの転用ですが、だいたいあっていると思います)


### アクティブなスレッド

**アクティブなスレッド上で参照されているオブジェクト**は、  
GCルートとなります。

「アクティブなスレッド」 とは、実行中、もしくは実行可能状態のスレッドのことです。  
すなわち、 **生成されてから、まだ終了されていないスレッド** のことを示します。

また、 「スレッド上で参照されているオブジェクト」 とは、  
各スレッドのスタックメモリ上で参照されているオブジェクトのことを示します。  
つまり、 **実行中のメソッドのローカル変数で参照されているオブジェクト** を示します。


### static 変数

クラスの静的変数（static変数）によって参照されているオブジェクトもGCルートです。  
アプリケーションがロードされるときに初期化され、アプリケーションのライフサイクル全体で有効です。

ドキュメントによっては、 static 変数から参照されている  
オブジェクトが GC の対象になり得ると記載されているものもあります。

厳密に言うと、確かに GC の対象になり得るのですが、  
普通の使い方をしている限り、 static フィールドが参照している  
オブジェクトが、 GC の対象になることはありません。

なぜ、厳密に言うと GC の対象になり得るのかというと、  
static フィールドは、 Class クラスから参照されています。  
Class クラスは、クラスローダーから参照されています。  
クラスローダーを明示的にアンロードした場合、  
クラスローダーが破棄され、 Class クラスが破棄されるため、  
Class クラスから static フィールドへの参照も失われます。  
その場合は、 static フィールドが参照しているオブジェクトも  
GC の対象となります。  
ただし、クラスローダーがアンロードされるのは、  
通常の場合、アプリが終了した時くらいしかありません。  
つまり、アプリを終了しない限りは static フィールドが参照している  
オブジェクトが GC 対象となることはなく、  
それゆえ、 static フィールドは GC ルートとなると認められています。


**【参考】インスタンス変数**

static 変数が Class クラスから参照されているのに対して、  
インスタンス変数は、インスタンスから参照されています。

そのため、 GC ルートからインスタンス自体への参照が残っていれば、  
そのインスタンスのインスタンス変数が参照しているオブジェクトも  
GC ルートから到達可能であり、 GC の対象とはなりません。


### アクティブなコンポーネント

現在フォアグラウンドで実行されているアクティビティ、サービス、  
ブロードキャストレシーバなどのアクティブなコンポーネントが  
GCルートとなります。


### JNI（Java Native Interface）参照

JNIを使用してネイティブコードとやり取りする場合、  
JNI参照がGCルートになります。

これらはJavaオブジェクトへの参照を保持し、ネイティブコードから  
Javaオブジェクトにアクセスするのに使用されます。


## Application は GC ルートではない

Application オブジェクトは GC ルートではありません。

しかし、 Activity と Service は、メンバ変数として Application を  
保持しているため、 Activity と Service が存在している際は、  
GC の対象にはなりません。

Broadcast については、 BroadcastReceicer のメンバ変数としては  
Application を保持してません。  
しかし、 BroadcastReceiver の onReceive(Context) メソッドの  
引数に ApplicationContext を保持しているため、  
onReceive() メソッドが実行されている最中は、  
Application オブジェクトが破棄されることはありません。  
それが終われば GC の対象となります。


## WeakReference は基本的には使うべきではない

WeakReference で参照されているオブジェクトは、いつ GC されるのかわかりません。  
つまり、本来、 GC されてはいけないタイミングで GC されることがあります。  
そのため、 WeakReference は基本的に使用すべきではありません。

WeakReference を使用したいと思った場合は、まずは、  
強参照している変数に明示的に null を代入して、  
クリアする方法を検討してみましょう。


## 参考資料

[Swift vs. Kotlin — the differences in memory management](https://medium.com/indoorway-blog/swift-vs-kotlin-the-differences-in-memory-management-860828edf8)

[Javaでのガベージコレクション](https://www.logicmonitor.jp/blog/garbage-collection-in-java)




