- [仮型引数の型へのキャストは実際にはキャストされていない](#仮型引数の型へのキャストは実際にはキャストされていない)
  - [【注意】上記のキャストはクライアント側で実行時エラーになる可能性がある](#注意上記のキャストはクライアント側で実行時エラーになる可能性がある)


# 仮型引数の型へのキャストは実際にはキャストされていない

```Java
public class MyClass<E> {

    public void myMethod() {
		// 例えば、 E が String 型だった場合、
		// 実行時に Object は String にキャストされず、 Object 型のまま扱われる
        E e = (E) new Object();
    }

}
```

まずは、上記のサンプルコードを見てください。

これは Object 型を String 型にキャストしているように見えるので、実行時にエラーになるように見えますが、  
**上記のキャスト自体は**、エラーにはならず、実行時には、 Object 型のまま扱われます。

ジェネリクスは、実行時には型情報を保持していないため、実行時の仮型引数へのキャストは無視されているようです。

では、 `(E) new Object();` のキャスト自体が不要かというと、そうではなく、  
コンパイル時には、型チェックを行うために、上記の例では必要なキャストとなります。


## 【注意】上記のキャストはクライアント側で実行時エラーになる可能性がある

上記のサンプルコード ( Object 型を仮型引数の型 E へキャスト) は、キャスト実行時にはエラーになりませんが、  
上記のメソッドを使用するクライアント側で実行時エラーになる可能性を含んでいます。

例えば、クライアント側のコードが以下のように実装されていたとします。

```Java
public class MyClient {

    public void execute() {
        MyClass<String> myClass = new MyClass<>();
		// myMethod() は Object 型のインスタンスを返すため、実行時エラーとなる。
        String s = myClass.myMethod();
    }
}
```

上記のクライアントコードはコンパイルに成功します。  
しかし、 `myMethod()` の戻り値が `Object` 型であるため、  
`String` 型の変数に格納することができず、実行時エラーとなります。

これを防ぐためには、ジェネリクスクラス or ジェネリクスメソッドの中で型チェックを行い、  
型安全を確認した上で、ジェネリクスクラス or ジェネリクスメソッドの中でキャストを実行すると良いでしょう。  

【補足】  
上記の例は、例が悪いため、改善例の記載はやめておきます。  
いい例なら、そもそも `myMethod()` 内の `Object` オブジェクトには  
`String` 型のデータしか入ってこないでしょう。




