<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [匿名内部クラス](#匿名内部クラス)
  - [外部メソッドのローカル変数は、匿名クラスの生成時にコピーされる](#外部メソッドのローカル変数は匿名クラスの生成時にコピーされる)
  - [外部メソッドのローカル変数へアクセスする場合は final である必要がある](#外部メソッドのローカル変数へアクセスする場合は-final-である必要がある)
    - [なぜ final でなければいけないのか？](#なぜ-final-でなければいけないのか)
    - [【余談】場合によっては、 final ではないので final で定義しないで！というエラーが出ることもある](#余談場合によっては-final-ではないので-final-で定義しないでというエラーが出ることもある)
  - [外部クラスのインスタンスへのアクセス](#外部クラスのインスタンスへのアクセス)
  - [外部クラスのプライベートメンバへのアクセス](#外部クラスのプライベートメンバへのアクセス)
<!-- TOC END -->


# 匿名内部クラス

## 外部メソッドのローカル変数は、匿名クラスの生成時にコピーされる

例えば、以下のコードについて考えます。

```java
public void outerMethod(int param) {
  String value = "Hello";

  Anonymous t = new Anonymous() {
    public void callback() {
      // この param は、値だけコピーされた、外部メソッドの param とは別の param である。
      Log.d("APP_LOG", "param = " + param);
      // この value は、値だけコピーされた、外部メソッドの value とは別の value である。
      Log.d("APP_LOG", "value = " + value);
    }
  };
}
```

まず、 Java の大原則として、ローカル変数のスコープは、そのメソッド内部だけになるため、  
`outerMethod()` が終了すると、 `outerMethod()` 内部の `param` と `value` は破棄されます。  
しかし、 `Anonymous` クラスの `callback()` メソッドは、 `outerMethod()` が終了するまでに  
呼ばれるとは限りません。

そのため、 `Anonymous` クラスのインスタンス生成時に、外部メソッドの  
`param` と `value` の値 or 参照先だけを `callback()` メソッド内の `param` と `value` にコピーしています。

つまり、 「外部メソッドのローカル変数」 と、 「匿名クラス内のメソッド内部のローカル変数」 は別物となっています。

これにより、 `outerMethod()` が終了した後でも、 `outerMethod()` が保持していた  
`param` と `value` にアクセスすることが可能になっています。


## 外部メソッドのローカル変数へアクセスする場合は final である必要がある

匿名クラスのメソッド内から、外部メソッドのローカル変数へアクセスする場合は、  
外部メソッドのローカル変数は `final` (もしくは実質的に `final` ※1) である必要があります。

(※1)  
「実質的に `final` 」 とは、実際には、 `final` と定義はしないものの、値の更新を行わない状態を示すと思われます。

final ではない場合は、基本的にはコンパイルエラーになりますが、値を更新していない場合は、  
エラーにならないこともあります。


### なぜ final でなければいけないのか？

匿名クラス内のメソッドは、 「いつ実行されるか」 がわからないため、匿名クラスのインスタンス生成時に  
外部メソッドのローカル変数をコピーする仕組みになっています。

基本的に、**コピーした値のコピー元を変更しても、コピー先には反映されないため (※1) 、プログラマーが
混乱してしまう**ことにつながりかねません。それを防止するために 「 `final` でなければいけない」  
という制限をつけていると思われます。

(※1)  
匿名クラスのインスタンス生成前に、値を更新した場合は、理屈的には、コピー先の値に、  
コピー元の更新後の値が反映されます。しかし、そのようなコードはコンパイルエラーになります。  
(実質的 `final` ではないため。)  
そもそも、匿名クラス内部からアクセスされている外部メソッドのローカル変数を、更新しない思想  
を持ってほしいという願いが込められていると思われる。


### 【余談】場合によっては、 final ではないので final で定義しないで！というエラーが出ることもある

`RecyclerView` の `onBindViewHolder()` メソッドの引数である `int position` を  
`final` で定義し、匿名クラスのメソッド内部で参照するとコンパイルエラーになります。

この `position` は、 「 途中で値が有効ではなくなる可能性があるため、 final で定義しないで」  
というコンパイルエラーが表示されるようになっています。

この場合は、 「代わりに `Adapter` からポジションを取得してください」 という補足メッセージが  
つけられています。


## 外部クラスのインスタンスへのアクセス

匿名クラスのコンストラクタで、外部クラスへの参照を渡しています。  
匿名クラス内部に、隠しメンバ ( `this$0` ) として保持しています。


## 外部クラスのプライベートメンバへのアクセス

外部クラスに `access$番号` というような隠しメソッドが用意してあり、それを経由してアクセスしています。
