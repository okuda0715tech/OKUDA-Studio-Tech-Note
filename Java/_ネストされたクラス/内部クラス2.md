<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [ネストされたクラス](#ネストされたクラス)
  - [概要](#概要)
  - [可視性](#可視性)
  - [ネストされたクラスの分類](#ネストされたクラスの分類)
    - [staticなネストされたクラス](#staticなネストされたクラス)
    - [メンバー内部クラス](#メンバー内部クラス)
    - [メソッドローカル内部クラス](#メソッドローカル内部クラス)
    - [匿名内部クラス](#匿名内部クラス)
    - [それぞれの使いどころ](#それぞれの使いどころ)
<!-- TOC END -->


# ネストされたクラス

## 概要

- ネストされたクラスは、常に包含クラスと関連付けされて使用されること意味する。
  - 例えば、Carという包含クラスとTireというネストされたクラスの関係などが考えられる。
- カプセル化を可能にすることで、可読性とメンテナンス性を向上させる目的がある。
  - 包含クラスのフィールドを`private`にしつつ、別の特定のクラス（ネストされたクラス）からのアクセスのみを許可することができる。


## 可視性

- 包含クラスはネストされたクラスのメンバーへのアクセス権限を持たない。
- ネストされたクラスは包含クラスのメンバーへのアクセス権限を持つ。たとえそれが`private`なメンバーであっても権限を持つ。


- ネストされたクラスは包含クラスのメンバーである。
  - そのため、ネストされたクラスには、`private`、`protected`、`package private`、`public`の修飾子が設定される。


## ネストされたクラスの分類

ネストされたクラスは4つにわけることができます。（以下の１～４）

- ネストされたクラス
  - staticなネストされたクラス　・・・　１
  - 内部クラス（staticではないネストされたクラス）
    - メンバー内部クラス　・・・　２
      - クラスのメンバとして定義されたクラス
    - メソッドローカル内部クラス ( Local Inner Class と呼ばれる)　・・・　３
      - メソッド内で定義されたクラス
    - 匿名内部クラス　・・・　４
      - メソッドローカル内部クラスのうち、名前を持たないクラス


### staticなネストされたクラス

- 定義する場所
  - クラスのメンバとして定義します。
- 用途
  - 包含クラスのクラスに関連づけて使用します。
- 目的
  - staticなネストされたクラスを参照する際に、包含クラスがパッケージのような役割をすることで、クラスを整理すること。ただし、それならパッケージで分ければ事足りることになる。実際は、パッケージを分けるほどでもないような小さなクラスの場合に使用するのかな？
- メリット
  - Builderパターンを作成する場合に最適な実装が可能になる。
    - どのように最適なのかや実際の実装はサンプルプロジェクトを参照（自分のGithubリポジトリ : #BuilderPattern）


### メンバー内部クラス

- 定義する場所
  - クラスのメンバとして定義します。
- 用途
  - 包含クラスのインスタンスに関連づけて使用します。
  - OuterクラスをViewに置き換え、InnerクラスをView.OnClickListenerに置き換えると、ユーザーイベントのハンドリングで使用されるパターンであることがわかる。
- 目的


### メソッドローカル内部クラス

一般的には、 「ローカル内部クラス」 と呼ばれます。  
ただし、このメモでは、 「メソッドローカル内部クラス」 と呼んだ方が、他の内部クラスとの違いがパッと認識しやすいため、あえて、こう呼んでいます。

- 定義する場所
  - 包含クラスのメソッド内や for 文内や if 文内などの中カッコ内で定義します。
- スコープ
  - 定義された中カッコ内
- 使用方法
  - クラスをインスタンス化してから使用する必要がある。
    - インスタンス化のコードは、クラス定義のコードが実行された後に記述する必要があります。
- 用途
  - 包含クラスのメソッドに関連付けて使用します。
- メリット
  - メソッドローカル内部クラスが、メソッドローカル内部クラスを包含するメソッドのfinalなローカル変数にアクセスできるます。このfinalローカル変数への参照は、包含クラスのメソッドのスコープが終了した後でも保持されることが重要なメリットです。


### 匿名内部クラス

- 定義する場所
  - メソッドローカル内部クラスのうち、名前を持たないクラス
- 用途
  - View.OnClickListernerなどGUIのイベントハンドリングに使用します。


### それぞれの使いどころ

`staticなネストされたクラス` と `メンバー内部クラス` はある種の仲間であり、これらのクラスを使用したい場合は、  
この二つから使用する方を決めることになります。

**staticなネストされたクラス**

- staticなネストされたクラスとメンバー内部クラスは使用方法が似ており、どちらを使用するか検討する場合が多いです。
- 下記の `メンバー内部クラス` の項目に記載したようなアクセスが必要ない場合は、`staticなネストされたクラス` を使用します。
  - `メンバー内部クラス` は包含クラスのインスタンスへの暗黙的な参照を保持するため、参照が必要ない場合は `staticなネストされたクラス` を使用します。

**メンバー内部クラス**

- 包含クラスのインスタンスの（publicではない）フィールドにアクセスする必要がある場合は、 `staticなネストされたクラス` ではなく、 `メンバー内部クラス` を使用します。
- 逆に、包含クラスのインスタンスのフィールドにアクセスする必要がない場合は、コンパイラは `staticなネストされたクラス` を推奨するでしょう。


`メソッドローカル内部クラス` と `匿名内部クラス` はある種の仲間であり、これらのクラスを使用したい場合は、  
この二つから使用する方を決めることになります。

**メソッドローカル内部クラス**

- 匿名内部クラスを使用したいが、複数のインスタンスを生成してそれぞれのインスタンスを別々に扱いたい場合にメソッドローカル内部クラスを使用する。

**匿名内部クラス**

- 匿名内部クラスを使用したい場合は、匿名内部クラスを使用するか、メソッド内部クラスを使用するか検討する余地がある。
