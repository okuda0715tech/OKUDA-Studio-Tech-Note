<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [型](#型)
	- [プリミティブ型とそのラッパークラスの相互変換について](#プリミティブ型とそのラッパークラスの相互変換について)
	- [ポリモーフィズムを使って各数値型をまとめて扱いたい場合](#ポリモーフィズムを使って各数値型をまとめて扱いたい場合)
	- [ラッパークラスをプリミティブ型に変換する方法（違う型への変換も可能）](#ラッパークラスをプリミティブ型に変換する方法違う型への変換も可能)
	- [リテラル](#リテラル)
		- [リテラルとは](#リテラルとは)
		- [リテラルは型を持つ](#リテラルは型を持つ)
		- [リテラルのデフォルトの型](#リテラルのデフォルトの型)
			- [n進数からm進数への変換](#n進数からm進数への変換)
	- [Object型からプリミティブ型への理想的な？変換](#object型からプリミティブ型への理想的な変換)
<!-- TOC END -->


# 型

## プリミティブ型とそのラッパークラスの相互変換について

プリミティブ型とそのラッパークラスの相互変換は Java が自動的にやってくれるため、開発者が変換する必要はありません。
プリミティブ型からラッパークラスへの変換を `Boxing` と言い、ラッパークラスからプリミティブ型への変換を `UnBoxing` と言います。
これを Java が自動でやってくれるため、合わせて `Auto Boxing` と言います。

**Sample.java**

```Java
// Boxingの例
int numInt = 10;
Integer numInteger = numInt;

// UnBoxingの例
Integer numInteger = new Integer(10);
int numInt =  numInteger;
```

Java が自動で変換してくれるため、開発者は上記のように直接代入するだけで OK 。  
ただし、配列のボクシング、アンボクシングは自動で行ってくれません。
別紙で配列用のユーティリティを用意しています。


## ポリモーフィズムを使って各数値型をまとめて扱いたい場合

ポリモーフィズムを使って各数値型をまとめて扱いたい場合は、`Number`型を使用します。
`Number`型は、`abstract`なクラスであり、`BigDecimal`、`BigInteger`、`Byte`、`Double`、`Float`、`Integer`、`Long`、`Short` のスーパークラスです。
よって、これらの型を同一視して同じ型変数で扱いたい場合は、`Number`型の変数に格納することで実現できます。


## ラッパークラスをプリミティブ型に変換する方法（違う型への変換も可能）

各ラッパークラスは、プリミティブ型に変換するメソッドを持っている。
同メソッドを使用して、精度の異なるプリミティブ型に変換することも可能である。が、変換処理は単にキャストしているだけなので、メソッドを使うほどでもない。
また、そもそもラッパークラスからプリミティブ型への変換はオートボクシングが作動するため、変換コードは不要である。

一応、変換するメソッドを以下に記載しておく。

- {ラッパークラスのインスタンス}.intValue();
  - `int`型の値を返す。
- {ラッパークラスのインスタンス}.longValue();
  - `long`型の値を返す。
- {ラッパークラスのインスタンス}.floatValue();
  - `float`型の値を返す。

など、他の型についても同様のメソッドが存在している。


## リテラル

### リテラルとは

リテラルとは、プログラム上に直接記述される数値や文字列のことを示します。 ( Kotlin では、関数もリテラルとして認められます。)

リテラル ( literal ) という単語には、 「言葉通りの」 という意味があります。プログラムで、例えば、以下のようにリテラルを定義したとします。

```java
int a = 10;
```

上記は、 `a` という変数の型は、 `int` です。 「この変数 `a` に代入される値は、 (言葉通り) int 型ですよ」 というニュアンスで、 「リテラル」 と呼ばれていると思われます。

一方で、以下のように、変数 `a` に代入されるのが、関数である場合、たとえ、その関数が int 型のデータを返したとしても、それは、リテラルとは呼びません。

```java
int a = hoge();

int hoge() {
	return 1;
}
```

リテラルと呼べるオブジェクトは、プリミティブ型、 String 型のみです。 ( Kotlin では、関数もリテラルと呼べます。)


### リテラルは型を持つ

コード上に記載する `10` や `"あいうえお"` は、変数に代入して初めて型が決まるように思えるかもしれませんが、代入する前に記述した時点で数値や文字そのものが特定の型を持っています。

例えば、

```
int a = 10;
```

と記載した時、 `10` は int 型と認識されるため、 int 型の数値 `(10)` を int 型の変数 `a` に代入することは何も問題ないわけです。

もし、

```
int a = 10L;
```

とした場合は、 `10L` は long 型の `10` と認識されるため、 long 型を int 型の変数に代入しようとしているとしてコンパイルエラーになります。


### リテラルのデフォルトの型

リテラルの表現(※3) | デフォルトで設定される型
---------------|-------------
整数           | int型
整数 + L       | long型
小数           | double型
小数 + F       | float型
小数 + D       | double型
0 + 0〜7の整数(※1)  | 8進数(intでもfloatでもどんな型にでも代入可能)
0x + 0〜9の整数(※2) or a〜f  | 16進数
数値 + E + 整数  | double型(数値 × 10^整数)

(※1)小数点が入ると10進数になってしまう。  
(※2)小数点が入るとコンパイルエラーになってしまう。  
(※3)大文字で書かれているローマ字の部分は小文字でも可。

#### n進数からm進数への変換

以下のサイトにJavaでの変換方法が詳しく書かれている。

[Javaで進数変換を行なう方法](https://qiita.com/munieru_jp/items/6288988293958850bddd)


## Object型からプリミティブ型への理想的な？変換

```Java
Float fValue = 1.0f
Object oValue = fValue;
float primitiveFloatValue = ((Number) oValue).floatValue();
```
