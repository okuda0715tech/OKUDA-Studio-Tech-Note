<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [コレクション](#コレクション)
	- [コレクションの「instanceOf」メソッド](#コレクションのinstanceofメソッド)
	- [コレクションを入れ子で扱う場合は、独自クラスを作ると可読性が上がる](#コレクションを入れ子で扱う場合は独自クラスを作ると可読性が上がる)
		- [ポイント](#ポイント)

<!-- /TOC -->

# コレクション

## コレクションの「instanceOf」メソッド

コレクションはいきなり`if(obj instanceOf ArrayList<String>)`という判定ができません。その為、以下のようにコレクションの種類と要素の型の判定を別々に実施します。

**Sample.java**

```Java
private ArrayList<AppLineDataSet> lineList = new ArrayList<>();

Object obj = savedInstanceState.getSerializable("line_data_set_list");
if(outerObj instanceof ArrayList<?>){
    ArrayList<?> arrayList = (ArrayList<?>)outerObj;
    for (Object innerObj : arrayList) {
        if (innerObj instanceof AppLineDataSet) {
            AppLineDataSet appLineDataSet = (AppLineDataSet)innerObj;
            lineList.add(appLineDataSet);
        }
    }
}
```


## コレクションを入れ子で扱う場合は、独自クラスを作ると可読性が上がる

`List<List<String>>`などのように、コレクションの入れ子になることがある。このままでも問題はないが、独自クラスを作ると、よりコードが見やすくなる。

### ポイント

- 入れ子になるとダイヤモンド演算子がいくつも重なって見づらくなる
- 内側のコレクションをクラス化する
- クラス化の仕方は、`class MyStringList extends ArrayList<String>{}`などのようにする。
  - 中身が空のクラスを定義する。
  - ArrayListの機能をそのまま使用するだけのため、中身は空で良い。
  - こうすることで、`List<MyStringList>`となり、見た目が入れ子ではなくなるので、スッキリするというメリットがある。




