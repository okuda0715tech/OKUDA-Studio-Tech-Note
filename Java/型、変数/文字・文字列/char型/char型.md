<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [char 型](#char-型)
  - [char 型とは](#char-型とは)
  - [char 型の使いどころ](#char-型の使いどころ)
  - [char 型の変数を初期化しなかった場合は 0](#char-型の変数を初期化しなかった場合は-0)
  - [char 型への代入](#char-型への代入)
    - [代入のサンプル](#代入のサンプル)
    - [シングルクォーテーション「 ' 」で囲んだ文字は、数値に変換されてから処理される](#シングルクォーテーション--で囲んだ文字は数値に変換されてから処理される)
  - [String と char 間の変換](#string-と-char-間の変換)
<!-- TOC END -->


# char 型

## char 型とは

`char` 型は、 16 ビットで表現可能な文字を扱うのに使用する型です。  
文字を扱うと言ってっも、実際に格納するデータは、 16 ビットの整数データです。

Unicode のコードポイント `U+0000` ～ `U+FFFF` までで表現可能な (いわゆる基本多言語面)  
の文字を表現するのに使用します。

コードポイントが `U+FFFF` よりも大きい文字 (いわゆる補助文字) を扱う場合は、  
32 ビットのデータを格納できる `int` 型にデータを格納する必要があります。

Unicode の基本的な文字は、 16 ビットで表現可能であり、 `U+FFFF` の形式で、コードポイントが表記されます。

Java の `char` 型、 `String` 型、 `StringBuilder` クラスは、いずれも UTF-16 表現が使用されます。  


## char 型の使いどころ

char 型をそれ単独で使うことはあまりありません。  
char 型を最終的に String 型に変換したり、 String 型から char 型を取り出すなど、  
char 型と String 型を組み合わせて使うことが多いです。


## char 型の変数を初期化しなかった場合は 0

他の数値型のプリミティブ型と同じように、初期化しなかった場合は、デフォルトで 0 が設定されています。

char の配列を定義した場合も同じで、各要素を初期化しなかった場合は、デフォルトで 0 が設定されています。


## char 型への代入

### 代入のサンプル

#### 代入したい文字をそのまま代入する

```java
char c1 = 'A'; // → OK、charに文字を代入する
char c2 = "A"; // → NG(コンパイルエラー)、charに文字列を代入しようとしている
char c3 = 'AB'; // → NG、シングルクォーテーションで囲める文字は、一文字のみです。
```

#### Unicode のコード番号（コードポイント）で代入する

```Java
// '\u0000' 形式でコードポイントを指定します。
// 先頭のバックスラッシュは、環境によっては、「￥」マーク表示されることもあります。
// 後ろ 4 桁で、コードポイントを指定します。この 4 桁は 16 進数です。
char c1 = '\u0041'; // → 'A'
char c2 = '\u004D'; // → 'M'
```

```Java
// コードポイントを 10 進数に変換すると、先頭の 「 \u 」 なしで同じ文字を表現することができます。
// 文字の A は、コードポイントで '\u0041' 。それを 10 進数に変換すると 65 になります。
char c1 = 65;
```

他の整数型の型と同じで、 char 型でも、 2 進数、 8 進数、 16 進数で値を代入することが可能です。

```java
// いずれも 65 (文字の A ) を代入しています。
char c1 = 65; // 10 進数
char c2 = 0b0100_0001; // 2 進数 ( Java 7 以降、 0b 始まり、"_" で区切ることもできる)
char c3 = 0101; // 8 進数 ( 0 始まり)
char c4 = 0x41; // 16 進数 ( 0x 始まり)
```

16 進数なら、後述する Unicode のコードポイントと見た目の値が同じになるため (※) 、  
分かりやすくなるケースもあるかもしれません。  
ただし、 char を数字のリテラルで記述する場合は、 UTF-16 というエンコーディングでの数字であって、  
コードポイントとは必ずしも同じになりません。  
例えば、後述するサロゲートペアの範囲の文字は違う値になります。


#### 16 ビットの範囲外にある文字もある

𠮷 (つちよし) や絵文字などは、 16 ビットで表現できる範囲の外に定義された文字です。  
これらの文字は、 32 ビットで表現され、 **サロゲートペア** と呼ばれます。

これらを char 型の変数で表現するには、 char 型の配列を使用します。

例えば、𠮷 (つちよし) は、 Unicode では、 `U+20BB7` と表現されます。  
これを Java の **char 型の配列で扱う場合には、単純に、前後 16 ビットずつに分けることはできません。  
一定の変換処理を行って、 16 ビットのデータ 2 つを生成します。**

変換方法は複雑であるため、変換ツールをネットで検索して使用してください。
「 unicode サロゲートペア 変換」 などのワードで検索すると良いでしょう。

```Java
// 以下の例は、𠮷 (つちよし) の場合の例です。
// 32 ビットで表現される文字データを char 型の変数に代入することはできません。
// NG : コンパイルエラーとなります。
char c1 = '\u20BB7';

// OK : 𠮷 (つちよし) として認識されます。
char[] c2 = { 0xD842, 0xDFB7 };
System.out.println(c2); // → 𠮷
```


### シングルクォーテーション「 ' 」で囲んだ文字は、数値に変換されてから処理される

Java では、シングルクォーテーション「 ' 」で囲んだ文字は、整数値に変換されてから処理されます。  
整数値とは、たいていの場合、 Unicode の 16 進数で表現されたコードポイント `U+FFFF` を  
10 進数に変換した値になります。正確な値は、 Unicode のコード表で、 「整数値」 と記載されている列を  
参照すれば問題ないと思われます。

整数値に変換されるため、例えば、以下のように `==` で数値として比較したり、算術演算が可能です。

```Java
// 'A' は内部的には 65 という数字です。
if ('A' == 65) { // true を返します。
  // do something.
}

// 算術演算が可能です。
int i1 = -'A';
int i2 = 'a' * -1;
int i3 = 'A' + 'a';
System.out.println(i1); // → -65
System.out.println(i2); // → -97
System.out.println(i3); // → 162
```


## String と char 間の変換

別紙 「 char と String 間の変換.md 」 を参照してください。
