<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [ひらがなとカタカナの変換ユーティリティ](#ひらがなとカタカナの変換ユーティリティ)
<!-- TOC END -->


# ひらがなとカタカナの変換ユーティリティ

```java
package com.kurodai0715.winloserecording.utility;

public class StringUtil {

    public static String hiraganaToKatakana(CharSequence input) {

        int i = 0;
        StringBuilder output = new StringBuilder();

        while (i < input.length()) {
            int codePoint = input.toString().codePointAt(i);
            if (Character.isBmpCodePoint(codePoint)) {
                // Unicode コードポイントが、基本多言語面 ( BMP ) の範囲に含まれる場合
                // すなわち、 16 ビットで表現可能な文字である場合

                // 「ひらがな」である場合
                if ((codePoint >= 'ぁ') && (codePoint <= 'ん')) {
                    int offset = 'ア' - 'あ';
                    char katakana = (char) (codePoint + offset);
                    output.append(katakana);
                } else {
                    output.append((char) codePoint);
                }

                // 16 ビットで表現される文字である場合は、インデックスを 1 つ進める。
                i++;
            } else if (Character.isSupplementaryCodePoint(codePoint)) {
                // Unicode コードポイントが補助文字の範囲に含まれる場合
                // すなわち、 16 ビットでは表現不可能であり、 32 ビットで表現可能な文字である場合

                output.append(String.format("%c", codePoint));

                // 32 ビットで表現される文字である場合は、 16 ビットで表現される場合の 2 倍の
                // 領域を使用してデータを保持しているため、インデックスを 2 つ進める必要がある。
                i = i + 2;
            }
        }

        return output.toString();
    }

    public static String katakanaToHiragana(CharSequence input) {

        int i = 0;
        StringBuilder output = new StringBuilder();

        while (i < input.length()) {
            int codePoint = input.toString().codePointAt(i);
            if (Character.isBmpCodePoint(codePoint)) {
                // Unicode コードポイントが、基本多言語面 ( BMP ) の範囲に含まれる場合
                // すなわち、 16 ビットで表現可能な文字である場合

                // 「カタカナ」である場合
                if ((codePoint >= 'ァ') && (codePoint <= 'ン')) {
                    int offset = 'ア' - 'あ';
                    char hiragana = (char) (codePoint - offset);
                    output.append(hiragana);
                } else {
                    output.append((char) codePoint);
                }

                // 16 ビットで表現される文字である場合は、インデックスを 1 つ進める。
                i++;
            } else if (Character.isSupplementaryCodePoint(codePoint)) {
                // Unicode コードポイントが補助文字の範囲に含まれる場合
                // すなわち、 16 ビットでは表現不可能であり、 32 ビットで表現可能な文字である場合

                output.append(String.format("%c", codePoint));

                // 32 ビットで表現される文字である場合は、 16 ビットで表現される場合の 2 倍の
                // 領域を使用してデータを保持しているため、インデックスを 2 つ進める必要がある。
                i = i + 2;
            }
        }

        return output.toString();
    }

}
```
