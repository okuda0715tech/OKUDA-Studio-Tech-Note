<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [ラムダ式](#ラムダ式)
	- [ラムダ式とは](#ラムダ式とは)
	- [なぜラムダ式が生まれたのか](#なぜラムダ式が生まれたのか)
		- [Collections.sort](#collectionssort)
		- [StreamAPI](#streamapi)
		- [forEach](#foreach)
		- [filter](#filter)
		- [map](#map)
		- [sorted](#sorted)

<!-- /TOC -->

# ラムダ式

## ラムダ式とは

後日記載予定

## なぜラムダ式が生まれたのか

そもそもなぜラムダ式が生まれたのでしょうか。
それは値ではなく処理を引数に渡すことで、動的に処理を変更する際に、より直感的な表現で読解しやすいためです。
代表的な例としてCollections.sortやStreamAPIのメソッド群があります。

### Collections.sort

`Collections.sort(List<T>, Comparator<? super T>)`

ソートの方法はオブジェクトの種類や状況によって異なります。
例えば数値を並べ替える場合でも、単純な昇順だったり、絶対値の昇順だったりします。
どちらのソートも実現するためには数値の比較処理を動的に切り替える必要があります。
そのため、Collections.sortは比較の処理自体を受け取る仕組みになっています。

```Java
int[] numbers = {-1, 2, 0, -3, 8};

List<Integer> numbersList = new ArrayList<>();

for(int n : numbers) {
  numbersList.add(n);
}

Collections.sort(numbersList, 【ソート方法】);
```

【ソート方法】にはComparatorインターフェースのcompare(s1, s2)メソッドを実装したインスタンスを指定します。
compareメソッドはパラメータで受け取った二つの項目`s1`,`s2`の前後関係の比較方法を実装します。
あえて、`大小関係の比較`ではなく、`前後関係の比較`と表現しています。なぜなら、compareメソッドは、ソートのための値同士の前後関係を比較するだけであり、その結果は値の大小関係を表しているわけではないためです。
また、compareメソッドの処理は、二つの項目の前後関係の判定を行っているのであり、ソートアルゴリズム自体を実装しているわけではありません。（ソートアルゴリズムはバブルソートなのか何ソートなのかはわかりません。）
compareメソッドは、int型を返し、その返値が正か負かゼロかによって、二項目の前後関係を以下のように判断します。

返値 | 前後関係
-----|---------------
正   | s1が後、s2が前
ゼロ | s1とs2は同じ
負   | s1が前、s2が後

実際にラムダ式を用いてソートしてみましょう。

```Java
Collections.sort(numbersList, (a, b) -> { return a - b; });

for(Integer n : numbersList) {
  System.out.print(n + " ");
}
// -3 -1 0 2 8
```

ラムダ式の内容を変えることでソート順を変更することができます。
降順にしてみましょう。

```Java
Collections.sort(numbersList, (a, b) -> { return b - a; });

for(Integer n : numbersList) {
  System.out.print(n + " ");
}
// 8 2 0 -1 -3
```

絶対値の順にしてみましょう。

```Java
Collections.sort(numbersList, (a, b) -> { return a*a - b*b; });

for(Integer n : numbersList) {
  System.out.print(n + " ");
}
// 0 -1 2 -3 8
```

もちろん、Comparatorを実装した通常クラスのインスタンスを渡しても正常に動作します。
しかし、ラムダ式を使うことで処理そのものを渡しているように見えるので、より簡潔に直感的な記述ができるようになります。


### StreamAPI

Collectionインターフェースにstreamというメソッドが追加されました。
streamメソッドは自分自身のStreamインスタンスを返します。
Streamには関数型インターフェースを引数にとる便利なメソッドがたくさん定義されています。


### forEach

`void forEach(Consumer<T>)`

forEachメソッドはConsumerを引数に取り、要素の数だけ処理を繰り返します。

```Java
int[] numbers = {-1, 2, 0, -3, 8};

List<Integer> numbersList = new ArrayList<>();

for(int n : numbers) {
  numbersList.add(n);
}

numbersList.stream().forEach((i) -> { System.out.print(i + " "); });
// -1 2 0 -3 8
```


### filter

`Stream filter(Predicate<T>)`

filterメソッドはPredicateを引数に取り、条件に合致しないものを除いたStreamを返します。
返ってくるのもStreamなのでそのままForEachメソッドを呼び出すことができます。

```Java
numbersList.stream().filter((i) -> { return i > 0; })
                    .forEach((i) -> { System.out.print(i + " "); });
                    // 2 8
```

filterメソッドは戻り値がStream型なので続けてforEachを呼び出すことができます。
そのため、filterのようなメソッドは中間操作と呼ばれています。
対してforEachのようなメソッドを終端操作と呼びます。


### map

`Stream map(Function<T, R>)`

mapメソッドはFunctionを引数に取り、処理後の結果をStreamにして返します。
filterと同じく中間操作です。

```Java
numbersList.stream().filter((i) -> { return i >= 0; })
                    .map((i) -> { return "*" + i + "*"; })
                    .forEach((s) -> { System.out.print(s + " "); });
                    // *2* *0* *8*
```


### sorted

`Stream sorted(Comparator<T>)`

java.utilパッケージですが、Comparatorを引数に取るsortedメソッドも用意されています。
filterと同じく中間操作です。

```java
numbersList.stream().filter((i) -> { return i >= 0; })
                    .sorted((i1, i2) -> { return i1 - i2; })
                    .map((i) -> { return "*" + i + "*"; })
                    .forEach((s) -> { System.out.print(s + " "); });
                    // *0* *2* *8*
```



