<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [ファイル書き込み](#ファイル書き込み)
	- [〜Streamを使うか〜Writerを使うか](#streamを使うかwriterを使うか)
	- [バッファリングを搭載していない3つのクラスは全く使用しないか？](#バッファリングを搭載していない3つのクラスは全く使用しないか)
	- [サンプルコード](#サンプルコード)
		- [BufferedOutputStreamサンプル](#bufferedoutputstreamサンプル)
		- [BufferedWriterサンプル](#bufferedwriterサンプル)

<!-- /TOC -->


# ファイル書き込み

ファイル書き込みを行うには、以下の5つのクラスから必要なクラスを使用します。

`FileOutputStream, BufferedOutputStream, FileWriter, BufferedWriter, OutputStreamWriter`

詳細は以下の表を参照してください。

クラス名             | バイナリ <-> 文字 変換 | バッファリング有無 | 説明
---------------------|------------------------|--------------------|-----
FileOutputStream     | なし                   | なし               |このクラスのwriteメソッドを使用することはない。なぜなら、バッファリングを搭載している上位クラスが存在するため。
BufferedOutputStream | なし                   | あり               |
FileWriter           | あり                   | なし               |このクラスのwriteメソッドを使用することはない。なぜなら、バッファリングを搭載している上位クラスが存在するため。
BufferedWriter       | あり                   | あり               |
OutputStreamWriter   | あり                   | なし               |このクラスのwriteメソッドを使用することはない。なぜなら、バッファリングを搭載している上位クラスが存在するため。

## 〜 Stream を使うか 〜 Writer を使うか

**〜 Stream はバイナリデータの書き込み、 〜 Writer は文字の書き込み**

クラス名の最後が `Stream` で終わるクラスの `write()`メソッドを使用すると、  
パラメーターで与えたバイナリデータをバイナリのままファイルに書き込む。

つまり、ファイルを開いて中身を見た際に、書き込んだバイナリデータがそのまま表示される。  
例えば、文字コードに沿ったバイナリデータを書き込んだ場合、そのファイルを開いても文字コードが  
表示されるだけで、文字として読むことはできない。

クラス名の最後が `Writer` で終わるものの `write()` メソッドを使用すると、  
パラメーターで与えた文字列を文字としてファイルに書き込む。

つまり、ファイルを開いて中身を見た際に、書き込んだ文字が読める状態でファイルに書き込まれている。

`〜 Writer ` は、 「バイナリ <-> 文字」 変換をしてくれている。  
そのため、パラメーターに文字を渡すことで、内部でバイナリに変換してバイナリのデータを書き込んでくれる。（おそらく。）


## バッファリングを搭載していない3つのクラスは全く使用しないか？

全く使用しないわけではありません。  
writeメソッドを使用しないというだけであり、バッファリングを搭載しているクラスのメソッド使用時に、  
パラメーターとしてこれらのオブジェクトを渡します。


## サンプルコード

### BufferedOutputStreamサンプル

```java
class BOSSample {
    public static void main(String args[]) throws IOException {
        String outputFile = "xxx/aaa.txt";
        // 第二引数を省略時はファイルを上書きします。
        // ファイルが存在しない場合は、第二引数に関わらず新規作成されます。
        FileOutputStream fos = new FileOutputStream(outputFile);
        // 第二引数がtrueの時ファイルに追記します。
        // FileOutputStream fos = new FileOutputStream(outputFile, true);
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        int[] code = {97, 98, 99};

        for(int i = 0; i < code.length; i++) {
            bos.write(code[i]);
        }

        bos.close();
    }
}
```


### BufferedWriterサンプル

**サンプル 1**

サンプル 1 は、 Java の基本的なファイル書き込みです。
Androidではあまり使わないと思います。

```Java
class BWSample1 {
    public static void main(String args[]) throws IOException {
        String outputFile = "/xxx/aaa.txt";
        FileWriter fw = new FileWriter(outputFile);
        BufferedWriter bw = new BufferedWriter(fw);
        bw.write("abcあいう");
        bw.newLine(); //「BufferedWriter」には行区切り文字（改行）のメソッドが用意されています。
        bw.close();
        System.out.println("出力しました。");
    }
}
```


**サンプル 2**

`data/data/パッケージ名/files` ディレクトリの下にサブディレクトリを構築する場合は、  
このサンプル 2 のやり方で実装する必要があります。

```java
public static void createFileOrEditFileContent(String path, String fileName, String content, Context context)
				throws IOException {
		File parent = new File(context.getFilesDir(), path);
		File file = new File(parent, fileName);
		FileOutputStream fos = new FileOutputStream(file);
		OutputStreamWriter osw = new OutputStreamWriter(fos);
		// 文字コードを指定する場合は第二引数に指定します。
		// OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8");
		BufferedWriter writer = new BufferedWriter(osw);
		writer.write(content);
		writer.flush();
		writer.close();
}
```

`context.getFilesDir()` メソッドは、 `data/data/パッケージ名/files` ディレクトリのパスを  
取得するメソッドです。


**サンプル 3**

`files` ディレクトリの下にサブディレクトリを構築せず、 `files` 直下にのみファイルを配置する場合には、  
サンプル 3 の方法を使用します。

```Java
public static void createFileOrEditFileContent(
		String fileName, String content, Context context) throws IOException {
	FileOutputStream fos = context.openFileOutput(fileName, Context.MODE_PRIVATE | Context.MODE_APPEND);
	OutputStreamWriter osw = new OutputStreamWriter(fos);
	BufferedWriter writer = new BufferedWriter(osw);
	writer.write(content);
	writer.flush();
	writer.close();
}
```

ポイントは、 `openFileOutput()` メソッドを使用している点です。  
これにより`files`ディレクトリ直下が自動的に設定されています。

`openFileOutput()` メソッドの第二引数には、 `MODE_PRIVATE` と `MODE_APPEND` があります。

`MODE_PRIVATE` : ファイルを新規作成する。
`MODE_APPEND` : 既存のファイルに追記する。

`Context.MODE_PRIVATE | Context.MODE_APPEND` と指定することにより、ファイルが存在しなければ  
新規作成し、存在していれば追加書き込みをすることが可能です

また、他のアプリからも読み書きができるファイルを作成するための `MODE_WORLD_READABLE` 、  
`MODE_WORLD_WRITABLE` という定数もありますが `API level 17` で非推奨となりました。  

外部アプリとデータ連携を行いたい場合には、 `ContentPrivider` など他の方法で行いましょう。  
なお、 SD カードなど他のアプリがアクセスできる場所に、どうしてもファイルを作成したい場合は、  
データを暗号化するなどの対策が必要になります。
