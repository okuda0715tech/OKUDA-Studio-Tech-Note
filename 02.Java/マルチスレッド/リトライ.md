<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [リトライ](#リトライ)
  - [指定回数リトライするサンプル](#指定回数リトライするサンプル)
<!-- TOC END -->


# リトライ

## 指定回数リトライするサンプル

以下のサンプルは、ワーカースレッドを作成して、一定時間間隔でコールバックを呼び出します。  
コールバック内の処理が完了し、リトライする必要がなくなった場合は、ワーカースレッドの  
`thread.interrupt()` メソッドを呼び出すと、コールバックは呼ばれなくなります。  
`Thread` クラスの仕様として、 `Runnable` が実行し終わるか、もしくは、  
インターラプトが発生するとスレッドは終了します。

```java
public class MultiThread {

    /**
     * 「指定したインターバル」で「指定した回数 + 1 回」のコールバックを行う。
     *
     * @param intervalInMillis インターバル時間[単位:ミリ秒]
     * @param retryCount       リトライ回数（最初の 1 回目のコールバックは含まない）
     * @param callback         コールバックされたいインスタンス
     */
    public static void periodicCallback(long intervalInMillis, int retryCount, Callback callback) {

        Runnable runnable = getRunnable(intervalInMillis, retryCount, callback);

        new Thread(runnable).start();

    }

    private static Runnable getRunnable(long intervalInMillis, int retryCount, Callback callback) {
        return () -> {

            // 初回呼び出し
            callback.call();

            for (int i = 0; i < retryCount; i++) {
                try {
                    Thread.sleep(intervalInMillis);
                } catch (InterruptedException e) {
                    AppLog.lineNumber();
                }
                // 待機後呼び出し
                callback.call();
            }

        };
    }

    public interface Callback {
        void call();
    }
}
```


```java
@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);

    mNendAdRewardedVideo.loadAd(); // 何らかの待機が必要な処理

    watchAdButton.setOnClickListener(v -> {
        MultiThread.periodicCallback(
                interval,
                retryCount,
                getCallback());
    });
}

private MultiThread.Callback getCallback() {
    return () -> {
        Thread workerThread = Thread.currentThread();
        requireActivity().runOnUiThread(() -> tryToShowAd(workerThread));
    };
}

public void tryToShowAd(Thread workerThread) {
    if (mNendAdRewardedVideo.isLoaded()) { // 待機が完了している場合に実行したい処理
        workerThread.interrupt();
        mNendAdRewardedVideo.showAd(requireActivity());
    } else { // 待機が完了していない場合に実行したい処理
        loadingUnfinishedCount++;
        int retryCount = 3;
        if (loadingUnfinishedCount == retryCount + 1) {
            AppSnackBar.showLong(getView(), R.string.timed_out);
        }
    }
}
```
