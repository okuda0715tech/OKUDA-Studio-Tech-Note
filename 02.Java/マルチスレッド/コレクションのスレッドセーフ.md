<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [コレクションのスレッドセーフ](#コレクションのスレットセーフ)
	- [addやremoveなど、コレクションの要素数が変更される処理はスレッドセーフではない。](#addやremoveなどコレクションの要素数が変更される処理はスレッドセーフではない)

<!-- /TOC -->


# コレクションのスレッドセーフ

## addやremoveなど、コレクションの要素数が変更される処理はスレッドセーフではない。

要素の値が変わったり、要素自体がreplaceされる処理はスレッドセーフである。

**対処法**

1. syncronizedブロックで囲む

```Java
List<String> list = new ArrayList<>();

syncronized(list){
  list.add("aaa");
}
```


2. スレッドセーフなコレクション Collections.synchronizedXXX を使用する

```Java
// 忘れないように new でリストを生成する時にsynchronizedListでラップするのことを推奨されている。（JavaDocの推奨）
List<String> list = Collections.synchronizedList(new ArrayList<>());
list.add("aaa");
```

Collections.synchronizedXXXを使用する場合、addやremoveの際は、上記のように普通に処理すれば良い。

しかし、拡張forループでコレクションの中身を参照する場合は、以下のようにsyncronizedブロックでロックする必要がある。

```Java
syncronized(list){
	for(String s : list){
		// do something.
	}
}
```


3. スレッドセーフなコレクション java.util.concurrent.CopyOnWriteArrayList クラスを使用する

```Java
List<String> list = new CopyOnWriteArrayList<>();
```

こちらの方法は二番目の Collections.synchronizedXXX と異なり、拡張forループを使用する場合でもsynchronizedブロックで囲む必要はなく、通常のコレクションのようにアクセスすることができる。

CopyOnWriteArrayListは、addやremoveなど更新を行う時は、コレクションのコピーを生成して、そのコピーに対して更新を行う。

更新と参照は同時に並列に処理することができ、更新中は、更新前のコレクションの参照が行われる。



