- [メモリ可視性の問題](#メモリ可視性の問題)
  - [メモリ可視性の問題の背景](#メモリ可視性の問題の背景)
  - [具体的な問題の例](#具体的な問題の例)
  - [メモリ可視性の問題の解決方法](#メモリ可視性の問題の解決方法)
  - [結論](#結論)


# メモリ可視性の問題

メモリ可視性の問題とは、複数のスレッドが並行して実行されるプログラムにおいて、一つのスレッドで行った変更が他のスレッドに正しく見えない、または遅れて見えることを指します。これは主に、 **CPU キャッシュ** と **メインメモリ** の間の同期の遅れによって生じます。

以下に、メモリ可視性の問題を詳しく説明します：


## メモリ可視性の問題の背景

1. **キャッシュの存在** : 現代のプロセッサは性能を向上させるために、メインメモリ（RAM）の内容をキャッシュに保存します。キャッシュは高速なメモリで、CPUが直接アクセスできます。各スレッドは自分専用のキャッシュを持っていることが多いです。

2. **キャッシュの一貫性** : 一つのスレッドがキャッシュ内の変数の値を更新しても、その変更がすぐに他のスレッドに見えるとは限りません。これは、各スレッドが自分のキャッシュを持っているため、キャッシュ間の同期が必要だからです。


## 具体的な問題の例

例えば、以下のような状況を考えてみます：

```java
public class VisibilityExample {
    private static boolean flag = false;

    public static void main(String[] args) {
        Thread writerThread = new Thread(() -> {
            flag = true; // 変数を更新
        });

        Thread readerThread = new Thread(() -> {
            while (!flag) {
                // フラグが true になるのを待つ
            }
            System.out.println("Flag is true!");
        });

        writerThread.start();
        readerThread.start();
    }
}
```

この例では、writerThread が flag を true に設定し、readerThread がその変更を検出するのを待っています。しかし、メモリ可視性の問題がある場合、readerThread は flag の変更をすぐに検出できない可能性があります。これは、writerThread が flag を更新しても、その変更がメインメモリにすぐに反映されず、readerThread が古い値を見続けることがあるからです。

## メモリ可視性の問題の解決方法

1. **volatile キーワード** : 変数に volatile キーワードを付けると、その変数の読み書きが常にメインメモリで行われるため、すべてのスレッドに対して最新の値が見えるようになります。

```java
public class VisibilityExample {
    private static volatile boolean flag = false;

    public static void main(String[] args) {
        Thread writerThread = new Thread(() -> {
            flag = true;
        });

        Thread readerThread = new Thread(() -> {
            while (!flag) {
                // フラグが true になるのを待つ
            }
            System.out.println("Flag is true!");
        });

        writerThread.start();
        readerThread.start();
    }
}
```

2. **同期機構 (synchronized)** : synchronized ブロックを使用することで、スレッド間のメモリ可視性を確保できます。synchronized ブロックに入る前に、そのスレッドはメインメモリから最新の変数値を読み込み、ブロックを出るときに変数の変更をメインメモリに書き込みます。


## 結論

メモリ可視性の問題は並行プログラミングにおいて重要な課題です。この問題を適切に解決するためには、volatile キーワードや synchronized を使用して、スレッド間でメモリの一貫性を確保する必要があります。AtomicInteger や他の java.util.concurrent.atomic パッケージのクラスも、内部的に適切なメモリ可視性を保証するためにこれらのテクニックを使用しています。




