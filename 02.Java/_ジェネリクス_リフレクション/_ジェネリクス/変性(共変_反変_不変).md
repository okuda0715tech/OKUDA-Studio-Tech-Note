- [変性 (共変 / 反変 / 不変)](#変性-共変--反変--不変)
  - [概要](#概要)
  - [具体例](#具体例)
  - [抽象的な説明](#抽象的な説明)
  - [配列とジェネリクスの不調和](#配列とジェネリクスの不調和)
  - [変性](#変性)
  - [関数の引数与えるパラメータの数を動的に変更する](#関数の引数与えるパラメータの数を動的に変更する)


# 変性 (共変 / 反変 / 不変)

## 概要

共変 (covariant) / 反変 (contravariant) / 不変 (invariant) は、コレクションや配列の性質を表す言葉です。


## 具体例

具体的に説明したほうが早いため、具体的な説明から始めます。

【前提】  
String クラスは Object クラスのサブクラスです。

- `String[]` は `Object[]` のサブクラスなので、 **共変** です。
- `List<String>` と `List<Object>` の間には継承関係は存在しないので、 **不変** です。
- 実際には違いますが、もし `String[]` が `Object[]` のスーパークラスなら **反変** です。


## 抽象的な説明

具体例を見ればわかるため、この項目は見なくても大丈夫です。

前提として、 「クラス A がクラス B のサブクラスである」 とします。

- 共変とは
  - 要素に A を持つ集合体が、要素に B を持つ集合体のサブクラスである場合
- 反変とは
  - 要素に A を持つ集合体が、要素に B を持つ集合体のスーパークラスである場合 (現実的にあまりありえなさそう)
- 不変とは
  - 要素に A を持つ集合体と、要素に B を持つ集合体の間に継承関係が存在しない場合


## 配列とジェネリクスの不調和

配列は 「共変」 、ジェネリクスは 「不変」 の性質を持っているため、  
配列とジェネリクスは組み合わせて使用することができないらしい...が、実際には `E[]` が実装できたので、よくわからない。

```
もし、配列とジェネリクスを混在させていて、コンパイルエラーや警告が出るなら、  
まず試してみることは、配列をリストに置き換えることです。 ( Effective Java 項目 28 より)
```


## 変性

Java の配列は共変ですが、 Kotlin の配列は不変です。

共変とは、 `String` が `Object` のサブクラスなら、 `String[]` も `Object[]` のサブクラスであるということです。

一方、不変とは、 `String` が `Object` のサブクラスであっても、 `String[]` と `Object[]` の間には何の継承関係もないということです。

Kotlin では、実行時にエラーになるのを防ぐために、不変となったようです。

もし、配列の要素で継承関係にあるオブジェクトを扱いたい場合には、 Type projections (型投影？) を使用します。

Type projections とは、 `Array<out Any>` のようなものです。

Type projections に関する公式ドキュメントは [こちら ( Type projections ) ](https://kotlinlang.org/docs/generics.html#type-projections) です。


## 関数の引数与えるパラメータの数を動的に変更する

`vararg` 修飾子を使用することによって、関数の引数に与えるパラメータの数を動的に変更することが可能です。これは、 SQL の結果など、引数の数があらかじめわからない場合に有効です。

```kotlin
fun main() {
    val lettersArray = arrayOf("c", "d")
    // 配列を関数に渡すにはスプレッド演算子 「 * 」 を使用します。
    printAllStrings("a", "b", *lettersArray)
    // abcd
}

// 引数の数が可変の場合は、 vararg 修飾子を付与します。
fun printAllStrings(vararg strings: String) {
    for (string in strings) {
        print(string)
    }
}
```




