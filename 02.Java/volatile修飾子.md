<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [volatile修飾子](#volatile修飾子)
  - [概要](#概要)
  - [キャッシュ値からの読み取りを禁止する](#キャッシュ値からの読み取りを禁止する)
  - [volatileな変数を判定に使用している場合、コンパイル時の最適化が行われないようにする](#volatileな変数を判定に使用している場合コンパイル時の最適化が行われないようにする)
  - [long, double などの64bit数値の読み書きをアトミックにする](#long-double-などの64bit数値の読み書きをアトミックにする)
<!-- TOC END -->


# volatile修飾子

## 概要

volatile修飾子には、以下の三つの役割がある。

- キャッシュ値からの読み取りを禁止する
- コンパイル時の最適化が行われないようにする
- long, double などの64bit数値の読み書きをアトミックにする

それぞれの役割について、以下で説明します。


## キャッシュ値からの読み取りを禁止する

マルチスレッド処理では、フィールドへのアクセスの高速化を図るために、  
フィールドの値を別のメモリ空間にコピーして、そのコピーを参照・更新することがある。  
volatile修飾子には、そのコピーをさせないようにする役割があります。


## volatileな変数を判定に使用している場合、コンパイル時の最適化が行われないようにする

コンパイラは、コードの最適化を行うため、一部の無駄だと思われるコードを書き換えてコンパイルすることがある。  
例えば、以下のような最適化が行われることがある。

```java
public class MyClass {

    boolean flg = true;

    public void a() {
        // 実際に記述したコード
        while(flg){
            System.out.println("hello!");
        }

        // 最適化後のコード
        if(flg){
            while(true){
                System.out.println("hello!");
            }
        }
    }
}
```

上記のような最適化が行われた場合、無限ループに陥ってしまう。

volatile修飾子には、最適化を行わせないようにする役割があります。


## long, double などの64bit数値の読み書きをアトミックにする

アトミックとは、「原子」という意味であり、プログラミングでは、「それ以上分解することができない処理」という意味を持っている。  
プリミティブ型の数値型のうち、 `int` や `float` などの32bit型は、その参照・更新がアトミックであることから、  
マルチスレッド状況下で複数のスレッドが同じフィールドに対して同時に参照・更新を行っても、データの安全性は保障される。  
しかし、 `long` や `double` といった64bit型の変数は、32bitずつの二回に分けて参照・更新を行うため、  
複数のスレッドから同時に参照・更新された場合に、データの安全性が保障されません。  
volatile修飾子には、 `long` や `double` といった64bit型の変数への参照・更新をアトミックに行うようにする役割があります。
