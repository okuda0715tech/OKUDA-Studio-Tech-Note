<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [ファイル操作](#ファイル操作)
	- [getterメソッドでファイル名やパスを取得](#getterメソッドでファイル名やパスを取得)
		- [ファイルの場合](#ファイルの場合)
		- [ディレクトリの場合](#ディレクトリの場合)
	- [ファイル、ディレクトリのリネーム](#ファイルディレクトリのリネーム)
	- [ファイルの削除](#ファイルの削除)
		- [filesディレクトリにサブディレクトリがある場合](#filesディレクトリにサブディレクトリがある場合)
		- [filesディレクトリ直下にのみファイルが存在する場合](#filesディレクトリ直下にのみファイルが存在する場合)
	- [サブディレクトリ内のアイテムも含めてディレクトリを削除](#サブディレクトリ内のアイテムも含めてディレクトリを削除)
	- [あるディレクトリ内のファイル、ディレクトリ一覧の取得](#あるディレクトリ内のファイルディレクトリ一覧の取得)
		- [filesディレクトリにサブディレクトリがある場合](#filesディレクトリにサブディレクトリがある場合)
		- [filesディレクトリ直下にのみファイルが存在する場合](#filesディレクトリ直下にのみファイルが存在する場合)
	- [markとreset](#markとreset)
	- [ファイルの存在確認](#ファイルの存在確認)
	- [ディレクトリの作成](#ディレクトリの作成)

<!-- /TOC -->


# ファイル操作

## getterメソッドでファイル名やパスを取得

### ファイルの場合

`new File(”xxx”)`の`xxx`の部分にファイルが指定された場合

```java
try {
		readFile = new File(”../practice/pom.xml”);

		// 絶対パス(ドットが残る)
		System.out.println(readFile.getAbsolutePath());
		// 絶対パス(ドットは実際のディレクトリ名に変換される)
		System.out.println(readFile.getCanonicalPath());
		// ファイル名のみ
		System.out.println(readFile.getName());
		// パスのみ
		System.out.println(readFile.getParent());
		// パス + ファイル名
		System.out.println(readFile.getPath());

} catch (IOException e) {
		e.printStackTrace();
}
```

**実行結果**

```
readFile.getAbsolutePath()
C:\Documents and Settings\hoge\workspace\practice\..\practice\pom.xml

readFile.getCanonicalPath()
C:\Documents and Settings\hoge\workspace\practice\pom.xml

readFile.getName()
pom.xml

readFile.getParent()
..\practice

readFile.getPath()
..\practice\pom.xml
```

`Canonical`正規という意味です。
正規パスとは、現在のディレクトリを表す「.(ドット)」や一つ上のディレクトリを表す「..(ドット2個)」を実際のディレクトリ名に置き換えたパスのことです。
そのため、`getCanonicalPath()`メソッドでは、「.」や「..」は出てきません。
一方、`getAbsolutePath()`メソッドでは、「.」や「..」はそのまま残り、取得した文字列の中に含まれます。


#### 拡張子なしのファイル名を取得したい場合

上記のgetメソッド郡では、拡張子なしのファイル名を取得することはできないため、自分で拡張子を取り除く必要があります。

以下は、引数に`File`オブジェクトを渡すと、拡張子なしのファイル名を返すメソッドです。

```Java
/**
 * 拡張子なしのファイル名を返すメソッド
 *
 * @param file ファイル名を取得したいファイル
 * @return ファイル名
 */
private String getNameWithoutExtension(File file) {
		String fileName = file.getName();
		if (fileName.contains(".")) {
				// lastIndexOfメソッドで"."が見つからなかった場合は-1が返されて、substringでエラーとなるため、事前にcontainsメソッドでのチェックが必要です。
				return fileName.substring(0, fileName.lastIndexOf("."));
		}
		return fileName;
}
```


### ディレクトリの場合

`new File(”xxx”)`の`xxx`の部分にディレクトリが指定された場合

ファイルが指定された場合と同じ考え方です。
上記のファイルの場合のサンプルの「ファイル名」の部分が「ディレクトリ名」に変わります。


## ファイル、ディレクトリのリネーム

ファイル名、ディレクトリ名を変更する場合には、`File.renameTo(File)`メソッドを使用します。

`RenameSample.java`

```Java
import java.io.File;

public class RenameSample {

    public static void main(String args[]) {

        //Fileオブジェクトを生成する
        File fOld = new File("c:\\test.txt");
        File fNew = new File("c:\\testNew.txt");

        if (fOld.exists()) {
            //ファイル名変更実行
            fOld.renameTo(fNew);
            System.out.println("ファイル名を変更しました。");

        } else {
            System.out.println("ファイルが存在しません。");
        }

    }

}
```

同名のファイル名でパスを変更した場合は移動となります。このメソッドは基本的には例外は発生せず、動作の成否は戻り値で確認する必要があります。trueなら成功、falseなら失敗です。

メソッドの挙動はプラットフォームに依存するため、Windows 系と UNIX 系で動作がことなる場合があります。たとえば、移動先に同名のファイルがある場合などは、Windows 環境では false が返りますが、UNIX 環境では上書きとなり、true が返ります。

自動で指定パスのディレクトリを作成する機能はないため、存在しないディレクトリへの移動はできません。

```java
private static void renameFile(String path, @NonNull String oldFileName, @NonNull String newFileName, Context context)
				throws DataAccessException, AlreadyExistException {
		File parentDir = new File(context.getFilesDir(), path);
		File newFile = new File(parentDir, newFileName);
		File oldFile = new File(parentDir, oldFileName);

		if ((!parentDir.exists()) || (!oldFile.exists())) {
				throw new DataAccessException();
		}

		if (newFile.exists()) {
				throw new AlreadyExistException();
		}

		if (!oldFile.renameTo(newFile)) {
				throw new DataAccessException();
		}
}
```


## ファイルの削除

### filesディレクトリにサブディレクトリがある場合

ファイルを削除するには、Fileクラスのインスタンスメソッドである`delete()`メソッドを使用します。
`delete()`メソッドはbooleanを返します。
削除に成功すれば`true`、失敗すれば`false`を返します。

```java
File f = new File("xxx/aaa.txt");
if(!f.delete()){
	throw new IOException();
}
```

`delete()`メソッドは、ディレクトリを削除することもできますが、削除するディレクトリ配下にファイルやディレクトリがあると削除に失敗します。
配下のアイテムがあっても、それも含めて一気に削除するのが以下の方法です。


### filesディレクトリ直下にのみファイルが存在する場合

```java
if(!context.deleteFile("xxx/aaa.txt")){
	throw new IOException();
}
```


## サブディレクトリ内のアイテムも含めてディレクトリを削除

`apache`ライブラリを使用します。

**build.gradle**

```java
dependencies {
	implementation 'org.apache.commons:commons-io:1.3.2'
}
```


以下のstaticメソッドで、サブディレクトリ内のアイテムも含めてディレクトリを削除することができます。

**Sample.java**

```java
FileUtils.deleteDirectory(File);
```


## あるディレクトリ内のファイル、ディレクトリ一覧の取得


### filesディレクトリにサブディレクトリがある場合


### filesディレクトリ直下にのみファイルが存在する場合

**注意！**
この方法は、filesディレクトリ配下にサブディレクトリが存在しない状況を想定して作られてたメソッドだと思うので、files直下にあるディレクトリは、取得した一覧に含まれているかどうかを検証してから使用してください。

```Java
String[] fileNames = context.fileList();
```


## markとreset

ファイルを一度開いて読み込むと、後戻りができない。
ただし、markとresetを使った場合のみ、markの上限以内ならば戻ることができる。

- これを使うことのメリット
  - ファイルを開き直さなくても再度読み込みだけを行える。
  - markした時点（ファイルの途中）から再度読み込みが行える。


## ファイルの存在確認

ファイルの存在確認には`File.exists()`メソッドを使用します。

注意すべき点は、`File`の実態がファイルだろうとディレクトリだろうと同じ名前ならばtrueを返すという点です。

例えば、既に「AAA」というファイルが存在しており、「AAA」というディレクトリ(Fileオブジェクト)の`exists`メソッドを呼び出した場合は、trueが返ってきます。

この件の対応方法としては、ファイル名には必ず拡張子をつけるようにします。この場合、もし、ディレクトリ名にファイルの拡張子と同じ拡張子がついていた場合は、`exists`メソッドのリターンがtrueになりますが、そのケースはレアなため、その時に対応を考えれば良いでしょう。


## ディレクトリの作成

ディレクトリを作成するには`File.mkdir()`メソッドを使用します。

作成に成功すればtrue、失敗すればfalseを返します。


```java
File directory = new File("path","directory_name");
if (directory.mkdir()) {
	throw new DataAccessException();
}
```


注意すべき点は、`mkdir`メソッドはディレクトリの作成メソッドであるにもかかわらず、作ろうとしているディレクトリ名と同じ名前のファイルが存在しているとディレクトリが作れない点です。

対応方法としては、ファイル名には必ず拡張子をつけるようにします。


## ファイルかディレクトリかの判定

```java
File file = new File("directory", "file.txt");
file.isFile();
file.isDirectory();
```



