<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [例外の概念](#例外の概念)
	- [例外の種類](#例外の種類)
		- [どの異常にも共通すること](#どの異常にも共通すること)
		- [Error](#error)
		- [Exception](#exception)
		- [RuntimeException](#runtimeexception)
		- [RuntimeException以外のException](#runtimeexception以外のexception)
	- [検査例外と非検査例外（チェック例外と非チェック例外）](#検査例外と非検査例外チェック例外と非チェック例外)
	- [ログの表示のされ方](#ログの表示のされ方)
	- [作り方](#作り方)
	- [例外処理のポイント](#例外処理のポイント)
		- [ポイント1 : 例外は細かくcatchする。](#ポイント1--例外は細かくcatchする)

<!-- /TOC -->

# 例外の概念

## 例外の種類

以下の図の通り、例外は大きく4種類に分けることができる。

Throwable

├── Error

└── Exception

　　　├── RuntimeException

　　　└── RuntimeException以外のException

1. Error
2. Exception
3. RuntimeException
4. RuntimeException以外のException

上記からわかる通り、この4つをまとめて「例外」と表現すると、`Exception`クラスのことを指しているようで紛らわしいので、ここでは「異常」と表現することにする。


### どの異常にも共通すること

- 4つとも実行時になって初めて発生する異常である。
- つまり、コンパイル時には発生するかどうか、まだわからない。
- もし発生した場合はプログラムは強制終了する。
  - catch した場合は強制終了しません。


### Error

**Errorは、アプリで対処不可能な状況を表す異常です。**
**つまり、アプリではErrorが発生するのを防ぐこともできなければ、発生時に対処することもできません。**
代表的なものにOutOfMemoryErrorやClassFormatError(クラスファイルが壊れている)があります。
これらの状況はOSレベルで対処すべき問題であるため、アプリで予防（事前チェック）したり対処（catch）したりする必要はありませんし、できません。


### Exception

アプリで対処が可能な異常です。
例外の種類によっては、予防することも可能です。
予防することができるかどうかによって、RuntimeExceptionとそれ以外のExceptionに分けることができます。


### RuntimeException

アプリで発生を予防することもできるし、予防せずに、事後に対処（`catch`）することもできる異常です。  

**注意**  
名前だけ見ると、いかにも「コンパイル時には発見できない、実行時に初めて発見できる `Exception` です。」  
と言わんばかりのException名だが、それはここで取り上げている4つの異常に共通することであり、  
この `RuntimeException` に限ったことではありません。

代表的なものに `NumberFormatException` があります。

**ポイント**  
事前に予防ができるため、 `catch` していない場合でも、コンパイル時にはエラーになりません。  
このクラスを継承して作成したカスタムエラークラスもコンパイル時にはエラーになりません。  
事前に予防しているべきであるため、 `catch` が不要であるという考え方です。  
~~むしろ、 `catch` するべきではないと思います。~~ 必ず `catch` して、エラーメッセージを画面に表示するようにしてください。必要に応じて、ログの出力と送信も行いましょう。なぜなら、もし、アプリがクラッシュしてしまった場合は、アプリからメッセージを表示することができず、ユーザーは原因を推測したり、特定することが困難になってしまうためです。


### RuntimeException以外のException

この異常は、発生する可能性があるにも関わらず、アプリで事前に予防することができません。  
そのため、必ず事後処理（catch）を実装し、発生に備える必要がある異常です。

**ポイント**
事前に予防ができないため、 `catch` を実装していないと、コンパイル時に必ずエラーになります。  
このクラスを継承して作成したオリジナルのエラークラスもコンパイル時はエラーになります。


## 検査例外と非検査例外（チェック例外と非チェック例外）

上記の「例外の種類」で説明した `RuntimeException` が「非検査例外（非チェック例外）」、  
`RuntimeException以外のException` が「検査例外（チェック例外）」です。

「検査」とは、プログラムの `catch` を表しており、「検査＝catchが必須」、  
「非検査＝（事前回避している可能性があるため） `catch` が必須ではない」という意味になります。


## ログの表示のされ方

Exceptionをcatchして、そのcatchブロックのパラメータで受け取った`(IOException e)`をそのcatchブロック中で更に`new throw MyIOException(e);`などとしてnew throwした場合、ログには以下のように途中で発生したIOExceptionと最終的に発生したMyIOExceptionが両方出力される。

```
MyIOException: IOException: ファイルを開けません。
    at ClassA.methodA(ClassA.java:10)
    at ClassB.methodB(ClassB.java:5)
Caused by:IOException: ファイルを開けません。
    at ClassA.methodA(ClassA.java:10)
```


## 作り方

サンプル

```Java
public class SampleException extends Exception {
    public SampleException(String message) {
        super(message);
    }
}
```

コンストラクタ内でsuper(message)とすると、ログにログクラス名と一緒にそのメッセージが出力される。

**検査例外と非検査例外**

検査例外を作りたい場合は、`java.lang.Exception`クラスを継承する。  
非検査例外を作りたい場合は、`java.lang.RuntimeException`クラスを継承する。


## 例外処理のポイント

### ポイント1 : 例外は細かくcatchする。

Exceptionには様々な子孫例外クラスが存在しています。
それらを単純に`catch(Exception e)`として`Exception`クラスでキャッチしてしまうと、様々なエラーが同一の方法で対処されてしまいます。
本来、発生したエラーの種類によって対処の仕方が異なることが考えられますので、大きなクラスでキャッチせず、細かいクラスでキャッチする方が良いと考えられます。
