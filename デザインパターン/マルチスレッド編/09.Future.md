- [Future](#future)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [Kotlin のコルーチンでは、 Deferred と async を使用する](#kotlin-のコルーチンでは-deferred-と-async-を使用する)
  - [使いどころ](#使いどころ)
    - [1. 並列で複数の非同期処理を走らせて、それらの結果を使って画面を描画する](#1-並列で複数の非同期処理を走らせてそれらの結果を使って画面を描画する)
    - [2. 画面ロード時にデータ取得を開始し、別の処理が終わったあとにそのデータを使う](#2-画面ロード時にデータ取得を開始し別の処理が終わったあとにそのデータを使う)
    - [3. Compose の画面描画と同時にバックグラウンドで処理をスタートし、後でその値を表示に使う](#3-compose-の画面描画と同時にバックグラウンドで処理をスタートし後でその値を表示に使う)
  - [引用元資料](#引用元資料)


# Future

## 役割

非同期で実行した処理が完了したら、その結果を受け取ります。

Thread-Per-Message パターンや Worker Thread パターンでは、非同期で実行された処理の結果を、呼び出し側に直接返すことができません。 (ただし、変数に格納するなどして、実質的に結果をセットすることは可能です。)  Future パターンでは、コルーチンを開始した時に返される Deferred オブジェクトを保持することで、後から、非同期処理の結果を受け取ることが可能です。


## 実装方法

### Kotlin のコルーチンでは、 Deferred と async を使用する

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val futureValue: Deferred<String> = async {
        delay(1000)  // 1秒待つ（疑似的な重い処理）
        "結果データ"
    }

    println("非同期処理中...")

    // 必要になった時に await() で結果を取得する。
    // await() は、 suspend 関数です。
    val result = futureValue.await()
    println("取得結果: $result")
}
```


## 使いどころ

### 1. 並列で複数の非同期処理を走らせて、それらの結果を使って画面を描画する

```kotlin
val userDeferred = async { api.getUser() }
val postsDeferred = async { api.getPosts() }

val user = userDeferred.await()
val posts = postsDeferred.await()
```

👉 複数の処理を **並列で実行** して、後から結果を受け取るというのが、 Deferred でしかできない重要な使い方です。

つまり、 userDeferred.await() で、処理が完了するのを待っている間に、既に、 api.getPosts() の処理は開始されています。


### 2. 画面ロード時にデータ取得を開始し、別の処理が終わったあとにそのデータを使う

```kotlin
val dataFuture = async { repository.loadData() }

// 他のUI処理など…

val data = dataFuture.await()
```

👉 「先に実行開始 → 後で取得」という 将来の値の保持 にぴったり。


### 3. Compose の画面描画と同時にバックグラウンドで処理をスタートし、後でその値を表示に使う

```kotlin
val future = remember {
    coroutineScope.async {
        heavyCalculation()
    }
}

LaunchedEffect(Unit) {
    val result = future.await()
    // 結果をステートに反映してUIに出す
}
```


## 引用元資料

- ChatGPT


