- [Thread-Per-Message](#thread-per-message)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [例：1つのキューにメッセージを送り、各メッセージを独立したコルーチンで処理する](#例1つのキューにメッセージを送り各メッセージを独立したコルーチンで処理する)
  - [使いどころ](#使いどころ)
    - [チャットアプリのメッセージ送受信](#チャットアプリのメッセージ送受信)
    - [画面表示用のデータ取得リクエスト（UIイベント）](#画面表示用のデータ取得リクエストuiイベント)
  - [引用元資料](#引用元資料)


# Thread-Per-Message

## 役割

メッセージ(命令 or リクエスト)ごとに、一つの専用のスレッド or コルーチンを割り当てます。

- メッセージを送った側は、すぐに手が空くため、別の処理を開始できます。
- スレッド or コルーチンを共有せず、処理ごとに専用のスレッド or コルーチンを割り当てるため、スレッド or コルーチンが共有されることによる問題を回避できます。

**参考** : コルーチンにおいて、 Thread-Per-Message パターンと Worker Thread パターンの区別はありません。詳細は、 [Thread-Per-Message と Worker Thread の違い](./Thread-Per-Message%20と%20Worker%20Thread%20の違い.md) を参照してください。


## 実装方法

### 例：1つのキューにメッセージを送り、各メッセージを独立したコルーチンで処理する

基本的には、処理ごとに新しいコルーチンを開始するだけの簡単なパターンだと思われます。

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

// メッセージクラス（Command パターン的な）
sealed class Message {
    data class PrintMessage(val text: String) : Message()
    object Stop : Message()
}

// メッセージを処理する Dispatcher
class MessageDispatcher {

    private val scope = CoroutineScope(Dispatchers.Default)
    private val messageChannel = Channel<Message>()

    init {
        // Dispatcher スレッド：メッセージを受け取ったら、それごとにコルーチンを立てて処理する
        scope.launch {
            for (message in messageChannel) {
                // Thread-Per-Message → コルーチンで処理を分離
                launch {
                    handleMessage(message)
                }
            }
        }
    }

    private suspend fun handleMessage(message: Message) {
        when (message) {
            is Message.PrintMessage -> {
                println("Handling: ${message.text} (on ${Thread.currentThread().name})")
                delay(500) // 擬似的な重い処理
            }
            Message.Stop -> {
                println("Shutting down dispatcher")
                messageChannel.close()
            }
        }
    }

    fun postMessage(message: Message) {
        scope.launch {
            messageChannel.send(message)
        }
    }
}
```

使用側：

```kotlin
fun main() = runBlocking {
    val dispatcher = MessageDispatcher()

    dispatcher.postMessage(Message.PrintMessage("Hello"))
    dispatcher.postMessage(Message.PrintMessage("World"))
    dispatcher.postMessage(Message.PrintMessage("Kotlin Coroutines"))

    delay(2000)
    dispatcher.postMessage(Message.Stop)
}
```


## 使いどころ

使いどころとしては、複数のサーバーリクエストを並列して実行する場合に使用されることが多いです。

### チャットアプリのメッセージ送受信

- ユーザーが送信したメッセージごとに独立した処理が必要（例：送信、サーバー応答待ち、失敗時のリトライ）。
- 各メッセージ処理は非同期で、他の送信と独立。

🧩 Thread-Per-Message により：

- 各送信はコルーチンで並列処理され、他の送信に影響を与えない。
- 送信失敗時のリトライやタイムアウト制御も個別に行える。


### 画面表示用のデータ取得リクエスト（UIイベント）

- RecyclerView で各アイテムが個別の画像やサムネイルをロードするようなケース。
- ユーザーがスクロールするたびに新しいリクエストが来る。

🧩 各ロードリクエストを独立したコルーチンで処理。前のリクエストをキャンセルすることも可能。


## 引用元資料

- ChatGPT


