- [Flyweight パターン](#flyweight-パターン)
  - [役割](#役割)
  - [主な登場人物](#主な登場人物)
  - [実装方法](#実装方法)
  - [使いどころ](#使いどころ)
    - [グラフやマップで大量のマーカーを表示するようなケース](#グラフやマップで大量のマーカーを表示するようなケース)
  - [カスタム View / Compose で複雑なパターン描画をする時](#カスタム-view--compose-で複雑なパターン描画をする時)
    - [カスタムチャート・データ可視化などでのシンボル共有](#カスタムチャートデータ可視化などでのシンボル共有)


# Flyweight パターン

## 役割

インスタンスをできる限り共有し、メモリ使用量やインスタンス生成コストを下げます。

インスタンスを共有する際に、共有すべきデータと、共有すべきではないデータをしっかりと区別する必要があります。共有すべきデータは **intrinsic なデータ** と呼ばれ、共有すべきではないデータは **extrinsic なデータ** と呼ばれます。

intrinsic には、「内部に備え持っている」という意味があり、 extrinsic には、「外部からうけとった」という意味があります。

## 主な登場人物

- Flyweight
  - 共有されるオブジェクトのインターフェース。内部状態を持つ。
- ConcreteFlyweight
  - Flyweight の具体的な実装。内部状態を保持し、外部状態を操作の引数などで受け取る。
- FlyweightFactory
  - Flyweight を生成・管理。すでに存在するものがあればそれを返す（再利用）。
- Client
  - Flyweight を利用する側。外部状態を保持し、それを渡して操作する。


## 実装方法

以下のサンプルは、 1 ～ 3 の数字をアスキーアートのような文字列に変換して、それを標準出力に表示するものです。

```kotlin
// Flyweight
interface NumGlyph {
    fun draw(position: Int)
}

// ConcreteFlyweight
class NumCharacter(private val number: Int) : NumGlyph {

    // 内部状態：数字に対応する ASCII アート
    private val art = when (number) {
        1 -> """
            #
           ##
          # #
            #
            #
            #
          #####
        """.trimIndent()

        2 -> """
          #####
              #
              #
           ####
          #    
         #     
         ######
        """.trimIndent()

        3 -> """
          #####
              #
              #
           ####
              #
              #
          #####
        """.trimIndent()

        else -> "Invalid number"
    }

    override fun draw(position: Int) {
        println("Position $position:\n$art\n")
    }
}

// FlyweightFactory
object NumGlyphFactory {
    private val pool = mutableMapOf<Int, NumGlyph>()

    fun getGlyph(number: Int): NumGlyph {
        require(number in 1..3) { "Only numbers 1 to 3 are supported." }
        return pool.getOrPut(number) { NumCharacter(number) }
    }
}

// Client
fun main() {
    val numbers = listOf(1, 2, 3, 1, 2, 3, 1)

    numbers.forEachIndexed { index, num ->
        val glyph = NumGlyphFactory.getGlyph(num) // 共有オブジェクトを取得
        glyph.draw(index)
    }
}
```

実行結果：

```text
Position 0:
  #
 ##
# #
  #
  #
  #
#####

Position 1:
#####
    #
    #
 ####
#    
#    
######

...
```

## 使いどころ

インスタンスの生成が繰り返し必要なケースで、パフォーマンスを改善したい場合は、共通データ部分に対して Flyweight パターンの導入を検討すると良いかもしれません。


### グラフやマップで大量のマーカーを表示するようなケース

省略


## カスタム View / Compose で複雑なパターン描画をする時

例：

- 数独やパズルなど、同じ見た目のセルが大量にある
- 各セルが「色・形・サイズ」などで共通要素を持っている

解決策：

- 「共通のデザイン」や「アイコン」を Flyweight オブジェクトとして使い、個別の位置や状態（選択状態など）だけを外部状態として渡す


### カスタムチャート・データ可視化などでのシンボル共有

例：

- グラフ上に多数の「同じアイコン（点・棒・ラベル）」を描く

解決策：

- 同じデータポイントの描画用 Flyweight オブジェクトを使って再利用






