- [Proxy パターン](#proxy-パターン)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [Kotlin を用いた実装方法](#kotlin-を用いた実装方法)
      - [関数を直接ラップするアプローチ](#関数を直接ラップするアプローチ)
      - [オブジェクト経由で関数をラップするアプローチ](#オブジェクト経由で関数をラップするアプローチ)
  - [使いどころ](#使いどころ)
    - [API 通信のラッパーに使う（セキュリティ・ログ・キャッシュ）](#api-通信のラッパーに使うセキュリティログキャッシュ)
      - [🎯 目的](#-目的)
      - [💡 使いどころ](#-使いどころ)
    - [ViewModel → Repository 間のアクセス制御・リトライ制御などに](#viewmodel--repository-間のアクセス制御リトライ制御などに)
      - [🎯 目的](#-目的-1)
      - [💡 例](#-例)
    - [重い処理の遅延初期化（Virtual Proxy）](#重い処理の遅延初期化virtual-proxy)
      - [🎯 目的](#-目的-2)
    - [テスト用のモック差し替え](#テスト用のモック差し替え)
      - [🎯 目的](#-目的-3)
      - [💡 例](#-例-1)


# Proxy パターン

Proxy には、「代理人」という意味があります。


## 役割

特定の機能を利用する際に、先に代理オブジェクトにアクセスし、本物の機能の前後に何らかの処理を実行します。

ユニットテストのテストダブルの一種である 「スパイ」 オブジェクトは、この Proxy パターンを使用して実現されています。


## 実装方法

### Kotlin を用いた実装方法

Kotlin では関数を一級オブジェクトとして扱えるため、 Proxy パターンががシンプルに実現できます。

#### 関数を直接ラップするアプローチ

```kotlin
// 実際の処理（本体）
fun fetchData(): String {
    println("Fetching data...")
    return "data"
}

// 関数型 Proxy（前後に処理を挟む）
fun <T> proxy(action: () -> T): T {
    println("Before action")
    val result = action()
    println("After action")
    return result
}

// 使用例
fun main() {
    val result = proxy { fetchData() }
    println("Result: $result")
}
```


#### オブジェクト経由で関数をラップするアプローチ

```kotlin
interface Service {
    fun execute()
}

class RealService : Service {
    override fun execute() {
        println("RealService: Executing")
    }
}

// Proxy を関数でラップ
fun proxy(service: Service): Service = object : Service {
    override fun execute() {
        println("Proxy: Before execute")
        service.execute()
        println("Proxy: After execute")
    }
}

// 使用例
fun main() {
    val real = RealService()
    val proxied = proxy(real)
    proxied.execute()
}
```


## 使いどころ

### API 通信のラッパーに使う（セキュリティ・ログ・キャッシュ）

#### 🎯 目的

- API の前後でログを取る
- 特定の条件（例：未ログイン）では API を呼ばない
- キャッシュがある場合はネットワーク通信をスキップ


#### 💡 使いどころ

例えば、UserApi にアクセスする前にログインチェックを挟みたいとき：

```kotlin
interface UserApi {
    suspend fun getUserProfile(): UserProfile
}

class RealUserApi : UserApi {
    override suspend fun getUserProfile(): UserProfile {
        // Retrofitなどを使った実際のAPI通信
    }
}

class UserApiProxy(
    private val realApi: RealUserApi,
    private val sessionManager: SessionManager
) : UserApi {
    override suspend fun getUserProfile(): UserProfile {
        if (!sessionManager.isLoggedIn()) {
            throw IllegalStateException("ログインが必要です")
        }
        println("UserApiProxy: API呼び出し前にログを記録")
        return realApi.getUserProfile()
    }
}
```


### ViewModel → Repository 間のアクセス制御・リトライ制御などに

#### 🎯 目的

- リトライ処理
- トークン自動更新
- 統一的なエラーハンドリング


#### 💡 例

```kotlin
interface MyRepository {
    suspend fun fetchData(): Result<String>
}

class MyRepositoryImpl : MyRepository {
    override suspend fun fetchData(): Result<String> {
        // 通常の処理
    }
}

class MyRepositoryProxy(
    private val real: MyRepositoryImpl,
    private val retryPolicy: RetryPolicy
) : MyRepository {
    override suspend fun fetchData(): Result<String> {
        return retryPolicy.runWithRetry {
            real.fetchData()
        }
    }
}
```


### 重い処理の遅延初期化（Virtual Proxy）

#### 🎯 目的

- 大量データの読み込みや画像のロードを遅延する
  - 実際のデータが読み込まれるまで、シマー（Shimmer）を表示する等
    - シマーとは、コンテンツがまだ読み込まれていないときに、読み込まれる予定のコンテンツの形（たとえば画像やテキストのブロックなど）に沿って配置されるプレースホルダーです。
    - キラキラと光が流れるようなアニメーションが付いています。これにより、「今データを読み込んでいますよ」ということがユーザーに視覚的に伝わります。
- 初回アクセス時のみ初期化

```kotlin
interface ImageLoader {
    fun loadImage(view: ImageView)
}

class RealImageLoader(private val url: String) : ImageLoader {
    override fun loadImage(view: ImageView) {
        Glide.with(view).load(url).into(view)
    }
}

class LazyImageLoaderProxy(private val url: String) : ImageLoader {
    private var realLoader: RealImageLoader? = null

    override fun loadImage(view: ImageView) {
        if (realLoader == null) {
            // 初回アクセス時のみインスタンスを生成します。
            realLoader = RealImageLoader(url)
        }
        realLoader?.loadImage(view)
    }
}
```

上記のように実装することで、 loadImage を呼び出したいときに、毎回 ImageLoader インスタンスが生成されているかを気にすることなく、 loadImage を呼び出せます。


### テスト用のモック差し替え

#### 🎯 目的

- 実際の機能はそのまま使いたいが、一部だけ差し替えたいとき


#### 💡 例

テスト時にのみログ出力したい場合：

```kotlin
class LoggingRepositoryProxy(
    private val real: MyRepository
) : MyRepository {
    override suspend fun fetchData(): Result<String> {
        println("LoggingProxy: fetchData が呼ばれた")
        return real.fetchData()
    }
}
```

テスト時に、強制的にエラーを発生させたい場合：

```kotlin
class TestUserRepositoryProxy(
    private val real: UserRepository
) : UserRepository {

    var forceError = false

    override suspend fun getUser(): User {
        if (forceError) {
            throw IllegalStateException("テスト用の強制エラー")
        }
        return real.getUser()
    }
}
```

```kotlin
// 呼び出し側

val realRepo = RealUserRepository()
val proxyRepo = LoggingUserRepositoryProxy(realRepo)

// ViewModel に渡すと、内部的には本物を使うけどログも出る
val viewModel = UserViewModel(proxyRepo)
```








