- [Repository パターン](#repository-パターン)
  - [Repository パターンとは？](#repository-パターンとは)
  - [主な役割・目的](#主な役割目的)
  - [イメージ図](#イメージ図)
  - [例：簡単な Repository のコード（Kotlin）](#例簡単な-repository-のコードkotlin)
    - [モックのサンプル（Mockito + JUnit）](#モックのサンプルmockito--junit)
      - [1. Repository のインターフェース](#1-repository-のインターフェース)
      - [2. モックを使った ViewModel テストの例](#2-モックを使った-viewmodel-テストの例)
      - [3. ViewModel のサンプル](#3-viewmodel-のサンプル)
      - [4. Coroutine テストルール（必要に応じて）](#4-coroutine-テストルール必要に応じて)
      - [必要な依存関係（build.gradle）](#必要な依存関係buildgradle)


# Repository パターン

Repository パターンの役割は、データアクセスの抽象化と疎結合なアーキテクチャの実現です。もう少し具体的に言うと：


## Repository パターンとは？

Repository パターンは、データソース（DB・ネットワーク・キャッシュなど）へのアクセスを管理する中間層を作るパターンです。


## 主な役割・目的

- データ取得の抽象化
  - ViewModel や UseCase が「どこからデータを取ってくるか」を意識しないようにする。例えば、ネットワークからでもローカル DB からでも、呼び出す側は同じインターフェースで扱える。
- 責務の分離
  - データ取得の処理を Repository にまとめることで、UI やビジネスロジックのコードをシンプルに保てる。
- テストしやすさ
  - インターフェース（interface Repository）を使うことで、モックを簡単に差し替えられるようになり、ユニットテストがしやすくなる。
- 複数データソースの統合
  - ネットワーク・DB・キャッシュなどを使い分けるような複雑な処理も、Repository にまとめることで ViewModel 側をスリムに保てる。


## イメージ図

```markdown
ViewModel
   ↓
UseCase（あれば）
   ↓
Repository ←→ RemoteDataSource（API）
           ←→ LocalDataSource（Roomなど）
```


## 例：簡単な Repository のコード（Kotlin）

```kotlin
interface UserRepository {
    suspend fun getUser(id: String): User
}

class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource
) : UserRepository {

    override suspend fun getUser(id: String): User {
        return try {
            val user = remoteDataSource.fetchUser(id)
            localDataSource.saveUser(user)
            user
        } catch (e: Exception) {
            localDataSource.getUser(id) // fallback to cache
        }
    }
}
```


### モックのサンプル（Mockito + JUnit）

#### 1. Repository のインターフェース

```kotlin
interface UserRepository {
    suspend fun getUser(id: String): User
}
```


#### 2. モックを使った ViewModel テストの例

```kotlin
@ExperimentalCoroutinesApi
class UserViewModelTest {

    @get:Rule
    val coroutineRule = MainDispatcherRule() // Coroutine のテスト用ルール（後述）

    private lateinit var userRepository: UserRepository
    private lateinit var viewModel: UserViewModel

    @Before
    fun setUp() {
        userRepository = mock() // ← Mockito Kotlin 拡張でスッキリ書ける！
        viewModel = UserViewModel(userRepository)
    }

    @Test
    fun `getUser returns expected user`() = runTest {
        // Arrange
        val expectedUser = User(id = "123", name = "Alice")
        whenever(userRepository.getUser("123")).thenReturn(expectedUser)

        // Act
        viewModel.loadUser("123")

        // Assert
        assertEquals(expectedUser, viewModel.user.value)
    }
}
```


#### 3. ViewModel のサンプル

```kotlin
class UserViewModel(private val repository: UserRepository) : ViewModel() {
    private val _user = MutableStateFlow<User?>(null)
    val user: StateFlow<User?> = _user

    fun loadUser(id: String) {
        viewModelScope.launch {
            _user.value = repository.getUser(id)
        }
    }
}
```


#### 4. Coroutine テストルール（必要に応じて）

```kotlin
@ExperimentalCoroutinesApi
class MainDispatcherRule(
    val testDispatcher: TestDispatcher = StandardTestDispatcher()
) : TestWatcher() {

    override fun starting(description: Description) {
        Dispatchers.setMain(testDispatcher)
    }

    override fun finished(description: Description) {
        Dispatchers.resetMain()
    }
}
```


#### 必要な依存関係（build.gradle）

```kotlin
// Coroutine test
testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")

// Mockito（Kotlin拡張付き）
testImplementation("org.mockito.kotlin:mockito-kotlin:5.1.0")

// JUnit
testImplementation("junit:junit:4.13.2")
```



