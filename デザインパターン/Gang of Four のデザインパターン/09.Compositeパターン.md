- [Composite パターン](#composite-パターン)
  - [役割](#役割)
  - [実装方法](#実装方法)
  - [使いどころ](#使いどころ)
    - [バリデーションルールの構成](#バリデーションルールの構成)
    - [オプションメニュー、ドロワー、カテゴリ一覧など、階層的なデータ構造を表現するとき](#オプションメニュードロワーカテゴリ一覧など階層的なデータ構造を表現するとき)
    - [独自の DSL（Domain Specific Language）を作成する場合](#独自の-dsldomain-specific-languageを作成する場合)
    - [カテゴリ一覧（ツリー構造）の例](#カテゴリ一覧ツリー構造の例)


# Composite パターン

## 役割

「中身を表すオブジェクト」と「入れ物を表すオブジェクト」に共通の抽象クラスを定義して同一視する。


## 実装方法

省略


## 使いどころ

### バリデーションルールの構成

```kotlin
interface Validator {
    fun validate(input: String): Boolean
}

// 単体のルール
class NotEmptyValidator : Validator {
    override fun validate(input: String) = input.isNotEmpty()
}

class EmailValidator : Validator {
    override fun validate(input: String) = input.contains("@")
}

// 複数ルールを束ねる
class CompositeValidator : Validator {
    private val validators = mutableListOf<Validator>()

    fun add(validator: Validator) {
        validators.add(validator)
    }

    override fun validate(input: String): Boolean {
        // List の all() 関数は、すべての要素が条件を満たすかどうかをチェックする関数です。
        // 一つでも条件を満たさない要素が存在した場合は、 all() は false を返し、
        // すべての要素が条件を満たせば、 true を返します。
        return validators.all { it.validate(input) }
    }
}
```

上記の例では、 Tree 構造に見えないかもしれません。例えば、ログイン ID を入力するフォームが、電話番号と E メールに対応している場合について考えてみましょう。あらかじめ、電話番号用の CompositeValidator と、 E メール用の CompositeValidator を作成しておき、それらを子に持つ CompositeValidator を作成すれば、 Tree 構造となる、 Composite パターンの効果が見いだせるでしょう。


### オプションメニュー、ドロワー、カテゴリ一覧など、階層的なデータ構造を表現するとき

省略


### 独自の DSL（Domain Specific Language）を作成する場合

Jetpack Compose のように Tree 構造になる可能性が高いです。


### カテゴリ一覧（ツリー構造）の例

Jetpack Compose で、以下のようなカテゴリ一覧を作成するサンプルを提示します。

```markdown
+ All Categories
  + Electronics
    - Smartphones
    - Laptops
  + Fashion
    + Men's
      - Shirts
      - Pants
    - Women's
```

```kotlin
// 共通のインターフェース

interface CategoryComponent {
    val name: String
    fun display(indent: String = "")
}
```

```kotlin
// リーフ

class CategoryItem(override val name: String) : CategoryComponent {
    override fun display(indent: String) {
        println("$indent- $name")
    }
}
```

```kotlin
// コンポジット

class CategoryGroup(
    override val name: String
) : CategoryComponent {
    private val children = mutableListOf<CategoryComponent>()

    fun add(child: CategoryComponent) {
        children.add(child)
    }

    override fun display(indent: String) {
        println("$indent+ $name")
        children.forEach { it.display(indent + "  ") }
    }
}
```

```kotlin
// 使用側

fun main() {
    val rootCategory = CategoryGroup("All Categories")

    val electronics = CategoryGroup("Electronics")
    electronics.add(CategoryItem("Smartphones"))
    electronics.add(CategoryItem("Laptops"))

    val fashion = CategoryGroup("Fashion")
    val mensWear = CategoryGroup("Men's")
    mensWear.add(CategoryItem("Shirts"))
    mensWear.add(CategoryItem("Pants"))
    fashion.add(mensWear)
    fashion.add(CategoryItem("Women's"))

    rootCategory.add(electronics)
    rootCategory.add(fashion)

    rootCategory.display()
}
```

```kotlin
@Composable
fun CategoryTreeView(category: CategoryComponent, indent: Int = 0) {
    when (category) {
        is CategoryItem -> {
            Text(text = "- ${category.name}", modifier = Modifier.padding(start = indent.dp))
        }
        is CategoryGroup -> {
            Text(text = "+ ${category.name}", modifier = Modifier.padding(start = indent.dp))
            category.children.forEach {
                // Jetpack Compose でも、コンポーザブル関数の再帰呼び出しは可能です。
                CategoryTreeView(it, indent + 16)
            }
        }
    }
}
```

折りたたみに対応した例は以下です。折りたたみ状態を管理したい場合、 `remember { mutableStateOf(...) }` を再帰内で使います。

```kotlin
@Composable
fun CategoryTreeView(category: CategoryComponent, indent: Int = 0) {
    var expanded by remember { mutableStateOf(true) }

    when (category) {
        is CategoryItem -> {
            Text(text = "- ${category.name}", modifier = Modifier.padding(start = indent.dp))
        }
        is CategoryGroup -> {
            Column(modifier = Modifier.padding(start = indent.dp)) {
                Text(
                    text = if (expanded) "[-] ${category.name}" else "[+] ${category.name}",
                    modifier = Modifier.clickable { expanded = !expanded }
                )
                if (expanded) {
                    category.children.forEach {
                        CategoryTreeView(it, indent + 16)
                    }
                }
            }
        }
    }
}
```

このコードは、各グループの折りたたみ状態を個別に保持しています。


