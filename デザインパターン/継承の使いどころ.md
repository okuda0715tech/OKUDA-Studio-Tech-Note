- [継承の使いどころ](#継承の使いどころ)
  - [継承を避けるべきケース](#継承を避けるべきケース)
    - [1. クラスが肥大化する](#1-クラスが肥大化する)
    - [2. 変更が難しくなる](#2-変更が難しくなる)
    - [3. 型の柔軟性が低下する](#3-型の柔軟性が低下する)
  - [継承を使うべきケース](#継承を使うべきケース)
    - [1. IS-A 関係が明確な場合](#1-is-a-関係が明確な場合)
    - [2. 共通の振る舞いを統一したい場合](#2-共通の振る舞いを統一したい場合)
    - [3. フレームワークやライブラリの設計に適合させる場合](#3-フレームワークやライブラリの設計に適合させる場合)
  - [代替手法](#代替手法)
    - [1. コンポジション（Composition）](#1-コンポジションcomposition)
    - [2. インターフェース（Interface）や抽象クラスの利用](#2-インターフェースinterfaceや抽象クラスの利用)
    - [3. デザインパターンの活用](#3-デザインパターンの活用)
  - [結論](#結論)
  - [引用元資料](#引用元資料)


# 継承の使いどころ

継承は強力な機能ですが、無計画に使うと「巨大な基底クラス（God Object）」が生まれ、柔軟性や保守性が低下する可能性があります。そのため、無闇に継承を使うのではなく、以下のようなポイントを考慮して設計するのが良いでしょう。


## 継承を避けるべきケース

### 1. クラスが肥大化する

- 基底クラスに多くの責務を持たせすぎると、変更が困難になります。
- サブクラスが基底クラスの不要な機能まで継承してしまう可能性があります。


### 2. 変更が難しくなる

- 継承関係が深くなると、1つの変更が多くのクラスに影響を与えます。
- Liskovの置換原則（LSP）が破られると、サブクラスの振る舞いが予測しにくくなります。


### 3. 型の柔軟性が低下する

- 継承は静的な結びつきを作るため、設計の柔軟性を損なうことがあります。
- 例えば、コンポジション（オブジェクトの委譲）を使うと、より柔軟な設計が可能です。


## 継承を使うべきケース

継承を完全に避けるべきではなく、以下のような場合には適しています。


### 1. IS-A 関係が明確な場合

- 「〇〇は△△の一種である」と明確に言える場合は継承が有効です。
- 例: Dog は Animal の一種である。


### 2. 共通の振る舞いを統一したい場合

- 例えば、Template Method パターン のように、共通の処理フローを基底クラスで提供し、一部の詳細のみサブクラスで実装するケース。


### 3. フレームワークやライブラリの設計に適合させる場合

- 例えば、AndroidのActivityやFragmentのように、継承が前提となるフレームワークでは、適切に継承することが求められます。


## 代替手法

継承を乱用しないために、以下の手法を検討すると良いでしょう。


### 1. コンポジション（Composition）

- 「継承より委譲（Favor Composition over Inheritance）」の原則に従い、オブジェクトの組み合わせで機能を実現する。
- 例: Car クラスが Engine オブジェクトを持つ (Car has an Engine)。


### 2. インターフェース（Interface）や抽象クラスの利用

- JavaやKotlinのinterfaceを活用すると、複数の異なるクラスに共通の振る舞いを持たせつつ、クラスの肥大化を防ぐことができます。


### 3. デザインパターンの活用

- Strategy パターン（動的に振る舞いを変更）
- Decorator パターン（機能を追加する）


## 結論

継承は慎重に使うべきであり、特に基底クラスが肥大化する場合は避けるべきです。ただし、適切な場面では有用であり、設計の意図を明確にすれば問題はありません。基本的には、コンポジションやインターフェースを優先し、継承が最適な選択肢である場合にのみ使うのが良いでしょう。


## 引用元資料

- ChatGPT
  
  