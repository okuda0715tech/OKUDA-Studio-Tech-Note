- [Thread-Specific Storage](#thread-specific-storage)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [Kotlin のコルーチンにデータを紐づける方法](#kotlin-のコルーチンにデータを紐づける方法)
      - [🧠 解説](#-解説)
      - [⚠ 注意点](#-注意点)
      - [🔍 さらに柔軟に管理したい場合](#-さらに柔軟に管理したい場合)
      - [✅ まとめ](#-まとめ)
      - [coroutine-specific storage に任意のオブジェクトを格納する例](#coroutine-specific-storage-に任意のオブジェクトを格納する例)
        - [✅ 型の制約は？](#-型の制約は)
        - [🔍 複数の値を一括で管理したいとき](#-複数の値を一括で管理したいとき)
        - [✅ まとめ](#-まとめ-1)
  - [使いどころ](#使いどころ)
    - [1. ログやトレースのコンテキスト保持（Logging / Tracing）](#1-ログやトレースのコンテキスト保持logging--tracing)
    - [2. ユーザー情報のコンテキスト管理](#2-ユーザー情報のコンテキスト管理)
    - [3. 認証トークンやセッション情報の伝播](#3-認証トークンやセッション情報の伝播)
    - [4. リクエストスコープのキャンセル・タイムアウト管理](#4-リクエストスコープのキャンセルタイムアウト管理)
    - [5. テストでの DI（依存性注入）代替としての使用](#5-テストでの-di依存性注入代替としての使用)
    - [✅ まとめ](#-まとめ-2)


# Thread-Specific Storage

## 役割

スレッド or コルーチンに何らかの一つのデータを簡単に紐づける仕組み。


## 実装方法

### Kotlin のコルーチンにデータを紐づける方法

```kotlin
import kotlinx.coroutines.*
import kotlin.coroutines.*

val threadLocal = ThreadLocal<String?>() // Thread-specific storage

fun main() = runBlocking {
    threadLocal.set("main") // メインスレッド用にセット

    println("Before launch: ${threadLocal.get()}") // main

    val job = launch(threadLocal.asContextElement("launch")) {
        println("Start coroutine: ${threadLocal.get()}") // launch

        delay(100)

        println("After delay: ${threadLocal.get()}") // launch
    }

    job.join()

    println("After coroutine: ${threadLocal.get()}") // main
}
```

#### 🧠 解説

- ThreadLocal をそのまま使うと、コルーチンのスレッド切り替えで値が失われる。
- asContextElement(value) を使えば、コルーチンの CoroutineContext に値をバインドできる。
  - 値はコルーチンのスレッド切り替えにも正しく引き継がれる。
- 上の例では、launch の中では "launch" が常に得られるようになっている。


#### ⚠ 注意点

- ThreadLocal の値は コルーチン単位で保持される（つまり TSS ではなく coroutine-specific storage に近い）。
- Dispatchers.Default などスレッドプールベースのディスパッチャーであっても、値は維持される。
- ただし、子コルーチンには自動で継承されないため、必要に応じて明示的に継承させる必要がある。


#### 🔍 さらに柔軟に管理したい場合

自前でキー付きの値を保持したい場合は、CoroutineContext に独自の要素を追加するという手もあります。

CoroutineContext.Element クラスを継承して、独自のクラスを定義します。

たとえば：

```kotlin
data class MyContext(val userId: String) : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<MyContext>
    override val key: CoroutineContext.Key<*> get() = Key
}
```

こうすると、 `coroutineContext[MyContext]?.userId` で任意の場所から取り出せます。


#### ✅ まとめ

- Kotlin コルーチンでは ThreadLocal + asContextElement() を使うことで TSS を模倣可能。
- ただし、 TSS というより Coroutine-Specific Storage。
- より柔軟に管理したい場合は、独自の CoroutineContext.Element を使うとよい。


#### coroutine-specific storage に任意のオブジェクトを格納する例

たとえば、以下のようにログ用のデータクラスを CoroutineContext に格納できます。

```kotlin
// 任意のオブジェクト（例：ログ用コンテキスト）
data class LogContext(val userId: String, val sessionId: String) : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<LogContext>
    override val key: CoroutineContext.Key<*> get() = Key
}
```

使い方：

```kotlin
val logContext = LogContext(userId = "u123", sessionId = "s456")

withContext(logContext) {
    // 任意の場所で取り出せる
    val ctx = coroutineContext[LogContext]
    println("Logging for user: ${ctx?.userId}, session: ${ctx?.sessionId}")
}
```

##### ✅ 型の制約は？

- CoroutineContext.Element を実装していればどんなクラスでも OK。
- プリミティブ、文字列、データクラス、カスタムクラスなど自由。
- データのスレッドセーフ性が必要なら、その設計も考慮（例：val、イミュータブル設計など）。


##### 🔍 複数の値を一括で管理したいとき

もし複数種類の値（例：ログ用コンテキスト、ユーザー情報、認証トークンなど）を扱う場合、下記のように 複数のカスタム Element を作って使い分けるのがよくある方法です：

```kotlin
data class AuthToken(val token: String) : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<AuthToken>
    override val key = Key
}

data class CurrentUser(val id: String, val name: String) : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<CurrentUser>
    override val key = Key
}

// withContext(AuthToken(...) + CurrentUser(...)) { ... }
```


##### ✅ まとめ

- CoroutineContext には 任意のオブジェクトを格納可能。
- 条件は CoroutineContext.Element を実装すること。
- データクラスやカスタムクラスも問題なく使用でき、非同期処理の文脈を自然に共有できる。


## 使いどころ

### 1. ログやトレースのコンテキスト保持（Logging / Tracing）

- 目的
  - 非同期処理中に「このリクエストはどのユーザー／どのトランザクションに属しているか」を記録する。
- 例
  - Crashlytics や Timber、Datadog などのログサービスにリクエスト ID やユーザー ID を紐づける。

```kotlin
data class LoggingContext(val traceId: String) : CoroutineContext.Element {
    companion object Key : CoroutineContext.Key<LoggingContext>
    override val key = Key
}

// 使い方
val context = LoggingContext(traceId = "abc123")
withContext(context) {
    log("User did something important") // traceId をログに含められる
}
```

### 2. ユーザー情報のコンテキスト管理

- 目的
  - コルーチンの中で一貫してログインユーザー情報にアクセスしたい。
- 例
  - API 呼び出しやキャッシュ処理においてユーザーIDを自動で付加する。


### 3. 認証トークンやセッション情報の伝播

- 目的
  - 非同期処理中にセッション／アクセストークンを安全に渡す。
  - 特に、複数の API 呼び出しを並列・逐次に行うときに便利。


### 4. リクエストスコープのキャンセル・タイムアウト管理

- 目的
  - 1 つのユーザー操作で起動されたコルーチン群をまとめてキャンセルしたい。
  - これは coroutineScope や supervisorScope を使った スコープ制御に近いが、スコープごとの付帯情報（コンテキスト）を管理したいときに coroutine-specific storage を活用する。


### 5. テストでの DI（依存性注入）代替としての使用

- 目的
  - テスト時にログコンテキストやユーザーコンテキストを差し替えたい。
  - 通常の DI（Hilt など）では難しい箇所に対して、コンテキストベースの切り替えが使える。


### ✅ まとめ

Android アプリにおける coroutine-specific storage の主な使い所：

- ログ／トレースの文脈情報
- ユーザーやセッション情報の伝播
- 非同期処理中の一貫したコンテキスト共有
- テスト用のコンテキスト切り替え








