- [Single Threaded Execution](#single-threaded-execution)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [コルーチンセーフにする実装](#コルーチンセーフにする実装)
    - [スレッドセーフにする実装](#スレッドセーフにする実装)
      - [方法 1: @Synchronized アノテーションを使う（Java の synchronized 修飾子に相当）](#方法-1-synchronized-アノテーションを使うjava-の-synchronized-修飾子に相当)
      - [方法 2: synchronized() 関数を使う（Java の synchronized ブロックに相当）](#方法-2-synchronized-関数を使うjava-の-synchronized-ブロックに相当)
      - [方法 3：Coroutine + Channel を使ってシングルスレッド実行を行う](#方法-3coroutine--channel-を使ってシングルスレッド実行を行う)
  - [使いどころ](#使いどころ)


# Single Threaded Execution

## 役割

特定の処理を複数のスレッド or コルーチンが同時に実行できないようにします。


## 実装方法

### コルーチンセーフにする実装

Kotlin の Mutex() を使用すると、 Java の syncronized が複数スレッドからのアクセスを防止するように、複数コルーチンからのアクセスを防止します。 Mutex について、詳しくは、 [Mutual exclusion（相互排他 / 排他制御）](../../Kotlin/非同期処理/コルーチン/09.共有可変状態と同時実行.md/#mutual-exclusion相互排他--排他制御) を参照してください。

Mutex() の実装側：

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

class SingleThreadExecutor {
    private val mutex = Mutex()

    suspend fun runTask(task: suspend () -> Unit) {
        mutex.withLock {
            task()
        }
    }
}
```

使用側：

```kotlin
fun main() = runBlocking {
    val executor = SingleThreadExecutor()

    repeat(5) { index ->
        launch {
            executor.runTask {
                println("Start Task $index on ${Thread.currentThread().name}")
                delay(500)
                println("End Task $index")
            }
        }
    }
}
```


### スレッドセーフにする実装

#### 方法 1: @Synchronized アノテーションを使う（Java の synchronized 修飾子に相当）

```kotlin
class SingletonExecutor {

    @Synchronized
    fun execute(task: () -> Unit) {
        // 単一スレッドでしか実行されない
        task()
    }
}
```


#### 方法 2: synchronized() 関数を使う（Java の synchronized ブロックに相当）

```kotlin
class Executor {
    private val lock = Any()

    fun execute(task: () -> Unit) {
        synchronized(lock) {
            // 単一スレッド実行
            task()
        }
    }
}
```


#### 方法 3：Coroutine + Channel を使ってシングルスレッド実行を行う

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

class CoroutineExecutor {
    private val channel = Channel<suspend () -> Unit>(Channel.UNLIMITED)
    private val scope = CoroutineScope(Dispatchers.Default)

    init {
        // コルーチンの性質上、この scope が終了するまでは、
        // このコルーチンスコープは、チャネルにタスクが格納されるのを待ち続けます。
        scope.launch {
            // チャネルからタスクを一つずつ取り出して実行する。
            for (task in channel) {
                // タスクを実行する。
                task()
            }
        }
    }

    fun execute(task: suspend () -> Unit) {
        // タスクをキュー(チャネル)に送信する
        channel.trySend(task)
    }
}
```

上記のサンプルは、説明のために簡易的にしたもので、細かい部分にも対応したものは以下の通りです。

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

class SafeSerialExecutor {

    private val channel = Channel<suspend () -> Unit>(Channel.UNLIMITED)
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

    init {
        scope.launch {
            for (task in channel) {
                try {
                    task()
                } catch (e: Exception) {
                    // タスク内の例外をログなどに残す（落とさない）
                    println("タスク中に例外が発生しました: ${e.message}")
                }
            }
        }
    }

    /**
     * タスクを直列実行キューに追加する。
     * タスク送信が失敗した場合は false を返す。
     */
    fun execute(task: suspend () -> Unit): Boolean {
        val result = channel.trySend(task)
        return if (result.isSuccess) {
            true
        } else {
            println("タスクの送信に失敗しました: ${result.exceptionOrNull()?.message}")
            false
        }
    }

    /**
     * シャットダウン処理。チャネルを閉じ、コルーチンもキャンセルする。
     */
    fun shutdown() {
        channel.close()
        scope.cancel()
    }
}
```

上記のクラスの使用例は以下です。

```kotlin
fun main() = runBlocking {
    val executor = SafeSerialExecutor()

    executor.execute {
        println("A 開始")
        delay(500)
        println("A 終了")
    }

    executor.execute {
        println("B 開始")
        delay(500)
        println("B 終了")
    }

    executor.execute {
        println("C 開始")
        throw RuntimeException("C タスク中の例外")
    }

    executor.execute {
        println("D 開始")
        delay(500)
        println("D 終了")
    }

    delay(3000)
    executor.shutdown()
}
```


## 使いどころ

省略


