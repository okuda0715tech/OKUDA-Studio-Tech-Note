- [Two-Phase Termination](#two-phase-termination)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [コルーチンの実装例](#コルーチンの実装例)
  - [使いどころ](#使いどころ)
    - [長時間実行される処理の中断](#長時間実行される処理の中断)
    - [トランザクションのロールバックやコミット](#トランザクションのロールバックやコミット)
  - [引用元資料](#引用元資料)


# Two-Phase Termination

## 役割

非同期処理のキャンセル要求が出された場合に、必要な処理を実行してから、実際のキャンセルを行います。

名前の通り、 2 つのフェーズで処理を終了させます：

- 第一フェーズ（終了要求）
  - 外部から「終了してね」とリクエストを送る。
- 第二フェーズ（安全終了）
  - 処理中のタスクを安全に終わらせ、リソースを解放してから終了する。


## 実装方法

### コルーチンの実装例

```kotlin
import kotlinx.coroutines.*
import kotlin.system.exitProcess

class TerminatableWorker {
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    private var job: Job? = null

    fun start() {
        job = scope.launch {
            println("Worker started")
            try {
                while (isActive) {
                    doWork()
                    delay(1000)
                }
            } finally {
                cleanup()
            }
        }
    }

    // 外部のクラスから呼ばれる関数 (今回、呼び出し側のコードは省略)
    fun shutdown() {
        println("Shutdown requested")
        job?.cancel()  // 第一フェーズ：終了要求
    }

    private suspend fun doWork() {
        println("Doing some work...")
        // 実際の処理
    }

    private fun cleanup() {
        println("Cleaning up resources") // 第二フェーズ：リソース解放
    }
}
```

Kotlin の実行環境側が、キャンセル要求が出されたかどうかをチェックするために、 isActive や ensureActive() 、または、キャンセル可能な suspend 関数 ( delay() や withContext() ) などを使う必要があります。


## 使いどころ

### 長時間実行される処理の中断

長時間実行される処理は、処理の中断の際に、途中までの実行結果を保存しておくと良い場合があります。

データを保存してからコルーチンを終了するのに、このパターンが使われます。


### トランザクションのロールバックやコミット

トランザクションが定義され、複数のデータの整合性のある更新が求められる場合は、データの更新中にコルーチンを終了する必要がある場合は、データのロールバックやコミットが必要になることが考えられます。


## 引用元資料

- ChatGPT


