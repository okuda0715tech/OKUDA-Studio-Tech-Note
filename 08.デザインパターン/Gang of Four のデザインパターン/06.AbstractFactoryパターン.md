- [AbstractFactory パターン](#abstractfactory-パターン)
  - [役割](#役割)
  - [実装方法](#実装方法)
  - [使いどころ](#使いどころ)
    - [スマホなのかタブレットなのかに応じて、 UI 部品を別々の工場で作成する](#スマホなのかタブレットなのかに応じて-ui-部品を別々の工場で作成する)
    - [ダークテーマなのかライトテーマなのかに応じて、 UI 部品を別々の工場で作成する](#ダークテーマなのかライトテーマなのかに応じて-ui-部品を別々の工場で作成する)


# AbstractFactory パターン

## 役割

複数の工場を作り、それぞれで、一貫性のある複数のクラスのインスタンスを生成します。

たとえば、GUI ライブラリを考えてみよう。

```plaintext
製品群A（Windows向け）：
  - ボタン：WindowsButton
  - テキストボックス：WindowsTextbox

製品群B（Mac向け）：
  - ボタン：MacButton
  - テキストボックス：MacTextbox
```

この場合、「Windows 製品群を作る工場」と「Mac 製品群を作る工場」が必要になります。これらの工場 (クラス) は、 AbstractFactory (インターフェース) を実装します。


## 実装方法

```kotlin
// Abstract Product
interface Button {
    fun render(): String
}

interface Textbox {
    fun render(): String
}

// Concrete Products
class WindowsButton : Button {
    override fun render(): String = "Rendering a Windows button"
}

class MacButton : Button {
    override fun render(): String = "Rendering a Mac button"
}

class WindowsTextbox : Textbox {
    override fun render(): String = "Rendering a Windows textbox"
}

class MacTextbox : Textbox {
    override fun render(): String = "Rendering a Mac textbox"
}

// Abstract Factory
interface GUIFactory {
    fun createButton(): Button
    fun createTextbox(): Textbox
}

// Concrete Factories
class WindowsFactory : GUIFactory {
    override fun createButton(): Button = WindowsButton()
    override fun createTextbox(): Textbox = WindowsTextbox()
}

class MacFactory : GUIFactory {
    override fun createButton(): Button = MacButton()
    override fun createTextbox(): Textbox = MacTextbox()
}

// Client code
class Application(private val factory: GUIFactory) {
    fun renderUI() {
        val button = factory.createButton()
        val textbox = factory.createTextbox()

        println(button.render())
        println(textbox.render())
    }
}

fun main() {
    // Windows環境の場合
    val windowsFactory = WindowsFactory()
    val windowsApp = Application(windowsFactory)
    println("Windows App UI:")
    windowsApp.renderUI()

    println()

    // Mac環境の場合
    val macFactory = MacFactory()
    val macApp = Application(macFactory)
    println("Mac App UI:")
    macApp.renderUI()
}
```


## 使いどころ

AbstractFactory パターンは、一連のインスタンスを、その環境に応じて作り分けたい場合に、非常に有効です。


### スマホなのかタブレットなのかに応じて、 UI 部品を別々の工場で作成する

```kotlin
interface Button {
    fun render(): String
}

interface TextField {
    fun render(): String
}

// Concrete Products for Phone
class PhoneButton : Button {
    override fun render(): String = "Rendering Phone Button"
}

class PhoneTextField : TextField {
    override fun render(): String = "Rendering Phone TextField"
}

// Concrete Products for Tablet
class TabletButton : Button {
    override fun render(): String = "Rendering Tablet Button"
}

class TabletTextField : TextField {
    override fun render(): String = "Rendering Tablet TextField"
}

// Abstract Factory
interface UIComponentFactory {
    fun createButton(): Button
    fun createTextField(): TextField
}

// Concrete Factories
class PhoneFactory : UIComponentFactory {
    override fun createButton(): Button = PhoneButton()
    override fun createTextField(): TextField = PhoneTextField()
}

class TabletFactory : UIComponentFactory {
    override fun createButton(): Button = TabletButton()
    override fun createTextField(): TextField = TabletTextField()
}
```


### ダークテーマなのかライトテーマなのかに応じて、 UI 部品を別々の工場で作成する

省略


