- [Factory Methodパターン](#factory-methodパターン)
  - [役割](#役割)
  - [実装方法](#実装方法)
  - [使いどころ](#使いどころ)
    - [API レスポンスによって異なる UI を表示する](#api-レスポンスによって異なる-ui-を表示する)
      - [1. Product（共通インターフェース）](#1-product共通インターフェース)
      - [2. ConcreteProduct（具体的 UI）](#2-concreteproduct具体的-ui)
      - [3. Creator（抽象ファクトリ）](#3-creator抽象ファクトリ)
      - [4. ConcreteCreator（具体的ファクトリ）](#4-concretecreator具体的ファクトリ)
      - [5. 使用例](#5-使用例)
  - [引用元資料](#引用元資料)


# Factory Methodパターン

## 役割

オブジェクトの生成をサブクラスに任せることで、実装から生成の詳細を切り離します。


## 実装方法

```kotlin
// Product
interface Button {
    fun render()
}

// ConcreteProduct
class WindowsButton : Button {
    override fun render() = println("Rendering a Windows button.")
}

class MacButton : Button {
    override fun render() = println("Rendering a Mac button.")
}

// Creator
abstract class Dialog {
    abstract fun createButton(): Button

    fun renderDialog() {
        val button = createButton()
        button.render()
    }
}

// ConcreteCreator
class WindowsDialog : Dialog() {
    override fun createButton(): Button = WindowsButton()
}

class MacDialog : Dialog() {
    override fun createButton(): Button = MacButton()
}

// 利用例
fun main() {
    val dialog: Dialog = WindowsDialog()
    dialog.renderDialog()
}
```


## 使いどころ

### API レスポンスによって異なる UI を表示する

たとえば、ある API が以下のように contentType を返してくるとします：

```json
{ "contentType": "text", "data": "Hello World!" }
```

- contentType が "text" なら TextView（Compose でいう Text()）を表示
- "image" なら画像（Image()）を表示
- "video" なら動画プレイヤーを表示

このようなとき、 Factory Method パターンを使うと、 UI の生成処理を柔軟に切り替えられます。

#### 1. Product（共通インターフェース）

```kotlin
interface ContentRenderer {
    @Composable
    fun Render()
}
```


#### 2. ConcreteProduct（具体的 UI）

```kotlin
class TextContent(private val text: String) : ContentRenderer {
    @Composable
    override fun Render() {
        Text(text = text)
    }
}

class ImageContent(private val imageUrl: String) : ContentRenderer {
    @Composable
    override fun Render() {
        // Coil などのライブラリを想定
        AsyncImage(model = imageUrl, contentDescription = null)
    }
}
```


#### 3. Creator（抽象ファクトリ）

```kotlin
abstract class ContentFactory {
    abstract fun createContent(data: String): ContentRenderer
}
```


#### 4. ConcreteCreator（具体的ファクトリ）

```kotlin
class TextContentFactory : ContentFactory() {
    override fun createContent(data: String): ContentRenderer = TextContent(data)
}

class ImageContentFactory : ContentFactory() {
    override fun createContent(data: String): ContentRenderer = ImageContent(data)
}
```


#### 5. 使用例

```kotlin
@Composable
fun ContentScreen(contentType: String, data: String) {
    val factory: ContentFactory = when (contentType) {
        "text" -> TextContentFactory()
        "image" -> ImageContentFactory()
        else -> throw IllegalArgumentException("Unsupported content type")
    }

    val content = factory.createContent(data)
    content.Render()
}
```

新しいタイプの UI（例えば "video"）が追加されても、 when() 文のラムダブロックが肥大化するのを避けることができます。


## 引用元資料

- ChatGPT


