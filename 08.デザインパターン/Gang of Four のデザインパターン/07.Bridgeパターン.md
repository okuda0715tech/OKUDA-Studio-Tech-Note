- [Bridge パターン](#bridge-パターン)
  - [役割](#役割)
  - [実装方法](#実装方法)
    - [RefinedAbstraction も登場するサンプル](#refinedabstraction-も登場するサンプル)
  - [使いどころ](#使いどころ)
    - [データの取得元が複数あって切り替えたいとき](#データの取得元が複数あって切り替えたいとき)
    - [テーマカラー等のテーマの設定](#テーマカラー等のテーマの設定)


# Bridge パターン

## 役割

- 「機能を使う側のクラス（処理）」と「機能を実装する側のクラス（処理）」を明確に分離する。
- 「機能を使う側」のクラスと「機能を実装する側」のクラスを自由に組み合わせて使用できるため、様々な組み合わせが必要な場合に利便性が高い。


## 実装方法

Koltin では、クラスデリゲーションを使用することで、 Bridge パターンを簡潔に実装することが可能です。

```kotlin
// 実装者 役
interface Device {
    fun turnOn()
    fun turnOff()
}
```

```kotlin
// 具体的な実装者 役
class TV : Device {
    override fun turnOn() = println("TV is turned on")
    override fun turnOff() = println("TV is turned off")
}

class Radio : Device {
    override fun turnOn() = println("Radio is turned on")
    override fun turnOff() = println("Radio is turned off")
}
```

```kotlin
// 抽象化 役
class RemoteControl(private val device: Device) : Device by device {
    fun togglePower() {
        println("Toggling power...")
        turnOn()  // device.turnOn() を呼んでるのと同じ
    }
}
```


### RefinedAbstraction も登場するサンプル

```kotlin
interface Device {
    fun turnOn()
    fun turnOff()
    fun setVolume(percent: Int)
}
```

```kotlin
class TV : Device {
    override fun turnOn() = println("TV: turned on")
    override fun turnOff() = println("TV: turned off")
    override fun setVolume(percent: Int) = println("TV: volume set to $percent%")
}
```

```kotlin
open class RemoteControl(protected val device: Device) {
    open fun togglePower() {
        println("Remote: toggling power")
        device.turnOn()
    }
}
```

```kotlin
class AdvancedRemoteControl(device: Device) : RemoteControl(device) {
    fun mute() {
        println("AdvancedRemote: muting device")
        device.setVolume(0)
    }

    fun setHalfVolume() {
        setVolume(50)
    }

    fun setVolume(percent: Int) {
        println("AdvancedRemote: setting volume to $percent%")
        device.setVolume(percent)
    }
}
```

```kotlin
fun main() {
    val tv = TV()

    val simpleRemote = RemoteControl(tv)
    simpleRemote.togglePower()

    val advancedRemote = AdvancedRemoteControl(tv)
    advancedRemote.setVolume(50)
    advancedRemote.mute()
}
```


## 使いどころ

### データの取得元が複数あって切り替えたいとき

- ユーザー情報を「ローカルDB or ネットワークAPI or Firebase」から取れるようにしたい
- UserRepository は使いたいけど、取得方法は柔軟に切り替えたい

```kotlin
interface UserDataSource {
    fun fetchUser(): User
}

class LocalUserDataSource : UserDataSource { ... }
class RemoteUserDataSource : UserDataSource { ... }

abstract class UserRepository(protected val dataSource: UserDataSource) {
    abstract fun getUser(): User
}

class NormalUserRepository(dataSource: UserDataSource) : UserRepository(dataSource) {
    override fun getUser(): User = dataSource.fetchUser()
}
```


### テーマカラー等のテーマの設定

```kotlin
// 実装 役
interface UiController {
    fun backgroundColor(): Color
    fun textColor(): Color
}
```

```kotlin
// Device（具体的な実装 役）＝テーマスタイル
class LightTheme : UiController {
    override fun backgroundColor() = Color.White
    override fun textColor() = Color.Black
}

class DarkTheme : UiController {
    override fun backgroundColor() = Color.Black
    override fun textColor() = Color.White
}
```

```kotlin
// 抽象（Bridge）クラス（デリゲートベース）

open class BaseUiController(controller: UiController) : UiController by controller
```

```kotlin
// RefinedAbstraction 役 : AdvancedController（追加機能あり）

class AdvancedUiController(controller: UiController) : BaseUiController(controller) {
    fun debugLogTheme() {
        println("Current bg: ${backgroundColor()}, text: ${textColor()}")
    }
}
```

```kotlin
// CompositionLocal 化して提供

val LocalUiController = staticCompositionLocalOf<BaseUiController> {
    error("No controller provided")
}

@Composable
fun AppTheme(
    isDarkMode: Boolean,
    content: @Composable () -> Unit
) {
    val base = if (isDarkMode) DarkTheme() else LightTheme()
    val controller = remember(isDarkMode) {
        AdvancedUiController(base)
    }

    CompositionLocalProvider(LocalUiController provides controller) {
        content()
    }
}
```

```kotlin
// UI 側で使用

@Composable
fun MainScreen() {
    // current が前回と異なる値に変更されると、 MainScreen が再コンポーズされます。
    val controller = LocalUiController.current

    controller.debugLogTheme() // RefinedAbstraction の機能！

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(controller.backgroundColor())
            .padding(16.dp)
    ) {
        Text(
            text = "Refined Bridge in Compose!",
            color = controller.textColor(),
            fontSize = 24.sp
        )
    }
}
```

```kotlin
// MainActivity の setContent() に埋め込む

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val isDark = isSystemInDarkTheme() // または ViewModel で管理してもOK

            // isDark が前回と異なる値に変更されると、 MainScreen が再コンポーズされます。
            AppTheme(isDarkMode = isDark) {
                MainScreen()
            }
        }
    }
}
```





