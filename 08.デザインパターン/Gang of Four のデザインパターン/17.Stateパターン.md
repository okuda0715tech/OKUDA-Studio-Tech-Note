- [State パターン](#state-パターン)
  - [役割](#役割)
  - [実装方法](#実装方法)
  - [使いどころ](#使いどころ)
    - [再生プレイヤーの状態 → 再生中 / 一時停止 / 停止](#再生プレイヤーの状態--再生中--一時停止--停止)
    - [Bluetooth の状態 → 未接続 / 接続中 / 接続済み / エラー](#bluetooth-の状態--未接続--接続中--接続済み--エラー)
    - [課金フローの状態 → 未購入 / 購入中 / 購入済み / 失敗](#課金フローの状態--未購入--購入中--購入済み--失敗)


# State パターン

## 役割

状態をクラスで定義し、クラスを差し替えるだけで、振る舞いを変更します。


## 実装方法

```kotlin
// 状態ごとの共通インターフェース
interface State {
    fun handle(context: Context)
}

// 状態ごとのクラス
class WaitingState : State {
    override fun handle(context: Context) {
        println("待機中です。")
    }
}

class AttackingState : State {
    override fun handle(context: Context) {
        println("攻撃中！")
    }
}

// 状態を持つクラス（コンテキスト）
class Context {
    var state: State = WaitingState()  // 初期状態

    fun request() {
        // 状態を差し替えれば、 handle メソッドの動作が変わる。
        state.handle(this)
    }
}
```

kotlin では、 sealed クラス + when で実装することが可能です。


## 使いどころ

State パターンの使いどころは、 **アプリ全体を通じて（もしくは、複数画面を横断して）使用する状態がある場合** です。これらを毎回 `when(currentState)` で分岐すると、処理が肥大化 & メンテ地獄になります。

具体的には、以下のようなユースケースが考えられます。


### 再生プレイヤーの状態 → 再生中 / 一時停止 / 停止

省略


### Bluetooth の状態 → 未接続 / 接続中 / 接続済み / エラー

省略


### 課金フローの状態 → 未購入 / 購入中 / 購入済み / 失敗

省略





