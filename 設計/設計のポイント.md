<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [設計のポイント](#設計のポイント)
	- [ポリモーフィズム](#ポリモーフィズム)
	- [オブジェクト思考な設計](#オブジェクト思考な設計)
	- [その他](#その他)
	- [継承と移譲](#継承と移譲)
	- [プログラムの読み方（理解の仕方）](#プログラムの読み方理解の仕方)
	- [データの永続化](#データの永続化)
	- [Widgetの管理している具体的な値をActivityやFragmentのフィールドに保持しないこと](#widgetの管理している具体的な値をactivityやfragmentのフィールドに保持しないこと)

<!-- /TOC -->

# 設計のポイント

## ポリモーフィズム

**クラス名を直接書くとクラス同士が密結合になる。クラスを抽象クラスやインターフェースで包んで、それを書くようにすると疎結合になる。**

ポリモーフィズムを使った場合、本来のクラスが隠蔽される為、子クラス側にある親クラスで定義されていないメソッドを修正しても、呼び出し元には影響がない。

コードの中にクラス名が出てくると、そのコードはそのクラスと密に結合していると言える。
コード中に出てくるクラス以外のクラスで同じ処理を行いたい場合は、抽象クラスやインターフェースを作って、それを使って具象クラスを隠蔽してやる。
このように、クラスAでクラスBを参照したいたが、クラスBの抽象クラスであるクラスCやインターフェースCを作り、クラスAからCを参照するように変更した場合、**クラスAはクラスBに依存していないと言います。**


## オブジェクト思考な設計

**何をクラスにしているのかを常に考える。**
時には実際に存在しないものもクラスにする。例えば、ユーザーが操作した内容をクラスにすることもある。

**「機能のクラス階層」と「実装のクラス階層」を分ける。**
Bridgeパターンと呼ばれているデザインパターンを用いると分けることができる。

**どのような処理をした時に、どのオブジェクトが、どのような情報を知っているのか**を整理すると、機能をどのように実装したら良いかが見えてくる。
↓
**When,Which object,Known data**

**クラスの役割を理解する方法**

- クラスが持っているフィールドで、そのオブジェクトが何のオブジェクトなのかがわかる
- クラスが他のクラスを参照していたら、そのクラスが他のクラスとどんな関係なのかがわかる
- クラスが他のクラスを継承していたら、そのクラスが他のクラスとどんな関係なのかがわかる


## その他

ポリモーフィズムを実現する際、必ずどこかのクラスでConcreteClassをnewしなければいけない。そのクラスはConcreteClassと必ず密結合となってしまう。
newするクラスが複数で一つのまとまりを持つ場合は、newする側も何らかのサブクラスとした方がコードがシンプルになる。これがAbstractFactoryパターンのConcreteFactoryとなる。


## 継承と移譲

継承と移譲を比べると、継承は密結合、移譲は疎結合であると言える。
移譲では、変数に格納する値を変えるだけで、簡単に呼び出すメソッドを変更できるのに対し、継承では、プログラムを書き換えて再度コンパイルしないと変更できない。（実行時に変更できない。）

一般的に、
機能の追加は継承で実現する。
APIの実装は継承で実現する。
機能とAPIの連携は移譲で行う。
これをデザインパターンではBridgeパターンという。


## プログラムの読み方（理解の仕方）

一つ一つのクラスがどのような役割なのかを理解する。
なぜなら、各オブジェクトの役割がわかれば、クラスを物として捉えることができ、
そのクラスでできることの範囲が限られてくる。
そのクラスのできることの範囲がわかれば、そのクラスを使いこなしたようなものである。
そのクラスを使ってどのようにしたらやりたいことをできるのかもわかってくる。
そのようにして、一つ一つのクラスの役割がわかれば、アプリ全体の機能がどのように実現されているのかがわかる。
よって、アプリの改修もできるようになる。

ポイント

- クラスを一つの物として捉える。


## データの永続化

- データはDBやプリファレンスなどの不揮発領域に保存し、永続化する。
- 一度、不揮発領域から取得したデータは、それ以降、高速に参照できるようにキャッシュ（メモリ）に保持しておく。


## Widgetの管理している具体的な値をActivityやFragmentのフィールドに保持しないこと

上記のルールを守らない場合、Widget自身とWidgetの値の二つをフィールドとして管理することになり、どちらか片方だけでも更新が漏れているとバグの原因になる。
よって、Widgetの値を保持するフィールドは作らないこと。
Widgetの値は常にフィールドとして保持しているWedgetから取得すること。
取得に手間がかかる場合は、取得用のメソッドを用意すれば問題ない。



