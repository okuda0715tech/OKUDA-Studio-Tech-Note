- [インターフェース](#インターフェース)
  - [デフォルト実装](#デフォルト実装)
    - [基本](#基本)
    - [デフォルト実装の衝突](#デフォルト実装の衝突)
  - [抽象プロパティの定義](#抽象プロパティの定義)


# インターフェース

## デフォルト実装

### 基本

Kotlin のインタフェースは、 Java8 のインタフェースのデフォルトメソッドと同様に、デフォルトの実装を持つことができます。 下記の Command インタフェースの help メソッドはデフォルト実装を持っています。

```kotlin
interface Command {
    fun execute()
    fun help() = println("No help exists")
}

class MyCommand : Command {
    override fun execute() = println("I am MyCommand")
}

fun main() {
    val a = MyCommand()
    a.execute()  //=> I am MyCommand
    a.help()  //=> No help exists
}
```

Java でインタフェースにデフォルト実装を持たせるときは `default` キーワードが必要でしたが、Kotlin では通常のメソッドと同様に定義するだけで OK です。


### デフォルト実装の衝突

インタフェースのデフォルト実装が可能になるということは、実装の多重継承ができることと同等の意味を持ちます。 これは、実装の衝突という問題を生みます。

下記は、2 つのインタフェースが、同じ help という名前のデフォルト実装を持つ例です。

```kotlin
interface Menu {
    fun help() = println("Menu.help")
}

interface Command {
    fun help() = println("Command.help")
}

class FileOpenMenu : Menu, Command {
    // コンパイルエラー！
}
```

FileOpenMenu クラスは help() のデフォルト実装を使おうとしますが、Menu.help() を呼び出せばいいのか、Command.help() を呼び出せばいいのか判断できないため、上記のコードはコンパイルエラーになります。

次のように、自分自身でオーバーライドしてしまえば問題ありません。

```kotlin
class FileOpenMenu : Menu, Command {
    override fun help() = println("FileOpenMenu.help")
}
```

どちらかのデフォルト実装をそのまま呼び出したい場合は、super キーワードを使って次のように記述します。

```kotlin
class FileOpenMenu : Menu, Command {
    override fun help() = super<Menu>.help()
}
```


## 抽象プロパティの定義

Kotlin のインタフェースには抽象プロパティを持たせることができます。

Kotlin のプロパティは、実質的に、バッキングフィールドと、そのゲッターとセッターの定義です。そのため、インターフェースに抽象プロパティを定義することは、そのゲッターとセッターの抽象関数を定義しているのと同じことになります。

下記の Book クラスは、description という抽象プロパティを定義しています。

```kotlin
interface Book {
    val description: String
}
```

このインタフェースを実装するクラスで、description プロパティを実装 (override) する必要があります。 下記のようにパラメータでプロパティの実体を定義してしまってもよいし、

```kotlin
class RealBook(override val description: String) : Book
```

下記のように getter メソッドを用意しても OK です。

```kotlin
class RealBook(bookId: Int) : Book {
    override val description: String
        get() = getBookDescription(bookId)
}
```




