- [拡張関数(レシーバー付き関数)](#拡張関数レシーバー付き関数)
  - [概要](#概要)
  - [仕組み](#仕組み)
  - [クラス関数かインスタンス関数か](#クラス関数かインスタンス関数か)
  - [基本形](#基本形)
  - [その他の呼び出し方](#その他の呼び出し方)
  - [this の使い方](#this-の使い方)
  - [ジェネリクスな拡張関数も定義可能](#ジェネリクスな拡張関数も定義可能)
  - [拡張関数は静的に解決される](#拡張関数は静的に解決される)
  - [同じシグネチャのメンバー関数が存在している場合](#同じシグネチャのメンバー関数が存在している場合)
  - [レシーバーが Null 許容型の場合は null チェックを忘れずに行う](#レシーバーが-null-許容型の場合は-null-チェックを忘れずに行う)
  - [companion object に対する拡張関数](#companion-object-に対する拡張関数)
  - [拡張関数のスコープ](#拡張関数のスコープ)
  - [クラスのメンバーとして定義された拡張関数](#クラスのメンバーとして定義された拡張関数)
    - [拡張関数をメンバーとして定義したクラス内から呼び出す場合の例](#拡張関数をメンバーとして定義したクラス内から呼び出す場合の例)
    - [this 系のスコープ関数のラムダ式内から呼び出す場合の例](#this-系のスコープ関数のラムダ式内から呼び出す場合の例)
      - [注意点](#注意点)
  - [ディスパッチレシーバーと拡張レシーバー内で関数名が競合した場合](#ディスパッチレシーバーと拡張レシーバー内で関数名が競合した場合)
  - [メンバー拡張関数を継承する](#メンバー拡張関数を継承する)
  - [同一ファイル内の他の private なパッケージレベル宣言へのアクセス](#同一ファイル内の他の-private-なパッケージレベル宣言へのアクセス)
  - [自分自身の private や protected なメンバーへのアクセスができない場合がある](#自分自身の-private-や-protected-なメンバーへのアクセスができない場合がある)


# 拡張関数(レシーバー付き関数)

## 概要

Kotlin は、クラスを継承したり Decorator などのデザインパターンを使用したりすることなく、  
Kotlin の新しい機能でクラスまたはインターフェイスを拡張する機能を提供します。  
これは、 **拡張関数** と呼ばれる特別な宣言を介して行われます。

たとえば、変更できないサードパーティライブラリのクラスまたはインターフェイスの新しい関数を作成できます。  
このような関数は、元のクラスの関数であるかのように、通常の方法で呼び出すことができます。

実際には、拡張関数は、クラスに新しいメンバー関数を追加するのではなく、クラスの外に関数を定義します。  
しかし、あたかもクラスのメンバー関数を追加したかのように、関数を呼び出すことができます。


## 仕組み

拡張関数は、コンパイルされると、レシーバーを関数の第一引数に割り当てます。

例えば、以下の拡張関数は、

```kotlin
fun Int.myIncrement(x: Int): Int {
    return x + 1
}
```

コンパイルされると、以下のようになります。

```kotlin
// $ マークは、自動生成された変数であることを表すマーカーです。
// 単なるマーカーであるため、普通の変数との違いはありません。
public final int myIncrement(int $this$myIncrement, int x) {
    return x + 1;
}
```


## クラス関数かインスタンス関数か

拡張関数は、実際には関数を定義したクラス内やパッケージ内に定義されます。  
そのため、関数を定義した場所がクラスのメンバであれば、インスタンス関数になり、  
パッケージレベルとして定義すれば、 static 関数になります。


## 基本形

拡張関数は、関数名の前に、拡張関数を定義したいクラスの 「`クラス名.` 」 を付与します。

```kotlin
// MutableList<Int> 型のオブジェクトに swap() 関数を追加します
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    // 'this' は、レシーバ ( MutableList ) のインスタンスを示します。
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}
```

これで、 `MutableList<Int>` のインスタンスなら、どのインスタンスでも `swap()` 関数が呼び出せるようになりました。

```kotlin
val list = mutableListOf(1, 2, 3)
list.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'list'
```


## その他の呼び出し方

```kotlin
// 拡張関数を定義
fun Int.myIncrement(x: Int): Int {
    return x + 1
}

// 関数参照 & 関数型を推論
// 推論される型は、レシーバが第一引数となった (Int, Int) -> Int となる
val myInc = Int::myIncrement
// OK
myInc(1, 2)
// NG (レシーバが第一引数化した場合、レシーバを指定した関数呼び出しはできなくなる)
1.myInc(2)

// 関数参照 & 関数型は明示 (レシーバは第一引数として指定)
val myInc2: (Int, Int) -> Int = Int::myIncrement
// OK
myInc2(1, 2)
// NG (レシーバが第一引数化した場合、レシーバを指定した関数呼び出しはできなくなる)
1.myInc2(2)

// 関数参照 & 関数型は明示 (レシーバはレシーバとして指定)
val myInc3: Int.(Int) -> Int = Int::myIncrement
// OK (レシーバを第一引数に指定して関数呼び出し)
myInc3(1, 2)
// OK (レシーバを指定した呼び出しもできる)
1.myInc3(2)

// 関数参照して、その場で呼び出し
(Int::myIncrement)(1, 2)

// OK (通常の呼び出し)
1.myIncrement(2)
// NG (直接拡張関数を呼び出す場合は、レシーバを第一引数に指定した呼び出しは不可。)
myIncrement(1, 2)
```


## this の使い方

拡張関数内で、 `this` キーワードを使用すると、レシーバーのインスタンスを取得することができます。また、拡張関数内で暗黙的な this でレシーバーのインスタンスを参照しているため、 this を省略してレシーバーのメンバーにアクセスすることも可能です。

```kotlin
fun String.isLengthOdd(): Boolean {
    // this.length の this が省略されている。
    return length % 2 != 0
}

val s = "abc"
Log.d("test", "${s.isLengthOdd()}") // true
```


## ジェネリクスな拡張関数も定義可能

以下の通り、ジェネリクスを使用した拡張関数の定義も可能です。

```kotlin
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
    val tmp = this[index1]
    this[index1] = this[index2]
    this[index2] = tmp
}
```


## 拡張関数は静的に解決される

拡張関数は静的に解決されるため、 **コンパイル時の型情報によって、どの拡張関数を呼び出すかが決まります。**

```kotlin
open class Shape
class Rectangle: Shape()

fun Shape.getName() = "Shape"
fun Rectangle.getName() = "Rectangle"

fun printClassName(s: Shape) {
    // s は Shape 型のため、必ず Shape.getName() が呼ばれます。
    println(s.getName())
}

printClassName(Rectangle())
```


## 同じシグネチャのメンバー関数が存在している場合

拡張関数と同じシグネチャのメンバー関数が存在している場合は、メンバー関数が実行され、拡張関数は実行されません。

関数の名前が同じでもシグネチャが異なれば、有効オーバーロードとして定義され、実行が可能です。


## レシーバーが Null 許容型の場合は null チェックを忘れずに行う

```kotlin
fun Any?.toString(): String {
    if (this == null) return "null"
    return toString()
}
```

上記のサンプルは、 `Any?.toString()` なので、一見すると、  
Any が null の場合は呼び出されなさそうに見えますが、呼び出されてしまいます。  
そのため、関数内で、 `this` を使用する場合は、 `this` が null である可能性を忘れずに実装する必要があります。


## companion object に対する拡張関数

companion object に対しても、拡張関数と拡張プロパティを定義することが可能です。

```kotlin
class MyClass {

    // 名前を省略しているので Companion という名前が自動的に付与される。
    companion object {}

}

// companion object に対する拡張関数の定義
fun MyClass.Companion.printCompanion() {
    Log.d("test", "companion")
}

// companion object に対する拡張関数の参照
MyClass.printCompanion()
```


## 拡張関数のスコープ

ほとんどの場合、拡張関数はパッケージ直下 (ファイルのトップレベル) に定義されます。  
パッケージ直下に定義された拡張関数は、パッケージ直下に定義された普通の関数と同じ方法で呼び出せます。


## クラスのメンバーとして定義された拡張関数

クラスのメンバーとして定義された拡張関数は、  
その関数内で、暗黙的な自分自身 (ラッパークラス) への参照 ( this ) を持っています。つまり、この拡張関数は、どこからでも呼び出せるものではなく、ラッパークラスへの参照を持っている場所からのみ呼び出し可能となります。

ラッパークラスへの参照を持っているのは、以下の 2 つの場合のみです。

- 拡張関数をメンバーとして定義したクラス内から呼び出す場合
- this 系のスコープ関数のラムダ式内から呼び出す場合


### 拡張関数をメンバーとして定義したクラス内から呼び出す場合の例

以下は、 「前者 (拡張関数をメンバーとして定義したクラス内から呼び出す場合) 」 の例です。

`Connection` クラス内からのみ、拡張関数 `printConnectionString()` が呼び出せます。

```kotlin
class Host(val hostname: String) {
    fun printHostname() { print(hostname) }
}

// Connection のインスタンスは、 「ディスパッチレシーバー」 と呼ばれる。
// Host のインスタンスは、 「拡張レシーバー」 と呼ばれる。
class Connection(val host: Host, val port: Int) {
    fun printPort() { print(port) }

    // クラスのメンバーとして定義された拡張関数
    fun Host.printConnectionString() {
        // Host.printHostname() を呼び出します。
        printHostname()
        print(":")
        // Connection.printPort() を呼び出します。
        printPort()
    }

    fun connect() {
        // 拡張関数の呼び出し
        host.printConnectionString()
    }
}

fun main() {
    // OK
    Connection(Host("kotl.in"), 443).connect()
    // NG
    // Connection クラスの外側では、拡張関数への直接のアクセスできないため、
    // 以下のような呼び出しはエラーとなります。
    Host("kotl.in").printConnectionString()
    // NG
    // もちろん以下もレシーバーの型が異なるためエラーとなります。
    Connection(Host("host3"), 123).printConnectionString()
}
```


### this 系のスコープ関数のラムダ式内から呼び出す場合の例

以下は、 「後者 ( this 系のスコープ関数のラムダ式内から呼び出す場合) 」 の例です。

```kotlin
// LocalDensity.current は、 Density インスタンスを返すため、
// with スコープ関数のラムダ内では、 Density への暗黙的な参照をもっています。
// そのため、 Density への暗黙的な参照が必要な Dp.toPx() 関数を呼び出すことが可能です。
val sizeInPx = with(LocalDensity.current) { 16.dp.toPx() }

@Immutable
@JvmDefaultWithCompatibility
interface Density : FontScaling {

    //　画面密度
    val density: Float

    // dp を px に変換する関数です。
    //
    // value は、 inline value クラスのプロパティであるため、 this.value の this が省略されています。
    //
    // density は、 Density クラスのプロパティであるため、 this.density の this が省略されています。
    //
    // この関数は、 density へアクセスする必要があるため、 Density インスタンスへの参照が必要です。
    // ただし、暗黙的に Density インスタンスを参照するため、明示的に参照を取得する必要はありません。
    @Stable
    fun Dp.toPx(): Float = value * density
}

@Immutable
@kotlin.jvm.JvmInline
value class Dp(val value: Float) : Comparable<Dp> {
    // 省略
}
```

通常、拡張関数は、パッケージ直下に定義することが多いですが、上記では、クラスのメンバーとして定義しています。この方法のメリットは、拡張関数が、ラッパークラスへの暗黙的な参照を持っているため、ラッパークラスのインスタンス生成をあまり意識することなく、ラッパークラスへのアクセスが可能なことかと思います。


#### 注意点

上記の例で、スコープ関数のラムダ式内は、ラッパークラスの外であるため、ラムダ式内からラッパークラスの private なメンバーにはアクセスできない点には注意してください。


## ディスパッチレシーバーと拡張レシーバー内で関数名が競合した場合

ディスパッチレシーバー側と拡張レシーバー側のメンバー間で名前が競合した場合は、  
拡張レシーバー側が優先されます。  
ディスパッチレシーバー側のメンバーを参照するには、修飾 `this` とラベルを使用します。

```kotlin
class Connection {
    fun Host.getConnectionString() {
        toString()                  // Host.toString() を呼び出します。
        this@Connection.toString()  // Connection.toString() を呼び出します。
    }
}
```


## メンバー拡張関数を継承する

クラスのメンバーとして定義された拡張関数に open 修飾子が付与された場合は、  
サブクラスでオーバーライドすることが可能です。  

```kotlin
open class Base { }

// 派生クラス
class Derived : Base() { }

open class BaseCaller {
    open fun Base.printFunctionInfo() {
        println("Base extension function in BaseCaller")
    }

    open fun Derived.printFunctionInfo() {
        println("Derived extension function in BaseCaller")
    }

    fun call(b: Base) {
        // レシーバーの型は静的に解決されるため、
        // 常に Base の printFunctionInfo() が呼ばれる
        b.printFunctionInfo()
    }
}

// 派生クラス
class DerivedCaller: BaseCaller() {
    override fun Base.printFunctionInfo() {
        println("Base extension function in DerivedCaller")
    }

    override fun Derived.printFunctionInfo() {
        println("Derived extension function in DerivedCaller")
    }
}

fun main() {
    BaseCaller().call(Base())   // "Base extension function in BaseCaller"
    // 普通の継承の仕組みに則り、 DerivedCaller の関数が呼ばれる
    DerivedCaller().call(Base())  // "Base extension function in DerivedCaller"
    DerivedCaller().call(Derived())  // "Base extension function in DerivedCaller"
}
```


## 同一ファイル内の他の private なパッケージレベル宣言へのアクセス

パッケージレベルの拡張関数は、同じファイル内に定義された  
private 修飾子付きの他のパッケージレベルの宣言へのアクセスが可能です。

```kotlin
fun Int.doWork() {
    // private な宣言へのアクセスが可能
    val kotlinClass = KotlinClass()
}

private class KotlinClass {
    // 省略
}
```


## 自分自身の private や protected なメンバーへのアクセスができない場合がある

もし、拡張関数がレシーバークラスの外で定義されている場合、  
拡張関数は、レシーバーの private もしくは protected なメンバーへのアクセスはできません。

拡張関数がもし本当にレシーバークラス内に定義されていれば、  
private や protected でもアクセスできるはずだが、  
実際にはレシーバークラスの外に定義されているため、  
アクセスできないという点に注意が必要です。

```kotlin
fun KotlinClass.doWorkCaller() {
    // NG
    privateDoWork()
    // OK
    publicDoWork()
}

class KotlinClass {

    private fun privateDoWork() {
        // do something.
    }

    public fun publicDoWork() {
        // do something.
    }

}
```





