- [パッケージレベル関数](#パッケージレベル関数)
  - [概要](#概要)
  - [基本形](#基本形)
  - [パッケージレベル関数のスコープ](#パッケージレベル関数のスコープ)
  - [Java からパッケージレベル関数にアクセスする方法](#java-からパッケージレベル関数にアクセスする方法)
    - [生成される Java のクラス名は変更することが可能](#生成される-java-のクラス名は変更することが可能)
  - [メモリへのロード / アンロードのタイミング](#メモリへのロード--アンロードのタイミング)


# パッケージレベル関数

## 概要

Kotlin では、関数をクラスの外側 (すなわち、 `.kt` ファイルの直下) に定義することが可能です。

これを **「パッケージレベル関数」** や **「トップレベル関数」** と呼びます。

コンパイル時に、 Java の static メソッドを生成しているため、  
Java の static にとってかわる機能として使用できます。


## 基本形

**Util.kt**

```kotlin
package com.example

fun printError(message: String) {
    System.err.println("Error: $message")
}
```

**main.kt**

```kotlin
// 関数ごとにインポートしたい場合
import com.example.printError
// 特定のパッケージ配下の関数、変数をまとめてインポートしたい場合
import com.example.*

fun main() {
    printError("ファイルが見つかりません")
}
```


## パッケージレベル関数のスコープ

パッケージレベル関数のデフォルトの可視性は、 `public` になっています。

自分のファイル内に限定したい場合は、 `private` を付けて関数を定義しましょう。


## Java からパッケージレベル関数にアクセスする方法

コンパイル時に、パッケージレベル関数が定義されている `.kt` ファイルのファイル名を使用して、  
`ファイル名Kt` という名前の Java のクラスが生成されます。

パッケージレベル関数は、そのクラスの `static` メソッドとして実装されます。  
その `static` メソッドを呼び出すように実装すれば、  
パッケージレベル関数を Java から呼び出すことが可能です。

**～.kt**

```kotlin
package com.example

// パッケージレベル関数
fun printError() {
    // do something.
}
```

**～.java**

```Java
import com.example.UtilKt;

public class Main {
    public static void main(String... args) {
        // パッケージレベル関数の呼び出し
        // 「ファイル名Kt」 というクラスの中に static メソッドが生成されています。
        UtilKt.printError();
    }
}
```


### 生成される Java のクラス名は変更することが可能

`@file:JvmName` アノテーションを使用することで、生成される Java のクラス名を変更することが可能です。

**Util.kt**

```kotlin
@file:JvmName("LogUtil")
package com.example

// Java からは、 LogUtil.printError() という風にアクセスすることになります。
fun printError(message: String) {
    System.err.println("Error: $message")
}
```


## メモリへのロード / アンロードのタイミング

パッケージレベル関数が初めて import された時に、該当の関数がロードされると考えられます。

アンロードのタイミングはガベージコレクション任せだと考えられます。  
通常、ガベージコレクションのタイミングを気にする必要はないでしょう。


