- [ラムダ式](#ラムダ式)
  - [使いどころ](#使いどころ)
  - [基本形](#基本形)
  - [文法](#文法)
  - [ラムダ式のレシーバー付き関数リテラル](#ラムダ式のレシーバー付き関数リテラル)
  - [後続ラムダ式（Trailing Lambdas）](#後続ラムダ式trailing-lambdas)
  - [引数が一つのみの場合の暗黙的な名前 「 it 」](#引数が一つのみの場合の暗黙的な名前--it-)
  - [ラベル付き return でラムダ式を抜ける](#ラベル付き-return-でラムダ式を抜ける)
  - [未使用の引数はアンダースコアにする](#未使用の引数はアンダースコアにする)
  - [ラムダ式で分解宣言を使用する](#ラムダ式で分解宣言を使用する)
  - [レシーバー付きラムダ式を使ったビルダーパターン](#レシーバー付きラムダ式を使ったビルダーパターン)
  - [ラムダ式の型推論](#ラムダ式の型推論)
    - [🔹 1. コンテキストからの型推論とは？](#-1-コンテキストからの型推論とは)
    - [🔹 2. 引数の型推論](#-2-引数の型推論)
    - [🔹 3. 複数引数の場合](#-3-複数引数の場合)
    - [🔹 4. 戻り値の型推論](#-4-戻り値の型推論)
    - [🔹 5. 型を明示する場合](#-5-型を明示する場合)
    - [🔹 補足：SAM 変換とラムダ](#-補足sam-変換とラムダ)


# ラムダ式

## 使いどころ

関数型プロパティに代入する関数インスタンスを生成するのに使用されることが多い。

例

```kotlin
val func: (Int) -> Int = { i: Int -> i + 1 }
```


## 基本形

```kotlin
val myLambdas = { i1: Int, i2: Int ->
    val sum = i1 + i2
    val doubleVal = sum * 2
    "sum & double = $doubleVal"
}

fun myFunc() {
    Log.d("test", myLambdas(1, 5))
}
```


## 文法

```
{ 引数名1: 引数1の型, 引数名2: 引数2の型 -> 処理 }
```

- 処理は中カッコで囲まれる
- 引数の型は推測可能な場合は省略可能
- 矢印 ( `->` ) の後ろは処理の本体
- 処理部分には複数行の記述が可能
- 推測される戻り値の型が Unit ではない場合、処理の最後の一文が表す式は戻り値となる
- 引数が一つであり、引数の型も推測可能である場合は、引数名と矢印が省略可能です。その場合、引数名は it になります。


## ラムダ式のレシーバー付き関数リテラル

ラムダ式のレシーバー付き関数リテラルを定義するには、ラムダ式を代入する変数の型がレシーバー付き関数型である必要があります。なぜなら、ラムダ式自体には、レシーバーの型を定義する方法はないためです。

```kotlin
val sum: Int.(Int) -> Int = { other -> plus(other) }
```

`plus()` 関数は、レシーバーのメンバー関数です。 this 修飾子なしでアクセスできていることがわかります。

ラムダ式にレシーバーのインスタンスをバインドするには、ラムダ式の実行時にレシーバー付きでラムダ式を呼び出します。

```kotlin
val sum: Int.(Int) -> Int = { other -> plus(other) }
println(1.sum(2)) // 3
```


## 後続ラムダ式（Trailing Lambdas）

関数の最後の引数が関数型の場合、関数呼び出し時に、その関数型のインスタンスを丸カッコの外に出すことが可能です。これを Trailing Lambdas と呼びます。

```kotlin
val product = items.fold(1) { acc, e -> acc * e }
```

もし、関数の引数が一つの関数型のみの場合は、丸カッコ自体を省略することが可能です。

```kotlin
run { println("...") }
```


## 引数が一つのみの場合の暗黙的な名前 「 it 」

もし、ラムダ式のパラメータが一つだけで、かつ、パラメータの型も推測可能な場合、パラメーターを宣言する必要はありません。また、 `->` 演算子を省略できます。この場合、パラメータの名前は暗黙的に `it` として宣言されます。

```kotlin
// 以下のラムダ式は、 'it ->' という引数部分が省略されています。
ints.filter { it > 0 }
```


## ラベル付き return でラムダ式を抜ける

ラベル付き return を使用することで、処理の途中でもラムダ式を抜けることが可能です。ラベル付き return が明示されていなければ、ラムダ式の最後の一文が return されます。

以下の二つは同じ動きをします。

```kotlin
ints.filter {
    val shouldFilter = it > 0
    shouldFilter
}

ints.filter {
    val shouldFilter = it > 0
    return@filter shouldFilter
}
```


## 未使用の引数はアンダースコアにする

もし、ラムダ式の引数に使用しない引数が存在する場合には、アンダースコアにすることが可能です。

```kotlin
map.forEach { (_, value) -> println("$value!") }
```


## ラムダ式で分解宣言を使用する

「分解宣言」 については、別紙を参照してください。

`Kotlin -> クラスとオブジェクト -> Destructuring declarations(分解宣言).md`

ラムダ式でも分解宣言 ( destructuring declarations ) を使用することは可能です。ラムダ式の引数部分に適用することが可能です。

```kotlin
// destructuring declarations を使用しない場合
map.mapValues { entry -> "${entry.value}!" }
// destructuring declarations を使用した場合
map.mapValues { (key, value) -> "$value!" }
```

ラムダ式の引数のオブジェクトが data クラスで定義されているなどで、 `componentN()` 関数を実装していれば、上記のように分解宣言を適用することが可能です。


## レシーバー付きラムダ式を使ったビルダーパターン

ラムダ式をレシーバー付き関数リテラルとして使用する最も重要な例の一つとして、 「型安全ビルダー」 があります。

```kotlin
// ビルドしたいクラス
class Html {
    // ビルドしたクラスを初期化する関数
    fun makeBody() {

    }
}

fun makeHtmlWith(init: Html.() -> Unit): Html {
    // レシーバーオブジェクトの生成
    val html = Html()
    // ラムダ式とレシーバーインスタンスをバインドして、
    // ラムダ式を実行する。
    html.init()
    return html
}

fun main() {
    makeHtmlWith {
        // この中かっこはラムダ式です。
        // 関数型は Html.() -> Unit です。

        // レシーバーの関数を呼び出すことが可能です。
        makeBody()
    }
}
```


## ラムダ式の型推論

Kotlin のラムダ式の引数と戻り値の型は、**コンテキスト（文脈）からの型推論（型推定）**によって自動的に決まります。以下に、具体的な推定の仕組みを段階的に説明します。


### 🔹 1. コンテキストからの型推論とは？

Kotlin ではラムダ式は 関数の引数として使われることが多く、その関数がラムダにどんな型を期待しているかによって、引数と戻り値の型が決まります。


### 🔹 2. 引数の型推論

ラムダ式の 引数の型は、渡される先の関数（または変数）が指定している関数型（(Type) -> ReturnType）によって推定されます。

例：

```kotlin
val list = listOf(1, 2, 3)
val doubled = list.map { it * 2 } // it: Int
```

- map 関数の型: map(transform: (T) -> R): List<R>
- list は List<Int> なので T = Int
- よって、it の型は Int に推定される


### 🔹 3. 複数引数の場合

ラムダ式で複数の引数を使うとき、型が明示されないと Kotlin は型を推定できない場合があります。通常、明示的に指定する必要があります。

例：

```kotlin
val map = mapOf("a" to 1, "b" to 2)
map.forEach { key, value -> println("$key -> $value") } // エラー！
```

上記のように書くとエラーになるため、明示的に書く必要があります。

```kotlin
map.forEach { (key, value) -> println("$key -> $value") } // OK
```

または：

```kotlin
map.forEach { entry: Map.Entry<String, Int> ->
    println("${entry.key} -> ${entry.value}")
}
```


### 🔹 4. 戻り値の型推論

ラムダ式の 戻り値の型は、ラムダの本体の最後の式の型になります。

```kotlin
val add: (Int, Int) -> Int = { a, b -> a + b }
// 戻り値の型は Int に推定される（`a + b` が Int のため）
```

```kotlin
val isEven = { n: Int -> n % 2 == 0 }
// `n % 2 == 0` の型は Boolean → ラムダの戻り値は Boolean
```


### 🔹 5. 型を明示する場合

型推論がうまくできない、またはコードの可読性を上げたい場合には、引数や戻り値に型を明示できます。

```kotlin
val multiply: (Int, Int) -> Int = { a: Int, b: Int -> a * b }
```


### 🔹 補足：SAM 変換とラムダ

Java のインターフェース（Runnable, Comparator など）を Kotlin でラムダで使う場合は、SAM 変換によって型推定が行われます。

```kotlin
val thread = Thread { println("Hello from thread") } // Runnable に変換される
```





