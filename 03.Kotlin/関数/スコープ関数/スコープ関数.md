- [スコープ関数](#スコープ関数)
  - [概要](#概要)
  - [メリット](#メリット)
  - [スコープ関数の選択](#スコープ関数の選択)
    - [概要](#概要-1)
    - [注意点](#注意点)
    - [this と it の違い](#this-と-it-の違い)
      - [this と it の違いが生じる仕組み](#this-と-it-の違いが生じる仕組み)
        - [【参考】block のレシーバー T のインスタンスがどのように指定されているか](#参考block-のレシーバー-t-のインスタンスがどのように指定されているか)
      - [スコープを形成するかどうか](#スコープを形成するかどうか)
      - [見た目の違い](#見た目の違い)
    - [this と it どちらを使うのかの覚え方](#this-と-it-どちらを使うのかの覚え方)
    - [it はデフォルトのプロパティ名なので変更可能](#it-はデフォルトのプロパティ名なので変更可能)
    - [戻り値の違い](#戻り値の違い)
    - [コンテキストオブジェクトを返す場合](#コンテキストオブジェクトを返す場合)
    - [ラムダの結果を返す場合](#ラムダの結果を返す場合)
  - [スコープ関数ごとの具体的な使用例](#スコープ関数ごとの具体的な使用例)
    - [let](#let)
    - [with](#with)
    - [with と T.run の使い分け](#with-と-trun-の使い分け)
    - [T.run](#trun)
    - [run](#run)
    - [apply](#apply)
    - [also](#also)
    - [apply と also の使い分け](#apply-と-also-の使い分け)
  - [takeIf と takeUnless](#takeif-と-takeunless)


# スコープ関数

## 概要

Kotlin 標準ライブラリには、オブジェクトのコンテキスト内でコードのブロックを実行することを唯一の目的とする関数がいくつか含まれています。ラムダ式を指定してオブジェクトに対してこのような関数を呼び出すと、一時的なスコープが形成されます。このスコープでは、名前なしでオブジェクトにアクセスできます。このような関数はスコープ関数と呼ばれます。

スコープ関数には、 `let` , `run` , `with` , `apply` , `also` の 5 つがあります。基本的に、これらの関数はすべて同じアクションを実行します。つまり、オブジェクトに対してコードのブロックを実行します。異なる点は、このオブジェクトがブロック内でどのように利用可能になるか、そして式全体の結果がどのようになるかです。


## メリット

スコープ関数の使用方法の典型的な例を次に示します。

```kotlin
Person("Alice", 20, "Amsterdam").let {
    println(it) // Person(name=Alice, age=20, city=Amsterdam)
    it.moveTo("London")
    it.incrementAge()
    println(it) // Person(name=Alice, age=21, city=London)
}
```

`let` を使わずに同じことを書くと、新しい変数を導入し、それを使用するたびにその名前を繰り返す必要があります。

```kotlin
val alice = Person("Alice", 20, "Amsterdam")
println(alice)
alice.moveTo("London")
alice.incrementAge()
println(alice)
```

スコープ関数は新しい技術機能を導入しませんが、コードをより簡潔で読みやすくすることができます。

スコープ関数には多くの類似点があるため、ユースケースに適した関数を選択するのは難しい場合があります。選択は主に、目的とプロジェクトでの使用の一貫性によって決まります。以下に、スコープ関数の違いとその規則について詳しく説明します。


## スコープ関数の選択

### 概要

前提として、さまざまなスコープ関数のユースケースは重複しているため、プロジェクトまたはチームで使用される特定の規則に基づいて、どの関数を使用するかを選択できます。

各スコープ関数の主要な違いは以下の通りです。

| 関数  | オブジェクトの参照方法 | 戻り値                   | 拡張関数か                                                 |
| ----- | ---------------------- | ------------------------ | ---------------------------------------------------------- |
| let   | it                     | ラムダ式の結果           | ○                                                          |
| run   | this                   | ラムダ式の結果           | ○                                                          |
| run   | -                      | ラムダ式の結果           | × : コンテキストオブジェクト (レシーバー) なしで呼ばれる。 |
| with  | this                   | ラムダ式の結果           | × : 引数にコンテキストオブジェクトをとる                   |
| apply | this                   | コンテキストオブジェクト | ○                                                          |
| also  | it                     | コンテキストオブジェクト | ○                                                          |

関数を選択する方法の簡単なガイドを以下に示します。

- let
  - null ではないオブジェクトでラムダ式を実行したい場合
  - ローカルスコープ内でコンテキストオブジェクトを明示的に参照したい場合
- apply
  - コンテキストオブジェクトを構築したい場合
- run
  - コンテキストオブジェクトを構築し、 (そのコンテキストオブジェクトではなく) 構築の実行結果 (成功や失敗など) を返したい場合
  - 複数の処理をブロックとしてまとめたい場合。また、そのブロックの処理結果を呼び出し元に返したい場合
- 拡張関数ではない run
  - コンテキストオブジェクトなしで実行でき、スコープ内でコンテキストオブジェクトを初めて構築して、そのオブジェクトを戻したい場合
- also
  - apply とほとんど同じ
- with
  - オブジェクト上で呼ばれるグループ化関数


### 注意点

スコープ関数を過度に使用すると、逆に読みづらくなるため、注意してください。

例えば、ネストが深いところでスコープ関数を使用すると `it` と `this` が何を示しているのか混乱することにつながります。また、過度にスコープ関数をチェーンするとその用法が似ていることから混乱につながる可能性が高いです。


### this と it の違い

#### this と it の違いが生じる仕組み

- `this`
  - `run` , `with` , `apply` 関数は、自分自身をラムダ式のレシーバーとして指定しています。
  - 例えば、 apply 関数の場合は、次のように、関数型 block のレシーバーが自分自身 ( T ) となっています。
  - `fun <T> T.apply(block: T.() -> Unit): T` (【参考】block のレシーバー T のインスタンスがどのように指定されているか)
  - そのため、ラムダ式内では、自分自身を this で参照します。

- `it`
  - `let` , `also` 関数は、自分自身を関数のパラメータで渡しています。
  - 例えば、 also 関数の場合は、次のように、 block 関数の引数が自分自身 ( T ) となっています。
  - `fun <T> T.also(block: (T) -> Unit): T`
  - そのため、ラムダ式内では、自分自身を it で参照します。


##### 【参考】block のレシーバー T のインスタンスがどのように指定されているか

apply 関数の引数の block のレシーバー T のインスタンスはどのように指定されているのでしょうか？ここでは、それについて説明します。

まずは、 apply 関数の定義を確認していきましょう。

```kotlin
fun <T> T.apply(block: T.() -> Unit): T {
    block()
    return this
}
```

レシーバー付き関数は、その関数の呼び出しまでに必ずインスタンスを渡してあげる必要があります。上記のコードでは、 block 関数の呼び出し時に、 T 型のインスタンスが渡されていないように見えます。しかし、 block に T 型のインスタンスを渡す方法が一つだけ存在しています。それは、暗黙的な this によって、 this.block() という関数呼び出しを行って渡す方法です。 this を明示的に渡すと以下のようになります。

```kotlin
fun <T> T.apply(block: T.() -> Unit): T {
    // この this が省略されている
    this.block()
    return this
}
```

apply 関数自体がレシーバー付き関数であるため、 apply 関数内で this を参照すると、そのレシーバーのインスタンスを取得することができます。このようにして、 block 関数のレシーバー T のインスタンスは渡されています。

ちなみに、細かいですが、 this を引数に渡す場合は、省略ができないため、 `block(this)` という渡し方をしているわけではなく、 `this.block()` という渡し方の省略形となります。


#### スコープを形成するかどうか

- this 系関数の場合
  - ラムダブロック内に、自分自身のスコープを形成します。
  - そのため、そのスコープ内からしか参照できないプロパティや関数にアクセスできます。
- it 系関数の場合
  - ラムダブロック内に、自分自身のスコープは形成されません。
  - そのため、 it は単なる引数としての役割しか持ちません。

this がスコープとして機能している例については、以下を参照してください。

- [拡張関数(レシーバー付き関数).md -> this 系のスコープ関数のラムダ式内から呼び出す場合の例](../拡張関数(レシーバー付き関数).md/#this-系のスコープ関数のラムダ式内から呼び出す場合の例)


#### 見た目の違い

- this 系関数の場合
  - メリット
    - this でコンテキストオブジェクトを参照する場合は、 this 自体が省略可能であるため、自分自身のメンバーを参照することが多い場合に表記がシンプルになります。
  - デメリット
    - 一方で、省略することで、コンテキストブロックの外側のメンバーを参照しているのか、自分自身を参照しているのかが曖昧になってしまうデメリットはあります。

- it 系関数の場合
  - メリット
    - it のメリットは、 this よりも短い単語であるため、読み書きしやすいところです。 this を省略せずに記載する必要がある場合には、 it を使用した方が良いでしょう。
  - 使用例
    - 例えば、コンテキストオブジェクトを関数の引数に使用する場合は it を使用すると良いでしょう。

```kotlin
fun getRandomInt(): Int {
    return Random.nextInt(100).also {
        // スコープ関数のブロック内で
        // 関数の引数としてオブジェクトを参照しているため、
        // it が使えるスコープ関数を選ぶと良い。
        writeToLog("getRandomInt() generated value $it")
    }
}

val i = getRandomInt()
println(i)
```


### this と it どちらを使うのかの覚え方

英語の it と this には、以下のようなニュアンスがあります。

- it は既に話題に出たものや文脈で明らかなもの
- this は今まさに指し示しているもの

つまり、 it は、既に話題に出てきているもの (形のないものも含む) を示します。スコープ関数の also は、この典型で、以前に出てきたものに対して、 「～も、また、～」 という意味なので、 it が適切だと言えます。

also 以外のスコープ関数については、必ずしも英語のニュアンスで、 it か this のどちらを使用するという決まりはないため、ニュアンス通りにならないこともあります。しかし、根本的には、英語という自然言語で、 it を使うことが多いのか、 this を使うことが多いのかに基づいて、スコープ関数が 「 it を使うべきか」 、 「 this を使うべきか」 が決まっていると思われます。


### it はデフォルトのプロパティ名なので変更可能

引数が一つだけのラムダ式で、引数名を省略すると、デフォルトで it という名前が割り当てられますが、この名前は変更することが可能です。同様に、スコープ関数の引数名も変更することが可能です。以下の例では、 it を value という名前に変更しています。

```kotlin
fun getRandomInt(): Int {
    return Random.nextInt(100).also { value ->
        writeToLog("getRandomInt() generated value $value")
    }
}

val i = getRandomInt()
println(i)
```


### 戻り値の違い

`apply` , `also` はコンテキストオブジェクトを返します。 `let` , `run` , `with` はラムダの結果を返します。

コード内で次に何をするかによって、どのような戻り値が必要か選択するのが良いでしょう。


### コンテキストオブジェクトを返す場合

コンテキストオブジェクトを返す apply と also のよくある使用例を以下に二つ記載します。

1. 関数チェーンを行う場合

```kotlin
val numberList = mutableListOf<Double>()
numberList.also { println("Populating the list") }
    .apply {
        add(2.71)
        add(3.14)
        add(1.0)
    }
    // いくつでも関数呼び出しがチェーンできます。
    .also { println("Sorting the list") }
    .sort()
```

2. 関数の戻り値としてコンテキストオブジェクトを返したい場合

```kotlin
fun getRandomInt(): Int {
    return Random.nextInt(100).also {
        writeToLog("getRandomInt() generated value $it")
    }
}

val i = getRandomInt()
```


### ラムダの結果を返す場合

ラムダの結果を返す let と run と with のよくある使用例を以下に三つ記載します。

1. ラムダの結果を変数に格納したい場合

```kotlin
val numbers = mutableListOf("one", "two", "three")
val countEndsWithE = numbers.run { 
    add("four")
    add("five")
    count { it.endsWith("e") } // "e" で終わる要素の数をカウント
}
println("There are $countEndsWithE elements that end with e.")
```

2. ラムダの結果に対して関数をチェーンしたい場合

```kotlin
fun main() {
    val numbers = mutableListOf("one", "two", "three")
    numbers.run { 
        add("four")
        add("five")
        size
    }.let {
        println("size of list = $it") // size of list = 5
    }
}
```


3. ラムダの戻り値を無視して、単なるプロパティのローカルスコープとして使用する場合

```kotlin
val numbers = mutableListOf("one", "two", "three")
with(numbers) {
    val firstItem = first()
    val lastItem = last()
    // First item: one, last item: three
    println("First item: $firstItem, last item: $lastItem")
}
```


## スコープ関数ごとの具体的な使用例

### let

1. 新たなプロパティの定義をなくす

let を使用しなかった場合

```kotlin
val numbers = mutableListOf("one", "two", "three", "four", "five")
val resultList = numbers.map { it.length }.filter { it > 3 }
println(resultList) // [5, 4, 4]
```

上記のコードを let を使用して書き直すと以下のようになります。 resultList というプロパティを定義する必要がなくなりました。

```kotlin
val numbers = mutableListOf("one", "two", "three", "four", "five")
numbers.map { it.length }.filter { it > 3 }.let { 
    println(it)
    // 必要に応じてさらに関数呼び出しを続けられます。
} 
```

さらに、上記のコードは println の引数に it を渡しているだけなので、関数参照を使用して書き換えることが可能です。この場合の let 関数は引数 it を関数参照の引数に直接渡して実行するように実装されています。

```kotlin
val numbers = mutableListOf("one", "two", "three", "four", "five")
numbers.map { it.length }.filter { it > 3 }.let(::println)
// 実行結果
// [5, 4, 4]
```


2. null チェックを if 文よりも簡潔に記述

Nullable オブジェクトが null でない場合にのみ実行したいコードブロックがある場合に `?.` 演算子で let 関数を呼び出すと、 if 文で null チェックを記述するよりも、少しですが簡潔に記述することが可能になります。

```kotlin
val str: String? = "Hello" 

// 以下は null である可能性があるためコンパイルエラーになる  
//processNonNullString(str)

val length = str?.let { 
    println("let() called on $it")        
    processNonNullString(it) // it は null ではないことが保証される
    it.length
}
```

```kotlin
private val dir: File? = null

if(dir != null){
    val d = dir!!
    if(d.exists()) d.delete()
}
```


3. メンバプロパティのローカルプロパティ化

コンテキストオブジェクトをメンバープロパティとして定義している場合、ローカルプロパティとして定義しなおすことができる可能性があります。

```kotlin
val numbers = listOf("one", "two", "three", "four")
val modifiedFirstItem = numbers.first().let { firstItem ->
    // The first item of the list is 'one'
    println("The first item of the list is '$firstItem'")
    if (firstItem.length >= 5) firstItem else "!" + firstItem + "!"
}.uppercase()

// First item after modifications: '!ONE!'
println("First item after modifications: '$modifiedFirstItem'")
```


### with

with は、拡張関数の run と非常によく似ています。違いは、コンテキストオブジェクトを関数の引数として受け取るか、それともレシーバーとして記述されるかだけです。

```kotlin
class Person(val name: String) {
    fun printName() {
        print("name = $name")
    }
}

val person = Person("Taro")

// with の使用例
with(person) {
    printName() // person.printName() と同じ
}

// run の使用例
person.run {
    printName() // person.printName() と同じ
}
```

with は、コンテキストオブジェクトの関数を呼んだり、プロパティにアクセスすることに専念しています。なぜなら with には、 「このオブジェクトを使って、次のコードを実行してください」 という意味が含まれているためです。 ( with this object, do the following. ) 例えば、ラムダ内でコンテキストオブジェクトのメンバーに直接アクセスしている処理がなければ、 with を削除するようにワーニングが表示されます。

```kotlin
val person = Person("Taro")

// ワーニングが出ます
with(person) {
    // コンテキストオブジェクトに全くアクセスしていない場合
    print("")
}

// ワーニングが出ます
with(person) {
    // メンバーに直接アクセスせずに、インスタンス名を付与してアクセスしている
    person.printName()
}

// ワーニングは出ません
with(person) {
    this.printName()
}

// ワーニングは出ません
with(person) {
    printName()
}
```


### with と T.run の使い分け 

run を使用するメリットは二つあります。

1. 関数チェーンが可能
2. `?.` 表記法で null なら実行しないということが可能

with を使用するメリットは一つあります。

1. レシーバー部分が長い場合に可読性が上がる

以下は、カスタムラインブレイクをなくして、標準のラインブレイクで改行した場合です。明らかに、 with を使用したほうが読みやすくなっています。

```kotlin
// run を使用した場合
val result1 = StringBuilder().append("xxx").append("yyy").append("zzz").run {
    append("abc")
    toString()
}

// with を使用した場合
val result2 = with(
    StringBuilder().append("xxx").append("yyy").append("zzz")
) {
    append("abc")
    toString()
}
```

公式ドキュメントで with の使用を推奨しているケース

1. 戻り値がない場合

なんか、 with という単語の意味としっくり合う気がする。

```kotlin
val numbers = mutableListOf("one", "two", "three")
with(numbers) {
    // 'with' is called with argument [one, two, three]
    println("'with' is called with argument $this")
    // It contains 3 elements
    println("It contains $size elements")
}
```

2. コンテキストオブジェクトのヘルパークラス or 関数を作りたい場合

```kotlin
val numbers = mutableListOf("one", "two", "three")
val firstAndLast = with(numbers) {
    "The first element is ${first()}," +
    " the last element is ${last()}"
}
// The first element is one, the last element is three
println(firstAndLast)
```


### T.run 

拡張関数の run は with とほとんど同じです。 with の項で説明しているため、ここでは省略します。


### run

ここでは、拡張関数ではない方の run について説明します。

run には、 「コードブロックを実行して、結果を算出する」 ( "run the code block and compute the result." ) という意味が込められています。この run は式であるため、複数のコードを実行して、その結果をプロパティに代入することが可能です。

```kotlin
val hexNumberRegex = run {
    val digits = "0-9"
    val hexDigits = "A-Fa-f"
    val sign = "+-"

    Regex("[$sign]?[$digits$hexDigits]+")
}

for (match in hexNumberRegex.findAll("+123 -FFFF !%*& 88 XYZ")) {
    println(match.value)
}
```


### apply

apply の主な用途は、オブジェクトの構築です。

apply には、 「次の処理 (パラメータの代入) をコンテキストオブジェクトに適用してください」 ( "apply the following assignments to the object." ) という意味が込められています。

```kotlin
val adam = Person("Adam").apply {
    age = 32
    city = "London"        
}
println(adam) // Person(name=Adam, age=32, city=London)
```


### also

also は、引数にコンテキストオブジェクトを含む処理を実行する場合に適しています。または、ブロック内で、コンテキストオブジェクトへの参照を隠蔽したくない場合に適しています。例えば、 also ブロックとその外側のブロックに同じ名前の関数が存在している場合には、コンテキストオブジェクトへの参照を明示的に記述した方が誤解を防げるでしょう。

also には、 「コンテキストオブジェクトを使用して、以下の処理も実行してください」 ( "and also do the following with the object." ) という意味が込められています。

```kotlin
val numbers = mutableListOf("one", "two", "three")
numbers
    .also { println("The list elements before adding new one: $it") }
    .add("four")
// The list elements before adding new one: [one, two, three]
```


### apply と also の使い分け

一般的には、 apply でオブジェクトの初期化を行い、さらにそのオブジェクトを使用した何らかの処理を行う場合には、 also で実行するという使用方法になるでしょう。


## takeIf と takeUnless

takeIf と takeUnless は、関数チェーンの中で、オブジェクトの状態チェックを埋め込むことができます。

takeIf は、コンテキストオブジェクトが引数の条件に一致していれば、そのオブジェクトを返します。一致していなければ、 null を返します。

takeUnless は、 takeIf と逆の動きをします。つまり、コンテキストオブジェクトが引数の条件に一致していれば、 null を返し、一致していなければ、そのオブジェクトを返します。

いずれの関数も、ブロック内でコンテキストオブジェクトを参照するには it を使用します。

```kotlin
val number = Random.nextInt(100)

val evenOrNull = number.takeIf { it % 2 == 0 }
val oddOrNull = number.takeUnless { it % 2 == 0 }
println("even: $evenOrNull, odd: $oddOrNull") // even: 70, odd: null
```

takeIf や takeUnless は他のスコープと組み合わせると便利です。例えば、条件に一致した場合のみ let で処理を行うことが可能です。具体的には `takeIf(xxx)?.let{}` のようにすると良いでしょう。






