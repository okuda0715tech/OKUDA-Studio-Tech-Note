- [境界型](#境界型)


# 境界ワイルドカード型 (変性の管理)

## Java と Kotlin の違い

境界ワイルドカード型を表すのに Java と Kotlin で文法に違いがあるため、以下の表にまとめます。

| 指定区分 | Java (使用側変性)             | Kotlin (定義側変性 or 使用側変性) |
| -------- | ----------------------------- | --------------------------------- |
| 上限指定 | MySupplier\<? extends Animal> | MySupplier\<out Animal>           |
| 下限指定 | MyConsumer\<? super Animal>   | MyConsumer\<in Animal>            |

Java では、ジェネリクスなクラスやメソッドを使用する側で変性を管理するのに対して、  
Kotlin では、ジェネリクスなクラスやメソッド側でも変性が管理できるようになっています。

一般的に、  
使用側変性定義のことを 「 Use-site variance 」  
定義側変性定義のことを 「 Declaration-site variance 」  
と呼びます。


## 使用側変性と定義側変性の比較

| 変性定義方法 | メリット                              | デメリット                                             |
| :----------- | :------------------------------------ | :----------------------------------------------------- |
| 定義側変性   | 宣言時に一度だけ out, in を書けばいい | 対応可能なケースが限定されている                       |
| 使用側変性   | より柔軟なケースに対応可能            | 利用時に毎回 ? extends, ? super を書かなければならない |


## サンプルコード

以下は、ジェネリクスなクラスの定義側で変性を定義した例です。  
(使用側でも、普通に変性の定義が可能です。)

```Kotlin
// out が付与された型は戻り値にしか使えない
interface MySupplier<out T> {
    fun get(): T
}

// in が付与された型は引数にしか使えない
interface MyConsumer<in T> {
    fun accept(t: T)
}
```

`in` と `out` は、その名の通り、 「メソッドの in (引数) か out (戻り値) にしか使用できなくなる」  
と考えれば、覚えなくともすんなりとコードが読み書きできるようになります。


## 複雑に見えるケース

```Kotlin
interface Foo<out T> {
    fun foo(Consumer<T> consumer);
}
```

上記の例では、 T が引数で使われているため `<in T>` にするべきに見えるが、  
実際に T が使用されているのは `Consumer` の中であり、  
`Consumer` の定義が `Consumer<in T>` となっていれば、  
`Foo` の定義は `<out T>` となっていて問題なし。




