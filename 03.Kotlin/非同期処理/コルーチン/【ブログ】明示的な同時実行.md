- [明示的な同時実行](#明示的な同時実行)
  - [引用元資料](#引用元資料)


# 明示的な同時実行

この記事は、何が言いたいのかよくわからないので、読まなくても良いかも。

現代社会では、同時実行が重要です。モバイル アプリケーションや Web アプリケーションは、ネットワーク リクエストを実行しながら、同時に UI を更新し、アニメーションを表示し、ユーザー入力に反応できる必要があります。サーバー側アプリケーションは、多数の同時リクエストを処理できる必要があります。並列処理はどうでしょうか。これも便利ですが、それほど頻繁に行われるわけではありません。多くの成功したサーバー側アプリケーションは、並列処理なしで完全に 1 つのスレッドで実行されますが、非常にうまく拡張できます (node.js プラットフォーム全体について考えてみてください)。

並列処理がなくても、同時実行は難しく、微妙なタイミング依存のバグの原因となる可能性があります。開発者は、次々に処理を実行する順次プログラムに慣れているため、関数型、または、命令型のどちらでコーディングするかは問題ではありません。関数呼び出しの概念全体が順次的です。つまり、関数を呼び出し、しばらくすると、結果が返され、その結果を使用することができます。次のコードをご覧ください。

```kotlin
foo(bar())
```

これは単なる式であり、非常に機能的に見えますが、シーケンシャル コードの良い例です。次のように、より命令型のスタイルで書き直すと、そのシーケンシャルな性質が明らかになります。

```kotlin
val x = bar()  // first call bar
foo(x)         // then call foo
```

[「スレッドのブロック、コルーチンのサスペンド」](https://elizarov.medium.com/blocking-threads-suspending-coroutines-d33e11bf4761) のストーリーでは、 Kotlin の通常の関数とサスペンド関数の違いを示しました。後者はスレッドをブロックしませんが、それでも順次実行されます。たとえば、 bar がサスペンドしている場合、上記の例は依然として順次実行され、 foo は bar が正常に返された後にのみ実行されます。

一方、 Kotlin では並行性は非常に明確です。プログラムの残りの部分を尊重しながら、コードの一部の並行実行を開始するには、 launch { ... } などのコルーチン ビルダーを明示的に使用します。

```kotlin
launch {
    foo(bar()) 
}
```

ただし、kotlinx.coroutines ライブラリ内のすべての同時実行コルーチン ビルダーは CoroutineScope インターフェースの拡張機能として宣言されており、 launch も例外ではありません。そのため、 foo(bar()) の同時実行を開始するコードを別のトップレベル関数に抽出すると、次のシグネチャを持つ関数が得られます。

```kotlin
fun CoroutineScope.launchFooBar() = launch { 
    foo(bar())
}
```

この関数はすぐに戻り、 launchFooBar を呼び出すプログラムの残りの部分と同時に foo(bar()) を実行します。

これにより、次の便利な規則が生まれます。 **CoroutineScope の拡張関数として宣言されているすべての関数は、すぐに戻り、そのアクションは、拡張関数の呼び出し元の後続処理と同時に実行されます。**

また、 runBlocking が CoroutineScope の拡張関数ではない理由の 1 つも説明できます。

独自のコードで、この規則に従うことも、非常に役立ちます。反例で示すのは簡単です。作業中のコードのどこかで偶然見つけた、次のシグネチャを持つ関数を考えてみましょう。

```kotlin
// obfuscate は「難読化する」の意味
suspend fun CoroutineScope.obfuscate(data: Data)
```

この関数は何ができるでしょうか。これはサスペンド関数なので、定義上、コルーチンの実行をサスペンドできることはわかっています。しかし、これは CoroutineScope の拡張機能としても定義されているため、プログラムの他の部分と同時に機能する何かを実行するために新しいコルーチンを起動することもできます。では、なぜ実行をサスペンドするのでしょうか。操作のどの部分が、同時に実行されるのでしょうか。ドキュメントやソース コードを読まなければわかりません。一方、サスペンド関数として宣言することを選択した場合は、次のようになります。

```kotlin
suspend fun obfuscate(data: Data)
```

そして、慣例により、呼び出し元をブロックせずに難読化処理を実行し、完了したら呼び出し元に戻ることがわかります。

あるいは、これを CoroutineScope 拡張機能として宣言することを選択した場合:

```kotlin
fun CoroutineScope.obfuscate(data: Data)
```

その後、慣例により、呼び出し元をブロックせずにすぐに戻り、プログラムの他の部分と同時に難読化処理を開始することがわかります。

経験則として、同時実行はデフォルトで安全ではないため、サスペンド関数を優先する必要があります。サスペンド関数を手元に持っている人は、明示的に launch { ... } を使用して同時実行を開始できます。

**グローバル スコープ**

同時実行を開始する必要があるが、コードがどの CoroutineScope 内にもない場合は、 GlobalScope.launch { ... } を記述したくなります。これは、新しいタスクをグローバル バックグラウンド スレッド プールに送信するのと同じくらい簡単です。この誘惑に負けないでください。この方法では、同時実行中のアクティビティを見失ったり、リソースを使い果たしたり、メモリ リークを引き起こしたりすることは難しくありません (「GlobalScope を避ける理由」で詳細を参照してください)。

CoroutineScope を明示的に使用すると、アプリケーション内のすべての同時操作を包含、制限、追跡でき、重要なことに、それらをアプリケーション エンティティのライフサイクルに結び付けることができます。しかし、それはまた別の話です ( [「コルーチンのコンテキストとスコープ」](./【ブログ】CoroutineContext%20と%20Scope.md) ( [引用元資料はこちら](https://elizarov.medium.com/coroutine-context-and-scope-c8b255d59055) ) を参照してください)。

**参考資料**

Kotlin コルーチンで CoroutineScope と構造化された並行性が導入された理由は、 [「構造化された並行性」](https://elizarov.medium.com/structured-concurrency-722d765aa952) の記事で説明されています。また、サスペンド関数が複数の同時操作を実行しながら、処理が完了したときにのみ呼び出し元に戻るという不変条件を維持する方法も示しています。

同時実行の正式な定義と、それがシーケンシャルとどう違うのかに興味がある場合は、しばらく前に書いた [並行性に関する記事](https://proandroiddev.com/what-is-concurrent-access-to-mutable-state-f386e5cb8292) で、この難しい理論的問題に対する非常にわかりやすい紹介を読んでください。

GlobalScope の詳細については、 [GlobalScope を避ける理由](https://medium.com/@elizarov/the-reason-to-avoid-globalscope-835337445abc) の記事をご覧ください。


## 引用元資料

- [Explicit concurrency - Medium](https://elizarov.medium.com/explicit-concurrency-67a8e8fd9b25)


