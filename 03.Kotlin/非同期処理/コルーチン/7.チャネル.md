- [チャネル](#チャネル)
  - [チャネルの基礎](#チャネルの基礎)
  - [チャネルのクローズと反復処理](#チャネルのクローズと反復処理)
  - [チャネルプロデューサーの構築](#チャネルプロデューサーの構築)
  - [パイプライン](#パイプライン)
    - [補足](#補足)
  - [パイプラインを使用した素数の生成](#パイプラインを使用した素数の生成)
  - [Fan-out（一ヶ所から扇状に広がること）](#fan-out一ヶ所から扇状に広がること)
  - [Fan-in（複数個所から一ヶ所に集まること）](#fan-in複数個所から一ヶ所に集まること)
  - [バッファリングされたチャネル](#バッファリングされたチャネル)
  - [チャネルの公平性](#チャネルの公平性)
  - [ティッカー（限られた狭い領域）チャネル](#ティッカー限られた狭い領域チャネル)
  - [チャネルをホットフローに変換する](#チャネルをホットフローに変換する)
    - [receiveAsFlow](#receiveasflow)
    - [consumeAsFlow](#consumeasflow)


# チャネル

遅延値 ( Deferred values ) は、コルーチン間で単一の値を転送する方法を提供します。一方で、チャネルは、値のストリームを転送する方法を提供します。


## チャネルの基礎

Channel は概念的には BlockingQueue と非常によく似ています。一つの重要な違いは、ブロッキング put 操作の代わりに一時停止送信があり、ブロッキング take 操作の代わりに一時停止受信があることです。

```kotlin
fun main() = runBlocking {
    val channel = Channel<Int>()
    launch {
        // 五つの平方を送信します。
        for (x in 1..5) channel.send(x * x)
    }
    // 五つの受信した数値を出力します。
    // 値が送信されるまで一時停止します。
    repeat(5) { println(channel.receive()) }
    println("Done!")
}
```

```
実行結果

1
4
9
16
25
Done!
```


## チャネルのクローズと反復処理

キューとは異なり、チャネルは閉じて、これ以上要素が来ないことを示すことができます。受信側では、通常の for ループを使用してチャネルから要素を受信すると便利です。

概念的には、クローズは特別なクローズトークンをチャネルに送信するようなものです。よって、クローズされたということは、クローズ前に送信されたすべての要素が受信済みであることが保証されます。クローズトークンを受信するとすぐに反復処理が停止します。

```kotlin
fun main() = runBlocking {
    val channel = Channel<Int>()
    launch {
        for (x in 1..5) channel.send(x * x)
        channel.close()
    }
    // チャネルがクローズされるまで、 for ループで受信した値を出力します。
    // for 文を使用すると暗黙的に receive 文が実行されます。
    for (y in channel) println(y)
    println("Done!")
}
```

```
実行結果

1
4
9
16
25
Done!
```

この for 文では、 `for (y in channel)` の channel が空になっても、次の要素がチャネルに送信されてくるのを待機します。そのため、送信側で明示的に close() を実行しなかった場合、永遠に Done! の文字列は表示されない点に注意してください。


## チャネルプロデューサーの構築

コルーチンが連続した要素 (コレクション的なもの) を生成するパターンは、非常に一般的です。これは、並列実行コードでよく見られる 「プロデューサー - コンシューマー」 パターンの一部です。このようなプパターンを実装するのに便利な機能が用意されています。

プロデューサー側は [produce](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html) というコルーチンビルダーがあり、コンシューマー側は、 for ループを置き換える拡張関数 [consumeEach](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html) があります。プロデューサー側は、 produce 関数の結果として ReceiveChannel を返します。 ReceiveChannel は、受信専用のチャネルで、 Channel インターフェースでも継承されているものです。

```kotlin
fun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {
    for (x in 1..5) send(x * x)
}

fun main() = runBlocking {
    val squares = produceSquares()
    squares.consumeEach { println(it) }
    println("Done!")
}
```

```
実行結果

1
4
9
16
25
Done!
```

この方法では、 close を明示的に実行しなくても、最後の Done! が表示されるため、最後の要素の送信後に、クローズトークンを自動的に送信しているようです。


## パイプライン

もともと、パイプラインは複数のパイプを繋げて一本の長いパイプにしたものを示します。プログラミングにおけるパイプラインパターン（Pipeline Pattern）は、データの処理を一連のステージ（ステップ）に分割し、各ステージでデータが順次処理されるパターンです。各ステージはデータを受け取り、何らかの処理を行った後に次のステージにデータを渡します。このようなパイプライン方式は、処理の分割と再利用性を高め、コードの可読性と保守性を向上させることができます。

```kotlin
fun CoroutineScope.produceNumbers() = produce<Int> {
    var x = 1
    // 1 から始まる Int 型の無制限のストリーム
    while (true) send(x++)
}
```

そして、別のコルーチンがそのストリームを消費し、何らかの処理を実行し、他の結果を生成します。以下の例では、数値が単に二乗されています。

```kotlin
// numbers には、上記の produceNumbers 関数の結果が渡されます。
fun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {
    for (x in numbers) send(x * x)
}
```

メインコードがパイプライン全体を開始して接続します。

```kotlin
fun main() = runBlocking {
    val numbers = produceNumbers()
    val squares = square(numbers)
    repeat(5) {
        // 最初の五つだけ表示します。
        println(squares.receive())
    }
    println("Done!")
    // 全ての子コルーチンをキャンセルします。
    // coroutineContext は、 CoroutineScope のプロパティです。
    // 全ての子コルーチンをキャンセルすることで、親コルーチンが終了できる状態になります。
    coroutineContext.cancelChildren()
}
```

コルーチンを作成するすべての関数は CoroutineScope の拡張機能として定義されているため、構造化された同時実行性を利用して、アプリケーション内にコルーチンが残らないようにすることができます。


### 補足

上記のサンプルコードで、再開可能なコルーチンが複数ある場合に、どのコルーチンから再開するのか確認したかったので、わかりやすいログを追加してみたので、そのコードを以下に載せておきます。ただし、どのコルーチンから再開するのかはルールがわかりませんでした。どのコルーチンから再開するかは処理結果には関係なく、再開順序も保証されていなさそうなので、再開順序に依存しない実装にする必要がありそう。

```kotlin
fun CoroutineScope.produceNumbers() = produce<Int> {
    var x = 1
    while (true) {
        Log.v("test", "[fun produceNumbers] sending $x. <suspended>")
        send(x++)
        Log.v("test", "[fun produceNumbers] sent ${x - 1}. <resumed>")
    }
}

val logSpace1 = "                    "

fun CoroutineScope.square(numbers: ReceiveChannel<Int>):ReceiveChannel<Int> = produce {
    for (x in numbers) {
        Log.v("test", "$logSpace1 [fun square] received $x <resumed>")
        Log.v("test", "$logSpace1 [fun square] sending ${x * x}. <suspended>")
        send(x * x)
        Log.v("test", "$logSpace1 [fun square] sent ${x * x}. <resumed>")
        Log.v("test", "$logSpace1 [fun square] receiving ... <suspended>")
    }
}

val logSpace2 = "                                        "

fun main() = runBlocking {
    val numbers = produceNumbers()
    val squares = square(numbers)
    repeat(5) {
        Log.v("test", "$logSpace2 [fun repeat] receiving ... <suspended>")
        Log.v("test", "$logSpace2 [fun repeat] received ${squares.receive()} <resumed>")
    }
    Log.v("test", "Done!")
    coroutineContext.cancelChildren()
}
```


## パイプラインを使用した素数の生成

パイプラインを極限まで活用して、コルーチンのパイプラインを使用して素数を生成する例を見てみましょう。まず、無限の数列から始めます。

```kotlin
fun CoroutineScope.numbersFrom(start: Int) = produce<Int> {
    var x = start
    // start から始まり無限に続く Int 型の値
    while (true) send(x++)
}
```

次のパイプラインステージでは、入力される数値ストリームをフィルター処理し、指定された素数で割り切れるすべての数値を削除します。

```kotlin
fun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {
    for (x in numbers) if (x % prime != 0) send(x)
}
```

次の例では、メインスレッドのコンテキストでパイプライン全体を実行し、最初の 10 個の素数を出力します。すべてのコルーチンはメインの runBlocking コルーチンのスコープ内で起動されるため、開始したすべてのコルーチンの明示的なリストを保持する必要はありません。最初の 10 個の素数を出力した後、 cancelChildren 拡張関数を使用してすべての子コルーチンをキャンセルします。

**このプログラムを正確に理解するには、まず、素数の算出アルゴリズムを理解する必要があるため、正確に理解する必要はありません。「再帰呼び出しを行うと、こんな高度なこともできるよ」ということが感じられればそれでOKです。**

```kotlin
fun main() = runBlocking {
    var cur = numbersFrom(2)
    repeat(10) {
        // 素数を受け取って表示する。
        // cur には、常に先頭のパイプが格納されている。
        val prime = cur.receive()
        println(prime)
        // cur は、新しい ReceiverChannel で上書きされます。
        // filter 関数が呼び出される度に、コルーチンと ReceiverChannel が一つずつ増えていきます。
        cur = filter(cur, prime)
    }
    // 全ての子コルーチンをキャンセルすることで、親コルーチンが終了できる状態になります。
    coroutineContext.cancelChildren()
}
```

```
実行結果

2
3
5
7
11
13
17
19
23
29
```

標準ライブラリのイテレータコルーチンビルダーを使用して同じパイプラインを構築できることに注意してください。 produce を iterator に、 send を yield に、 receive を next に、 ReceiveChannel を Iterator に置き換え、コルーチンスコープを削除します。 runBlocking も必要ありません。ただし、上記のようにチャネルを使用するパイプラインの利点は、 Dispatchers.Default コンテキストで実行すると、実際に複数の CPU コアを使用できることです。

いずれにせよ、これは素数を見つけるための非常に非実用的な方法です。実際には、パイプラインには他の suspend 関数の呼び出し (リモートサービスへの非同期呼び出しなど) が含まれており、これらのパイプラインは、完全に非同期である produce とは異なり、任意の中断を許可しないため、 sequence や iterator を使用して構築することはできないでしょう。


## Fan-out（一ヶ所から扇状に広がること）

一つのチャネルに送信されたデータを、複数のコルーチンで受信し、作業を分散することができます。まずは、整数を定期的に生成する ( 1 秒あたり 10 個の数値) プロデューサーコルーチンから始めましょう。

```kotlin
fun CoroutineScope.produceNumbers() = produce<Int> {
    // 最初に送る値
    var x = 1
    while (true) {
        send(x++)
        delay(100)
    }
}
```

次に、複数のプロセッサコルーチンを作成できます。この例では、 ID と受信番号を印刷するだけです。

```kotlin
fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel<Int>) = launch {
    for (msg in channel) {
        println("Processor #$id received $msg")
    }
}
```

ここで、 5 つのプロセッサを起動し、約 1 秒間動作させてみます。何が起こるか見てみましょう。

```kotlin
fun main() = runBlocking<Unit> {
    val producer = produceNumbers()
    // 同じチャネルを 5 つの異なるコルーチンに渡す。
    repeat(5) { launchProcessor(it, producer) }
    delay(950)
    // 今回、プロデューサーコルーチンは無限に値を送信するため、キャンセルが必要です。
    producer.cancel()
}
```

プロセッサ ID はケースバイケースで異なりますが、出力は次のようになります。

```
実行結果

Processor #2 received 1
Processor #4 received 2
Processor #0 received 3
Processor #1 received 4
Processor #3 received 5
Processor #2 received 6
Processor #4 received 7
Processor #0 received 8
Processor #1 received 9
Processor #3 received 10
```

プロデューサーコルーチン ( produce 関数が生成した ReceiverChannel ) をキャンセルすると、そのチャネルが閉じられるため、最終的にプロセッサコルーチンが実行しているチャネルのイテレーター処理が終了することに注意してください。

また、 launchProcessor コードでファンアウトを実行するために、 for ループを使用してチャネルを明示的に反復処理している点にも着目してください。

consumeEach を使用した場合は、正常または異常な完了時に常に基礎となるチャネルを消費 (キャンセル) します。一方で、上記のように for ループを使用した場合は、プロセッサコルーチンの一つが失敗した場合、他のコルーチンは引き続きチャネルを処理します。


## Fan-in（複数個所から一ヶ所に集まること）

複数のコルーチンが同じチャネルに対して送信することができます。例えば、指定された遅延で指定された文字列を繰り返し送信する suspend 関数があるとします。

```kotlin
suspend fun sendString(channel: SendChannel<String>, s: String, time: Long) {
    while (true) {
        delay(time)
        channel.send(s)
    }
}
```

以下は、二つのコルーチンが同じチャネルに対して送信し、その結果を確認するコードです。 (この例では、メインスレッドのコンテキストでメインコルーチンの子として起動します)。

```kotlin
fun main() = runBlocking {
    val channel = Channel<String>()
    launch { sendString(channel, "foo", 200L) }
    launch { sendString(channel, "BAR!", 500L) }
    // 最初の 6 個を受信します。
    repeat(6) {
        println(channel.receive())
    }
    // 親コルーチンを終了させるために子をキャンセルします。
    coroutineContext.cancelChildren()
}
```

```
実行結果

foo
foo
BAR!
foo
foo
BAR!
```

想定通り動作していることがわかります。


## バッファリングされたチャネル

これまで示したチャネルにはバッファがありませんでした。バッファなしのチャネルは、送信側と受信側が出会ったとき (つまり、ランデブー) に要素を転送します。送信が最初に呼び出された場合は、受信が呼び出されるまで一時停止され、受信が最初に呼び出された場合は、送信が呼び出されるまで一時停止されます。

Channel() ファクトリ関数と produce ビルダーは、バッファサイズを指定する引数を任意で受け取ります。バッファを使用すると、送信側は一時停止する前に複数の要素を送信できます。これは、バッファがいっぱいになるとブロックする、指定された容量を持つ BlockingQueue に似ています。

次のコードの動作を見てみましょう。

```kotlin
fun main() = runBlocking<Unit> {
    // バッファサイズ 4 のチャネルを生成
    val channel = Channel<Int>(4)
    // 送信コルーチンを発足
    val sender = launch {
        repeat(10) {
            println("Sending $it")
            // バッファーがいっぱいになったら一時停止します。
            channel.send(it)
        }
    }
    // don't receive anything... just wait....
    delay(1000)
    sender.cancel() // cancel sender coroutine
}
```

「 Sending 3 」 までは、送信済みですが、 「 Sending 4 」 は、送信直前で一時停止しています。

```
実行結果

Sending 0
Sending 1
Sending 2
Sending 3
Sending 4
```


## チャネルの公平性

チャネルへの送信および受信操作は、複数のコルーチンからの呼び出し順序に関して公平です。これらは先入先出の順序で処理されます。 (ただし、場合によっては公平性が失われます。詳しくはこのセクションの末尾を参照してください。) (あまり公平だとは思わないほうが良いかも ... )

一旦、「チャネルは公平である」という前提で話を進めます。例えば、最初に受信を呼び出すコルーチンが要素を取得します。次の例では、 2 つのコルーチン 「 ping 」 と 「 pong 」 が共有の 「 table 」 チャネルから 「 ball 」 オブジェクトを受信して​​います。

```kotlin
data class Ball(var hits: Int)

fun main() = runBlocking {
    val table = Channel<Ball>()
    launch { player("ping", table) }
    launch { player("pong", table) }
    // 最初の送信
    table.send(Ball(0))
    delay(1000)
    // 終了
    coroutineContext.cancelChildren()
}

suspend fun player(name: String, table: Channel<Ball>) {
    // ループ内でボールを受信します。
    for (ball in table) {
        ball.hits++
        println("$name $ball")
        delay(300)
        table.send(ball)
    }
}
```

「 ping 」 コルーチンが最初に開始されるため、ボールを受け取るのはこれが最初です。 「 ping 」 コルーチンはボールをテーブルに送り返した後すぐに再びボールの受け取りを開始しますが、  「 pong 」 は既にすでにボールを待っていたため、ボールは 「 pong 」 コルーチンによって受け取られます。

```
実行結果

ping Ball(hits=1)
pong Ball(hits=2)
ping Ball(hits=3)
pong Ball(hits=4)
```

場合によっては、使用されているエグゼキュータの性質により、チャネルが不公平に見える実行を生成する可能性があることに注意してください。詳細については、 [この問題](https://github.com/Kotlin/kotlinx.coroutines/issues/111) を参照してください。開発チームはこの動作を不具合とはみなさず、 「対処なし」と結論づけて、この問題をクローズしています。


## ティッカー（限られた狭い領域）チャネル

ティッカー ( ticker ) には、新幹線の電光掲示板のように限られた領域に文字を流して表示するもののことを示します。また、ティックには、時計などがカチカチと音を立てるという意味があります。転じて、限られた狭い領域に繰り返し何かが起こるという意味があります。

ティッカーチャネルは、このチャネルからの最後の消費から指定された遅延が経過するたびに `Unit` を生成する特別なランデブーチャネルです。スタンドアロンでは役に立たないように見えるかもしれませんが、ウィンドウ処理やその他の時間依存の処理を行う複雑な時間ベースの produce パイプラインや演算子を作成するための便利な構成要素です。ティッカーチャネルは、 [select](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html) 内で使用され 「 on tick 」 アクションを実行できます。

このようなチャネルを作成するには、ファクトリメソッド [ticker](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html) を使用します。これ以上の要素が必要ないことを示すには、 ReceiveChannel.cancel メソッドを使用します。

では、実際にどのように動作するかを見てみましょう。

```kotlin
fun main() = runBlocking<Unit> {
    // ティッカーチャネルを生成する。
    val tickerChannel = ticker(delayMillis = 200, initialDelayMillis = 0)
    var nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }
    // 初期遅延はなし。
    println("Initial element is available immediately: $nextElement")

    // 後続の要素はすべて 200 ms の遅延を持つ
    nextElement = withTimeoutOrNull(100) { tickerChannel.receive() }
    println("Next element is not ready in 100 ms: $nextElement")

    // 前回の取得から 200 ms が経過しているので、 Unit を取得可能。
    nextElement = withTimeoutOrNull(120) { tickerChannel.receive() }
    println("Next element is ready in 200 ms: $nextElement")

    // 大きな一時停止を再現する。
    println("Consumer pauses for 300ms")
    delay(300)
    // 前回の取得から 200 ms が経過しているので、 Unit を取得可能。
    nextElement = withTimeoutOrNull(1) { tickerChannel.receive() }
    println("Next element is available immediately after large consumer delay: $nextElement")
    // 前回の 300 ms の一時停止も今回の一時停止に含まれるため、今回は 100 ms の一時停止で Unit を取得可能。
    nextElement = withTimeoutOrNull(120) { tickerChannel.receive() }
    println("Next element is ready in 100ms after consumer pause in 300ms: $nextElement")

    // これ以上要素が必要ないことを示します。
    tickerChannel.cancel()
}
```

```
実行結果

Initial element is available immediately: kotlin.Unit
Next element is not ready in 100 ms: null
Next element is ready in 200 ms: kotlin.Unit
Consumer pauses for 300ms
Next element is available immediately after large consumer delay: kotlin.Unit
Next element is ready in 100ms after consumer pause in 300ms: kotlin.Unit
```

ティッカーは、消費者の一時停止の可能性を認識しており、デフォルトでは、一時停止が発生した場合に次に生成される要素の遅延を調整し、生成される要素の固定レートを維持しようとします。

オプションで、要素間の固定遅延を維持するために、 [TickerMode.FIXED_DELAY](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-ticker-mode/-f-i-x-e-d_-d-e-l-a-y/) に等しい mode パラメータを指定できます。


## チャネルをホットフローに変換する

### receiveAsFlow

指定された受信チャネルをホットフローに変換します。

このフローは複数のコレクターから収集することが可能です。

1 つの要素は 1 つのコレクターでのみ受信可能であり、要素は複数のコレクターによって、分散して受信されます。


### consumeAsFlow

指定された受信チャネルをホットフローに変換します。

このフローは一つのコレクターからのみ収集することが可能です。二つ目のコレクターを接続しようとすると IllegalStateException がスローされます。



