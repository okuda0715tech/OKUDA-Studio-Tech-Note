- [コルーチンの例外の扱い方](#コルーチンの例外の扱い方)
  - [例外の伝播](#例外の伝播)
    - [【注意】](#注意)
    - [Java の UncaughtExceptionHandler](#java-の-uncaughtexceptionhandler)
      - [【参考】個別のスレッドに対して UncaughtExceptionHandler を設定する例](#参考個別のスレッドに対して-uncaughtexceptionhandler-を設定する例)
  - [CoroutineExceptionHandler](#coroutineexceptionhandler)
    - [async ビルダーで生成されたコルーチンの場合](#async-ビルダーで生成されたコルーチンの場合)
    - [スーパービジョンスコープで実行されているコルーチンの場合](#スーパービジョンスコープで実行されているコルーチンの場合)
  - [キャンセルと例外](#キャンセルと例外)
    - [まとめ](#まとめ)
  - [例外の集約](#例外の集約)
    - [【参考】 CancellationException による例外のラップ](#参考-cancellationexception-による例外のラップ)
  - [監督・監視（ Supervision ）](#監督監視-supervision-)
    - [監視（ Supervision ）ジョブ](#監視-supervision-ジョブ)
    - [監督（ Supervision ）スコープ](#監督-supervision-スコープ)
    - [監視されたコルーチンの例外](#監視されたコルーチンの例外)
  - [引用元資料](#引用元資料)


# コルーチンの例外の扱い方

このセクションでは、例外処理と例外のキャンセルについて説明します。キャンセルされたコルーチンは一時停止ポイント (キャンセルチェックポイント) で CancellationException をスローすることは既にわかっています。ここでは、キャンセル中に例外がスローされた場合、または、同じコルーチンの複数の子が例外をスローした場合に、何が起こるかを見ていきます。


## 例外の伝播

コルーチンビルダーには、 **例外を自動的に伝播する ( launch )** か、 **ユーザーが手動で例外を拾いに行くと伝搬する ( async と produce )** という二つの種類があります。これらのビルダーを使用してルートコルーチン (別のコルーチンの子ではないコルーチン) を作成する場合、前者のビルダー ( launch ) は、例外をキャッチされていない例外として扱います ( Java の Thread.UncaughtExceptionHandler に似ています。詳細は [次のセクション](#java-の-uncaughtexceptionhandler) を参照) 。一方、後者は、たとえば await または receive を介して、ユーザーが最終的な例外を処理する必要があります。 ( produce と received については、 [チャネルセクション](https://kotlinlang.org/docs/channels.html) で説明しています) 。

これは、 GlobalScope を使用してルートコルーチンを作成する簡単な例で実証できます。

GlobalScope は、大きな副作用が発生する可能性があるデリケートな API です。アプリケーション全体のスコープでルートコルーチンを作成することは、一般的には適切な使用方法ではないため、 `@OptIn(DelicateCoroutinesApi::class)` を使用して GlobalScope の使用を明示的にオプトインする必要があります。

```kotlin
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {

    // launch で生成したグローバルスコープのルートコルーチン
    val job = GlobalScope.launch {
        println("Throwing exception from launch")

        // Thread.defaultUncaughtExceptionHandler によって、
        // 例外はコンソールに出力されます。
        throw IndexOutOfBoundsException()
    }
    job.join()
    println("Joined failed job")

    // async で生成したグローバルスコープのルートコルーチン
    val deferred = GlobalScope.async {
        println("Throwing exception from async")

        // 例外は await を呼び出したところに伝搬されるため、ここでは何も出力されません。
        throw ArithmeticException()
    }
    try {
        deferred.await()
        println("Unreached")
    } catch (e: ArithmeticException) {
        println("Caught ArithmeticException")
    }
}
```

このコードの出力は次のようになります ( [デバッグあり](https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html#debugging-coroutines-and-threads) )。

```
実行結果
(注意：読みやすさのために、一行ごとに空白行を挿入しています。)

Throwing exception from launch

Exception in thread "DefaultDispatcher-worker-1 @coroutine#2" java.lang.IndexOutOfBoundsException

Joined failed job

Throwing exception from async

Caught ArithmeticException
```


### 【注意】

例外は伝搬するといっても、以下のように例外を処理することはできません。

```kotlin
scope.launch {
    try {
        launch {
            throw IOException
        }

        // 内側の launch 関数を呼び出すと、その中身の処理が
        // 終了するのを待つことなく、ここに書かれた処理が
        // 開始されます。つまり、 try ブロックを抜けます。

    } catch(e : IOException) {
        // ここでは、内側の launch ブロックで発生した
        // IOException をキャッチすることはできません。
    }
}
```

このコードは、一見すると、例外が外側の launch {} ブロックに伝搬し、そこで catch できるように見えるかもしれません。しかし、 launch ブロックは、呼び出されると、すぐに制御を返し、 launch ブロックの外側の次のステップの処理を開始します。つまり、外側の launch ブロックは、内側の launch ブロックの終了を待つことなく、 try ブロックを抜けてしまいます。

そのため、親コルーチンが子コルーチンを try ブロックで囲んで、例外を処理しようとする方法は間違っています。親が子コルーチンの例外をキャッチするには、 CoroutineExceptionHandler を使用します。



### Java の UncaughtExceptionHandler

通常、例外が発生する可能性のある処理では、 `try {} catch {}`
構文でキャッチして、処理フローを正常ルートに戻します。その一方で、 `UncaughtExceptionHandler` を使用すると、以下のように、グローバールなスコープで例外をキャッチすることも可能です。

```java
public class Main {
    public static void main(String[] args) {
        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                System.out.println("Unhandled exception caught: " + e);
            }
        });

        int[] numbers = {1, 2, 3};
        // ArrayIndexOutOfBoundsException が発生
        System.out.println(numbers[3]);
    }
}
```

UncaughtExceptionHandler は、スレッドに対して設定します。それを設定したスレッドで、例外が発生し、それをキャッチする処理が存在しない場合に、 UncaughtExceptionHandler がキャッチしてくれる。という例外処理の仕組みです。

なお、 `setDefaultUncaughtExceptionHandler` メソッドは、アプリケーション内のすべてのスレッドにえらーハンドラーを設定します。


#### 【参考】個別のスレッドに対して UncaughtExceptionHandler を設定する例

```java
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("スレッド " + t.getName() + " で例外が発生しました: " + e.getMessage());
        // 例外発生時の処理 (ログ出力、リトライなど)
    }
}

public class Main {
    public static void main(String[] args) {

        // スレッド1の作成と個別のハンドラーの設定
        Thread thread1 = new Thread(() -> {
            // 例外が発生する可能性のある処理
            int i = 1 / 0; // 意図的に例外を発生させる
        });
        thread1.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                System.out.println("スレッド1専用のエラーメッセージ: " + e.getMessage());
            }
        });

        thread1.start();
    }
}
```


## CoroutineExceptionHandler

**コルーチンがルートコルーチンの場合** 、キャッチされていない例外に対するデフォルトの動作 (コンソールに出力する動作) をカスタマイズできます。

まず、 CoroutineExceptionHandler ファクトリー関数に、例外が発生した場合の処理を記述します。つまり、通常、 catch ブロックに記述している内容を記述します。 (ファクトリー関数とは、インスタンスを生成する関数のことです。)

CoroutineExceptionHandler は、コルーチンコンテキスト要素 ( CoroutineContext.Element ) です。そのため、 launch の引数として渡します。

launch の引数に渡された CoroutineExceptionHandler は、このルートコルーチンと、すべての子コルーチンの例外ハンドラーとして機能します。 (これは Java の Thread.UncaughtExceptionHandler に似ています。)

**CoroutineExceptionHandler で例外から回復することはできません。** ハンドラーが呼び出されたときには、コルーチンは対応する例外で、既に終了しています。通常、ハンドラーは例外をログに記録し、何らかのエラーメッセージを表示し、アプリケーションを終了、または、再起動するために使用されます。

CoroutineExceptionHandler は、キャッチされていない例外、つまり、他の方法で処理されなかった例外に対してのみ呼び出されます。特に、すべての子コルーチン (別のジョブのコンテキストで作成されたコルーチン) は、例外の処理を親コルーチンに委任し、親コルーチンは、さらにその親に委任し、ルートまでこれが続きます。そのため、途中で例外が処理されている場合は、コンテキストにインストールされている CoroutineExceptionHandler が使用されることはありません。

```kotlin
// CoroutineExceptionHandler を定義
val exceptionHandler = CoroutineExceptionHandler { _, throwable ->
    Log.d("test", "Caught exception: ${throwable.localizedMessage}")
}

val scope = CoroutineScope(Job())
// 例外ハンドラを使ってコルーチンを起動
val job = scope.launch(exceptionHandler) {
    Log.d("test", "Running coroutine...")
    throw RuntimeException("Something went wrong!")
}

job.join()
Log.d("test", "Coroutine has finished.")
```

```
実行結果

Running coroutine...
Caught exception: Something went wrong!
Coroutine has finished.
```


### async ビルダーで生成されたコルーチンの場合

async ビルダーは常にすべての例外をキャッチし、結果の Deferred オブジェクトでそれらを表すため、 CoroutineExceptionHandler に伝搬されることはありません。


### スーパービジョンスコープで実行されているコルーチンの場合

監督 ( supervisor / supervision ) スコープで実行されているコルーチンは、~~例外を親に伝播しないため~~ (伝搬はするが、キャンセルはしないが正しいはず) 、このルールから除外されます。詳細はこのドキュメントの後半の [スーパービジョン](#監督監視-supervision-) のセクションを参照してください。

```kotlin
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -> 
        println("CoroutineExceptionHandler got $exception") 
    }
    // launch で生成したグローバルスコープのルートコルーチン
    val job = GlobalScope.launch(handler) {
        throw AssertionError()
    }
    // async で生成したグローバルスコープのルートコルーチン
    val deferred = GlobalScope.async(handler) {
        // await 呼び出しがないため、この例外は出力されません。
        // また、 async に渡される CoroutineExceptionHandler は機能しません。
        throw ArithmeticException()
    }
    joinAll(job, deferred)
}
```

```
実行結果

CoroutineExceptionHandler got java.lang.AssertionError
```


## キャンセルと例外

キャンセルは例外と密接に関係しています。コルーチンは内部的に **キャンセルに CancellationException を使用します。この例外はハンドラーには無視される** ため、 catch ブロックでのみキャッチ可能です。そのため、デバッグ用の情報源としてのみに使用されるべきです。 (私としては、必ずしもデバッグ用でなくても良いと思うが...。)

**コルーチンが Job.cancel を使用してキャンセルされると、自分自身のコルーチンは終了しますが、親はキャンセルされません。** これはキャンセルと例外の重要な違いです。

```kotlin
fun main() = runBlocking {
    val job = launch {
        val child = launch {
            try {
                // delay は suspend 関数なので即座にキャンセル可能
                delay(Long.MAX_VALUE)
            } catch (e: Exception) {
                println("Catch block has passed")
            } finally {
                println("Child is cancelled")
            }
        }
        // yield は、現在のコルーチンを一時停止し、他のコルーチンやタスクに実行を譲ります。
        yield()
        println("Cancelling child")
        child.cancel()
        // 子コルーチンが終了するのを待機します。
        child.join()
        yield()
        // このメッセージが表示されるということは親コルーチンはキャンセルされていないということになります。
        println("Parent is not cancelled")
    }
    job.join()
}
```

```
実行結果

Cancelling child
Catch block has passed
Child is cancelled
Parent is not cancelled
```

コルーチンが CancellationException 以外の例外に遭遇した場合、その例外で親の Job をキャンセル状態にします。この動作は、構造化された同時実行性を担保するためにオーバーライドできないようになっています。

CoroutineExceptionHandler は常に GlobalScope で作成されたコルーチンにインストールする必要があります。限定的なスコープで起動されるコルーチンに CoroutineExceptionHandler をインストールしても意味がありません。

子で発生した例外は、すべての子が終了した場合にのみ、親に伝搬します。これは次の例で示されています。

```kotlin
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -> 
        println("CoroutineExceptionHandler got $exception") 
    }
    val job = GlobalScope.launch(handler) {
        // 一つ目の子コルーチン
        launch {
            try {
                delay(Long.MAX_VALUE)
            } finally {
                // この Job がキャンセルされたときに、
                // finally ブロック内で suspend 関数を呼び出す場合は、
                // NonCancellable コンテキスト内で処理する必要がある。
                withContext(NonCancellable) {
                    println("Children are cancelled, but exception is not handled until all children terminate")
                    delay(100)
                    println("The first child finished its non cancellable block")
                }
            }
        }
        // 二つ目の子コルーチン
        launch {
            delay(10)
            println("Second child throws an exception")
            throw ArithmeticException()
        }
    }
    job.join()
}
```

```
実行結果
(注意：読みやすさのために、一行ごとに空白行を挿入しています。)

Second child throws an exception

Children are cancelled, but exception is not handled until all children terminate

The first child finished its non cancellable block

CoroutineExceptionHandler got java.lang.ArithmeticException
```

### まとめ

- Job.cancel で Job に紐づくコルーチンをキャンセルした場合、 CancellationException がスローされる。
- CancellationException は親コルーチンに伝搬されないため、その親コルーチンはキャンセルされない。
- CancellationException は、 catch してはいけません。 ( catch してもコルーチンは終了しないため。)
- 子コルーチンで CancellationException 以外の例外がスローされた場合、その例外は親にスローされ、親コルーチンは、その例外を起因として Job の状態がキャンセル状態になる
- CoroutineExceptionHandler は常に GlobalScope で作成されたコルーチンにインストールする必要があります。
  - なぜなら、子で例外が発生すると (限定的なスコープの) 親はキャンセルされる。
  - キャンセルされると、 CancellationException が発生し、この例外は親に伝搬されないため。
- 子で発生した例外は、すべての子が終了した場合にのみ、親に伝搬する。
- あるコルーチンで例外が発生すると、その兄弟コルーチンはキャンセルされます。 (次のセクションを参照)


## 例外の集約

コルーチンの複数の子が例外で失敗した場合、一般的なルールとしては 最初の例外が優先され、それが処理されます。最初の例外の後に発生するすべての追加の例外は、抑制された例外として最初の例外に添付されます。

```kotlin
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception ->
        println("CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}")
    }
    val job = GlobalScope.launch(handler) {
        launch {
            try {
                // 他の兄弟コルーチンが IOException で失敗するとキャンセルされます。
                delay(Long.MAX_VALUE)
            } finally {
                // 二番目の例外
                throw ArithmeticException()
            }
        }
        launch {
            delay(100)
            // 最初の例外
            throw IOException()
        }
        delay(Long.MAX_VALUE)
    }
    job.join()  
}
```

```
実行結果

CoroutineExceptionHandler got java.io.IOException with suppressed [java.lang.ArithmeticException]
```

このメカニズムは現在、 Java バージョン 1.7 以降でのみ機能することに注意してください。 JS およびネイティブの制限は一時的なもので、将来解除される予定です。


### 【参考】 CancellationException による例外のラップ

実際の例外が CancellationException でラップされている場所がある点に注意してください。

```kotlin
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception ->
        // ここでは IOException が CancellationException でラップされておらず、 IOException が渡ってきます。
        println("CoroutineExceptionHandler got $exception")
    }
    val job = GlobalScope.launch(handler) {
        // 配下の全てのコルーチンはキャンセルされます。
        val innerJob = launch {
            launch {
                launch {
                    // 最初の例外の発生源
                    throw IOException()
                }
            }
        }
        try {
            innerJob.join()
        } catch (e: CancellationException) {
            // ここでは IOException が CancellationException でラップされています。

            println("Rethrowing CancellationException with original cause")
            // キャンセル例外が再スローされるが、元の IOException がハンドラに渡される
            throw e
        }
    }
    job.join()
}
```

注意 : これは、実際の例外が CancellationException でラップされていることを証明するサンプルです。実際には、 CancellationException を catch することは避けるべきパターンです。詳細は [CancellationException をキャッチしてしまっている場合](./3.キャンセルとタイムアウト.md/#2-cancellationexception-をキャッチしてしまっている場合) を参照してください。

```
実行結果

Rethrowing CancellationException with original cause
CoroutineExceptionHandler got java.io.IOException
```



## 監督・監視（ Supervision ）

前に学習したように、キャンセルはコルーチンの階層全体に伝播する双方向の関係です。 Supervision の仕組みを使用すると、親はキャンセルせず、子だけをキャンセルする一方向のキャンセルを実装することが可能です。

一方向のキャンセルが必要な場合を見てみましょう。

UI コンポーネントのライフサイクルに連動するコルーチンスコープを定義した場合、そのスコープから起動されたコルーチンのうち、どれか一つでも失敗した場合に、スコープ自体をキャンセルしたり、他の兄弟コルーチンをキャンセルする必要があるでしょうか？通常は、そこまでする必要はないでしょう。失敗したコルーチンのみを再実行すれば済む問題です。 Android の viewModelScope や lifecycleScope は、まさにこのケースです。 viewModelScope や lifecycleScope は、 SupervisorJob を使用して構築されています。また、 ViewModel や Activity が破棄された場合には、該当のコルーチンスコープ、および、そのスコープから起動されたコルーチンは、キャンセルする必要がある場合が多く、一方向のキャンセルが適しています。

もう 1 つの例は、複数の子ジョブを生成し、それらの実行を監視し、失敗を追跡して失敗したジョブのみを再開する必要があるサーバープロセスです。


### 監視（ Supervision ）ジョブ

これらの目的には [SupervisorJob](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html) を使用できます。これは通常の [Job](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html) に似ていますが、 **キャンセルが下方向にのみ伝播する** という点が異なります。これは、次の例を使用して簡単に実証できます。 (例の中の with は、 [スコープ関数](../../関数/スコープ関数/スコープ関数.md/#with) です。)

```kotlin
fun main() = runBlocking {
    val supervisor = SupervisorJob()
    // with はスコープ関数です。
    with(CoroutineScope(coroutineContext + supervisor)) {
        // 一つ目の子コルーチンを開始します。
        // 簡略化のため、この例では例外を無視します。
        val firstChild = launch(CoroutineExceptionHandler { _, _ -> /* 例外を無視 */ }) {
            println("The first child is failing")
            throw AssertionError("The first child is cancelled")
        }
        // 二つ目の子コルーチンを開始します。
        val secondChild = launch {
            firstChild.join()
            // 一つ目の子コルーチンのキャンセルは、二つ目の子コルーチンには伝搬されません。
            println("The first child is cancelled: ${firstChild.isCancelled}, but the second one is still active")
            try {
                delay(Long.MAX_VALUE)
            } finally {
                // しかし、監視ジョブのキャンセルは伝搬されます。
                println("The second child is cancelled because the supervisor was cancelled")
            }
        }
        // 一つ目の子コルーチンが失敗 or 正常終了するまで待ちます。
        firstChild.join()
        println("Cancelling the supervisor")
        supervisor.cancel()
        secondChild.join()
    }
}
```

```
実行結果

The first child is failing

The first child is cancelled: true, but the second one is still active

Cancelling the supervisor

The second child is cancelled because the supervisor was cancelled
```


### 監督（ Supervision ）スコープ

coroutineScope の代わりに、スコープ化された同時実行に supervisorScope を使用できます。これは、キャンセルを一方向にのみ伝播し、自分自身が失敗した場合にのみ、そのすべての子をキャンセルします。また、 coroutineScope と同様に、自分自身を終了する場合は、その前に、すべての子が終了するのを待機します。

```kotlin
fun main() = runBlocking {
    try {
        supervisorScope {
            val child = launch {
                try {
                    println("The child is sleeping")
                    delay(Long.MAX_VALUE)
                } finally {
                    println("The child is cancelled")
                }
            }
            // yield は、現在のコルーチンを一時停止し、他のコルーチンやタスクに実行を譲ります。
            yield()
            println("Throwing an exception from the scope")
            throw AssertionError()
        }
    } catch(e: AssertionError) {
        println("Caught an assertion error")
    }
}
```

例外発生時に、子コルーチンが完了するのを待機するため、子の final ブロックが実行されてから、 supervisorScope の catch ブロックが実行されます。

```
実行結果

The child is sleeping
Throwing an exception from the scope
The child is cancelled
Caught an assertion error
```


### 監視されたコルーチンの例外

通常のジョブとスーパーバイザジョブのもう一つの重要な違いは、例外処理です。子ジョブの失敗が親ジョブに伝播しないため、すべての子ジョブは、その例外を自分自身で処理する必要があります。つまり、スーパーバイザスコープ内で直接起動されたコルーチンは、ルートコルーチンと同じように、 CoroutineExceptionHandler を使用するか、 try / catch ブロックで例外を処理する必要があります。例外が CancellationException の場合は何もしなくて大丈夫です。コルーチンがキャンセルされると、コルーチンの仕組みで、自動的にコルーチンが終了します。

ルートコルーチンがキャンセルされたらどうなる？ CancellationException は catch してはいけないはずだが、 catch しないと異常終了してしまうのでは？

以前のセクションで少し触れましたが、通常、 CoroutineExceptionHandler は、グローバルスコープのルートコルーチンにインストールする必要がありますが、 supervisor の場合は例外となっています。

```kotlin
fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -> 
        println("CoroutineExceptionHandler got $exception") 
    }
    supervisorScope {
        val child = launch(handler) {
            println("The child throws an exception")
            throw AssertionError()
        }
        println("The scope is completing")
    }
    println("The scope is completed")
}
```

```
実行結果

The scope is completing
The child throws an exception
CoroutineExceptionHandler got java.lang.AssertionError
The scope is completed
```


## 引用元資料

- [Coroutine exceptions handling](https://kotlinlang.org/docs/exception-handling.html)


