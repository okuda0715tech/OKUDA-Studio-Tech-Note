- [コルーチンのキャンセル](#コルーチンのキャンセル)
  - [キャンセルの呼び出し](#キャンセルの呼び出し)
    - [スコープをキャンセルすると、その子もキャンセルされる](#スコープをキャンセルするとその子もキャンセルされる)
    - [キャンセルされた子は他の兄弟には影響しない](#キャンセルされた子は他の兄弟には影響しない)
      - [viewModelScope と lifecycleScope](#viewmodelscope-と-lifecyclescope)
  - [コルーチンの作業が停止しないのはなぜですか？](#コルーチンの作業が停止しないのはなぜですか)
  - [コルーチン作業をキャンセル可能にする](#コルーチン作業をキャンセル可能にする)
    - [kotlinx.coroutines の suspend 関数を使用している場合](#kotlinxcoroutines-の-suspend-関数を使用している場合)
    - [kotlinx.coroutines の suspend 関数を使用していない場合](#kotlinxcoroutines-の-suspend-関数を使用していない場合)
  - [ジョブのアクティブ状態をチェックする](#ジョブのアクティブ状態をチェックする)
  - [yield() を使用して他の作業を実行させる](#yield-を使用して他の作業を実行させる)
    - [例](#例)
  - [コルーチンの終了の待機（Job.join / Deferred.await）とキャンセルを組み合わせる](#コルーチンの終了の待機jobjoin--deferredawaitとキャンセルを組み合わせる)
    - [Job.join とキャンセル](#jobjoin-とキャンセル)
    - [Deferred.await とキャンセル](#deferredawait-とキャンセル)
  - [キャンセルの副作用の処理](#キャンセルの副作用の処理)
    - [!isActive を確認する](#isactive-を確認する)
    - [try catch finally](#try-catch-finally)
      - [【注意点】キャンセル状態のコルーチンは、デフォルトでは一時停止できません](#注意点キャンセル状態のコルーチンはデフォルトでは一時停止できません)
  - [コールバックをコルーチンに変換する](#コールバックをコルーチンに変換する)
  - [まとめ](#まとめ)
  - [引用元資料](#引用元資料)


# コルーチンのキャンセル

開発では、人生と同様、メモリとエネルギーを無駄にするため、必要以上の作業を避けることが重要であることはわかっています。この原則はコルーチンにも当てはまります。コルーチンの寿命を制御し、不要になったらキャンセルする必要があります。これが構造化された同時実行性です。コルーチンのキャンセルについて詳しくは、以下をお読みください。

これに関するビデオをご覧になりたい場合は、KotlinConf’19 で Manuel Vivo と私が行った [コルーチンのキャンセルと例外に関する講演](https://www.youtube.com/watch?v=w0kfnydnFWI) をご覧ください。


## キャンセルの呼び出し

### スコープをキャンセルすると、その子もキャンセルされる

複数のコルーチンを起動する場合、それらを追跡したり、個別にキャンセルしたりするのは面倒です。代わりに、コルーチンが起動されるスコープ全体をキャンセルすることで、作成されたすべての子コルーチンをキャンセルできます。

```kotlin
// アプリのこのレイヤに定義されたスコープがあるとします。
val job1 = scope.launch { … }
val job2 = scope.launch { … }
scope.cancel()
```


### キャンセルされた子は他の兄弟には影響しない

ユーザー入力への反応として、 1 つのコルーチンだけをキャンセルする必要がある場合があります。job1.cancel を呼び出すと、その特定のコルーチンだけがキャンセルされ、他のすべての兄弟は影響を受けません。

```kotlin
val job1 = scope.launch { … }
val job2 = scope.launch { … }
// 最初のコルーチンだけがキャンセルされ、もう一方のコルーチンは影響を受けません。
job1.cancel()
```

コルーチンは、特別な例外 CancellationException をスローしてキャンセルを処理します。キャンセルの理由について、さらに詳しい情報を提供したい場合は、 `job.cancel()` 関数を呼び出すときに CancellationException のインスタンスを提供できます。

```kotlin
fun cancel(cause: CancellationException? = null)
```

独自の CancellationException インスタンスを提供しない場合は、デフォルトの CancellationException が作成されます。

```kotlin
public override fun cancel(cause: CancellationException?) {
    cancelInternal(cause ?: defaultCancellationException())
}
```

CancellationException がスローされるため、このメカニズムを使用してコルーチンのキャンセルを処理できます。これを行う方法については、以下の [キャンセルの副作用の処理](#キャンセルの副作用の処理) セクションで詳しく説明します。

内部的には、子ジョブが例外を介して親にキャンセルを通知します。親はキャンセルの原因を使用して、例外を処理する必要があるかどうかを判断します。子が CancellationException によってキャンセルされた場合、親は他のアクションを実行する必要はありません。

**⚠️スコープをキャンセルすると、キャンセルされたスコープで新しいコルーチンを起動できなくなります。**


#### viewModelScope と lifecycleScope

androidx KTX ライブラリを使用している場合、ほとんどの場合、独自のスコープを作成しないため、スコープをキャンセルする必要はありません。 viewModelScope を使用して ViewModel のスコープ内で作業している場合、またはライフサイクル スコープに関連付けられたコルーチンを起動する場合は、lifecycleScope を使用します。viewModelScope と lifecycleScope はどちらも、適切なタイミングでキャンセルされる CoroutineScope オブジェクトです。たとえば、ViewModel がクリアされると、そのスコープ内で起動されたコルーチンがキャンセルされます。


## コルーチンの作業が停止しないのはなぜですか？

単に cancel を呼び出しても、コルーチンの作業が停止するわけではありません。複数のファイルからの読み取りなど、比較的負荷の高い計算を実行している場合、コードの実行を自動的に停止するものはありません。

もっと単純な例で何が起こるか見てみましょう。コルーチンを使用して 1 秒間に 2 回 「 Hello 」 を表示する必要があるとします。コルーチンを 1 秒間実行してからキャンセルします。実装の 1 つの例は、次のようになります。

```kotlin
fun main(args: Array<String>) = runBlocking<Unit> {
    val startTime = System.currentTimeMillis()
    val job = launch (Dispatchers.Default) {
        var nextPrintTime = startTime
        // この i は、 if 文の条件を満たした場合のみインクリメントしています。
        var i = 0
        while (i < 5) {
            // print a message twice a second
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("Hello ${i++}")
                nextPrintTime += 500L
            }
        }
    }
    delay(1000L)
    println("Cancel!")
    job.cancel()
    println("Done!")
}
```

では、ステップごとに何が起こるか見てみましょう。launch を呼び出すと、アクティブ状態で新しいコルーチンが作成されます。コルーチンを 1000 ミリ秒実行します。これで、次のように出力されます。

```
開始から 1000 ミリ秒経過後の画面表示

Hello 0
Hello 1
Hello 2
```

job.cancel が呼び出されると、コルーチンはキャンセル状態に移行します。しかし、その後、Hello 3 と Hello 4 がターミナルに出力されます。作業が完了した後でのみ、コルーチンはキャンセル状態に移行します。

```
最終的な実行結果

Hello 0
Hello 1
Hello 2
Cancel!
Done!
Hello 3
Hello 4
```

コルーチン作業は、キャンセルが呼び出されても停止するわけではありません。これは、 **コルーチンがアクティブかどうかを定期的に確認する必要があることを意味します。**


## コルーチン作業をキャンセル可能にする

### kotlinx.coroutines の suspend 関数を使用している場合

kotlinx.coroutines のすべての suspend 関数はキャンセル可能です ( withContext、delay など) 。そのため、これらのいずれかを使用している場合は、開発者自身が、キャンセルをチェックして実行を停止したり、CancellationException をスローしたりする必要はありません。これらは、内部的にキャンセル状態を監視し、自動的に CancellationException をスローするようになっているためです。よって、処理がキャンセルされた場合は、即座に処理が中断されます。


### kotlinx.coroutines の suspend 関数を使用していない場合

kotlinx.coroutines の suspend 関数を使用していない場合は、開発者自身が、キャンセルをチェックして実行を停止したり、CancellationException をスローしたりする必要があります。

そのため、定期的に、または、長時間実行される作業を開始する前に、キャンセルを確認する必要があります。たとえば、ディスクから複数のファイルを読み取る場合、各ファイルの読み取りを開始する前に、コルーチンがキャンセルされたかどうかを確認します。このようにして、不要になったときに CPU を集中的に使用する作業を回避します。

```kotlin
val job = launch {
    for(file in files) {
        // TODO キャンセルされたかどうかチェックする。

        readFile(file)
    }
}
```

キャンセルされたかどうかをチェックするには、次の 2 つのオプションがあります:

- [job.isActive または ensureActive() をチェックする](#ジョブのアクティブ状態をチェックする)
  - [ジョブのライフサイクル](./【ブログ】1.まずはじめに.md/#ジョブのライフサイクル) でもわかるように、ジョブがキャンセルされると `isActive = false` になります。
- [yield() を使用して他の作業を行う](#yield-を使用して他の作業を実行させる)


## ジョブのアクティブ状態をチェックする

1 つの方法としては、 `while( i < 5 )` の部分で、コルーチンの状態をチェックする方法があります。

```kotlin
// launch ブロック内にいるため、 job.isActive にアクセスすることが可能です。
while (i < 5 && isActive)
```

これは、コルーチンがアクティブな間のみ作業を実行する必要があることを意味します。 isActive を使用すれば、 「ジョブがキャンセルされた場合にのみ実行したい処理」 を実行することもできます。例えば、ジョブがキャンセルされた場合に、ログに記録するなどの他のアクションを実行することが可能です。その場合は、コルーチンスコープ内で、 `if(!isActive)` のチェックを追加して、そこでアクションを実行するようにします。

コルーチンライブラリには、別の便利なメソッドである ensureActive() が用意されています。その実装は次のとおりです。

```kotlin
fun Job.ensureActive(): Unit {
    if (!isActive) {
        throw getCancellationException()
    }
}
```

**このメソッドは、ジョブがアクティブでない場合は即座に例外をスローする** ため、これを while ループで最初に実行することができます。

```kotlin
while (i < 5) {
    ensureActive()
    // ...
}
```

ensureActive を使用すると、isActive に必要な if ステートメントを自分で実装する必要がなくなり、記述する必要のある定型コードの量が減りますが、ログ記録などの他のアクションを実行する柔軟性は失われます。


## yield() を使用して他の作業を実行させる

実行している作業が次のような場合は、 yield() を使用します。

1. CPU を大量に消費し、
2. スレッドプールを使い果たす可能性があり、
3. プールにスレッドを追加せずに、スレッドが他の作業を実行できるようにする場合

yield によって実行される最初の操作はキャンセル状態の確認であり、 **job.cancel() が呼ばれた後、 yield() が呼ばれると CancellationException をスローしてコルーチンを終了します。** yield は、前述の ensureActive() のように、定期的なチェックで最初に呼び出される関数にすることができます。


### 例

Kotlinのコルーチンがキャンセルされた際に、yield 関数を使ってキャンセル状態をチェックする例を以下に示します。

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        repeat(1000) { i ->
            // yield()を使用して、キャンセル状態を確認する
            yield()
            println("Processing item $i")
            delay(500)  // シミュレーションのための遅延
        }
    }

    delay(2000)  // 2秒後にキャンセル
    println("Cancelling job...")
    job.cancelAndJoin()
    println("Job cancelled")
}
```

- yield() 関数は、コルーチンの協調的な中断ポイントです。コルーチンがキャンセルされた場合、この関数が呼ばれると CancellationException がスローされ、コルーチンの実行が停止します。
- この例では、コルーチン内の repeat ループで各反復中に yield() を呼び出しています。これにより、キャンセルが発生したときにすぐに反応できます。


## コルーチンの終了の待機（Job.join / Deferred.await）とキャンセルを組み合わせる

コルーチンの終了を待機する方法は 2 つあります。

1. launch から返されたジョブは join を呼び出します。
2. async から返された Deferred (ジョブの一種) は await を呼び出します。


### Job.join とキャンセル

Job.join は、作業が完了するまでコルーチンを一時停止します。 job.cancel と組み合わせると、期待どおりに動作します:

- job.cancel を呼び出してから job.join を呼び出すと、コルーチンはジョブのキャンセルが完了するまで一時停止します。
- job.join の後に job.cancel を呼び出しても、ジョブはすでに完了しているため効果はありません。


### Deferred.await とキャンセル

コルーチンの処理結果を受け取りたい場合は、 Deferred を使用します。この結果は、コルーチンが完了したときに Deferred.await() から返されます。 Deferred は Job の一種であり、キャンセルすることもできます。

キャンセルされた Deferred に対して await を呼び出すと、 JobCancellationException がスローされます。 await 関数は、 deferred (ジョブ) のキャンセル状態を監視しているため、 await 関数が呼び出されて時点で、既に deferred.cancel() が呼び出されている場合は、即座に JobCancellationException をスローします。

```kotlin
val deferred = scope.async {
    // コルーチン内の処理
}

// コルーチンをキャンセル
deferred.cancel()

// ここで即座に CancellationException がスローされる
try {
    deferred.await()
} catch (e: CancellationException) {
    // JobCancellationException
    println("deferred はキャンセルされており、await は即座に例外をスローしました")
}
```

例外が発生する理由は次のとおりです。 await の役割は、結果が計算されるまでコルーチンを一時停止することです。コルーチンがキャンセルされると、結果を返すことができません。したがって、 cancel の後に await を呼び出すと、 JobCancellationException: Job was cancelled が発生します。

一方、 deferred.await の後に deferred.cancel を呼び出した場合は、コルーチンがすでに完了しているため、何も起こりません。


## キャンセルの副作用の処理

コルーチンがキャンセルされたときに、何らかの処理を行いたい場合があります。例えば、以下のような場合があります。

- 使用している可能性のあるリソースを閉じる
- キャンセルをログに記録する
- 実行したいその他のクリーンアップ コードなどを実行する

これを行うには、いくつかの方法があります。


### !isActive を確認する

isActive を定期的に確認している場合は、while ループから抜けたら、リソースをクリーンアップできます。先ほどのコードは、次のように修正できます。

```kotlin
while (i < 5 && isActive) {
    // 1 秒間に 2 回メッセージを表示します。
    if (…) {
        println(“Hello ${i++}”)
        nextPrintTime += 500L
    }
}
// while ループの処理が 5 回分終わったか、
// あるいは、ジョブがキャンセルされたため、
// クリーンアップできます。
println(“Clean up!”)
```

これで、コルーチンがアクティブでなくなると、 while が中断され、クリーンアップを実行できます。


### try catch finally

コルーチンがキャンセルされると CancellationException がスローされるため、一時停止する処理を try/catch でラップし、finally ブロックでクリーンアップ作業を実装できます。

```kotlin
val job = launch {
    try {
        // 一時停止する処理
        work()
    } catch (e: CancellationException){
        println(“Work cancelled!”)
    } finally {
        println(“Clean up!”)
    }
}
delay(1000L)
println(“Cancel!”)
job.cancel()
println(“Done!”)
```


#### 【注意点】キャンセル状態のコルーチンは、デフォルトでは一時停止できません

注意 : キャンセル状態のコルーチンは、デフォルトでは、一時停止できません。コルーチンがキャンセル状態になると、それ以上一時停止できなくなるため、クリーンアップ処理に susupend 関数が含まれている場合、 finally ブロックの処理が正常に完了できなくなります。

コルーチンがキャンセルされたときに suspend 関数を呼び出せるようにするには、実行する必要があるクリーンアップ作業を **NonCancellable CoroutineContext** 内で実行する必要があります。これにより、コードが一時停止可能になり、クリーンアップ作業が完了するまでコルーチンがキャンセル状態に保たれます。

```kotlin
val job = launch {
    try {
        work()
    } catch (e: CancellationException){
        println(“Work cancelled!”)
    } finally {
        withContext(NonCancellable){
            // 何らかの suspend 関数の処理
            delay(1000L)

            println(“Cleanup done!”)
        }
    }
}
delay(1000L)
println(“Cancel!”)
job.cancel()
println(“Done!”)
```

```
実行結果

Hello 0
Hello 1
Hello 2
Cancel!
Done!
Cleanup done!
```


## コールバックをコルーチンに変換する

[suspendCoroutine](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html) メソッドを使用すると、コールバックをコルーチンに変換することが可能です。しかし、この関数を使用したい場合は、その代わりに [suspendCancellableCoroutine](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html) を使用することをお勧めします。キャンセル時に実行される作業は、 [continuation.invokeOnCancellation](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellable-continuation/invoke-on-cancellation.html) を使用して実装できます。

```kotlin
suspend fun work() {
   return suspendCancellableCoroutine { continuation ->
       continuation.invokeOnCancellation { 
          // do cleanup
       }
   // rest of the implementation
}
```


## まとめ

構造化された同時実行処理の利点を実現し、不要な作業を行わないようにするには、コードをキャンセル可能にする必要があります。

まずは、 Jetpack で定義されている CoroutineScopes ( viewModelScope または lifecycleScope) を使用することを検討してください。それらを使用せず、独自の CoroutineScope を作成する場合は、開発者自身が、ジョブのキャンセル状態をチェックし、例外をスローするようにしてください。

コルーチンコードのキャンセルは協調的である必要があるため、キャンセルが遅延されないことを意識し、必要以上の作業を行わないようにしてください。

キャンセルすべきでない作業のパターンの詳細については、 [この投稿](./【ブログ】4.キャンセルすべきではないワークのコルーチン実装パターン.md) ( [元資料はこちら](https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad) ) をご覧ください。


## 引用元資料

[Cancellation in coroutines](https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629)




