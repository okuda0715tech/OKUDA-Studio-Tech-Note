- [suspend 関数の作成](#suspend-関数の作成)
  - [デフォルトの順次実行](#デフォルトの順次実行)
  - [async を使用した同時実行](#async-を使用した同時実行)
  - [async は遅延実行も可能](#async-は遅延実行も可能)
  - [xxxAsync スタイルの関数（グローバルスコープのコルーチン）](#xxxasync-スタイルの関数グローバルスコープのコルーチン)
  - [async を使用した構造化された同時実行](#async-を使用した構造化された同時実行)


# suspend 関数の作成

このドキュメントでは、サスペンド関数の構成に関するさまざまなアプローチについて説明します。


## デフォルトの順次実行

コルーチン内の処理は、デフォルトでは順次実行されます。

例えば、以下の二つの suspend 関数があったとします。

```kotlin
suspend fun doSomethingUsefulOne(): Int {
    // 実際には、単なる一時停止ではなく、何か意味のある処理をしているとします。
    delay(1000L)

    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    // 実際には、単なる一時停止ではなく、何か意味のある処理をしているとします。
    delay(1000L)

    return 29
}
```

これらを順番に呼び出す必要がある場合、つまり最初にdoSomethingUsefulOne 、次に doSomethingUsefulTwo を呼び出す場合、通常の呼び出し方法で呼び出すことで、順次、呼び出すことが可能です。

```kotlin
fun main() = runBlocking<Unit> {
    val time = measureTimeMillis {
        val one = doSomethingUsefulOne()
        val two = doSomethingUsefulTwo()

        println("The answer is ${one + two}")
    }
    println("Completed in $time ms")
}
```

```
実行結果

The answer is 42
Completed in 2017 ms
```


## async を使用した同時実行

doSomethingUsefulOne と doSomethingUsefulTwo の呼び出しの間に順序関係がなく、両方を同時に実行して、より早く回答を得たい場合はどうすればよいでしょうか。その場合は、 async が役に立ちます。

概念的には、 async は launch とまったく同じです。 async は、他のすべてのコルーチンと同時に動作する軽量スレッドである別のコルーチンを開始します。 async と launch の違いは、 launch は Job を返し、結果の値は持ちませんが、 async は Deferred ( 「延期」 の意味) を返すことです。 Deferred は、後で結果を提供するという約束を表す軽量の非ブロッキング future です。遅延値に対して .await() を使用して最終的な結果を取得できますが、 Deferred も Job であるため、必要に応じてキャンセルできます。

```kotlin
fun main() = runBlocking<Unit> {
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        println("The answer is ${one.await() + two.await()}")
    }
    println("Completed in $time ms")
}
```

```
実行結果

The answer is 42
Completed in 1017 ms
```

二つのコルーチンが同時に実行されるため、この例では、速度は二倍になります。コルーチンの同時実行は常に明示的に行う必要があります。


## async は遅延実行も可能

オプションで、開始パラメータを CoroutineStart.LAZY に設定することで、 async の実行を遅延させることができます。このモードでは、その結果が await によって要求されたとき、またはその Job の start 関数が呼び出された場合にのみ、コルーチンが開始されます。次の例を実行します。

```kotlin
fun main() = runBlocking<Unit> {
    val time = measureTimeMillis {
        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
        // 一つ目の関数を開始します。
        one.start()
        // 二つ目の関数を開始します。
        two.start()
        println("The answer is ${one.await() + two.await()}")
    }
    println("Completed in $time ms")
}
```

```
実行結果

The answer is 42
Completed in 1017 ms
```

start を呼び出すことによって、処理をいつ開始するかを正確に制御することが可能になります。

この例のように複数のコルーチンを同時に実行する場面では、 await で処理を開始せずに、 start で開始するようにしてください。なぜなら、 await は、そのコルーチンが完了するまで次の処理に進まないためです。この例では、 doSomethingUsefulOne 関数が完了してから doSomethingUsefulTwo 関数が開始されるため、同時実行ではなく、順次実行になってしまいます。

async(start = CoroutineStart.LAZY) の使用例は、値の計算に suspend 関数が含まれる場合に、標準の lazy 関数の代わりとなります。


## xxxAsync スタイルの関数（グローバルスコープのコルーチン）

非同期関数を使用したこのプログラミング スタイルは、他のプログラミング言語でよく使用されるスタイルであるため、ここでは説明のみを目的として提供されています。 Kotlin コルーチンでこのスタイルを使用することは、以下に説明する理由により、強く推奨されません。

構造化された同時実行をオプトアウトするために、 GlobalScope 参照を使用して、 async コルーチンビルダーを使用して、 doSomethingUsefulOne および doSomethingUsefulTwo を非同期的に呼び出す非同期スタイルの関数を定義できます。このような関数の名前には、非同期計算を開始するだけであり、結果を取得するには結果の遅延値を使用する必要があることを強調するために、「...Async」というサフィックスを付けます。

GlobalScope は、重要な方法で裏目に出る可能性のあるデリケートな API です。そのうちの 1 つについては以下で説明します。そのため、 @OptIn(DelicateCoroutinesApi::class) を使用して GlobalScope の使用を明示的にオプトインする必要があります。

```kotlin
// この関数の戻り値の型は Deferred<Int> です。
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulOneAsync() = GlobalScope.async {
    // これ ↓ は suspend 関数です。
    doSomethingUsefulOne()
}

// この関数の戻り値の型は Deferred<Int> です。
@OptIn(DelicateCoroutinesApi::class)
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}
```

これらの xxxAsync 関数はサスペンド関数ではないことに注意してください。 suspend 関数ではないので、これらはどこからでも使用できます。ただし、これらを使用すると、呼び出しコードとのアクションが常に非同期 (ここでは同時実行を意味します) で実行されます。

次のコードは、コルーチン外で使用する例です。

```kotlin
// この例では、main の右側に runBlocking がないことに注意してください。
fun main() {
    val time = measureTimeMillis {
        // async 関数をコルーチンの外側で呼び出せます。
        val one = somethingUsefulOneAsync()
        val two = somethingUsefulTwoAsync()
        // but waiting for a result must involve either suspending or blocking.
        // しかし、結果の取得には待機が必要なため、一時停止可能な suspending か blocking 内で取得する必要があります。
        runBlocking {
            println("The answer is ${one.await() + two.await()}")
        }
    }
    println("Completed in $time ms")
}
```

val one = somethingUsefulOneAsync() と one.await() 式の間にコードに何らかのロジックエラーがあり、プログラムが例外をスローし、プログラムによって実行されていた操作が中止された場合に何が起こるかを考えてみましょう。通常、グローバルエラーハンドラーはこの例外をキャッチし、開発者向けにエラーをログに記録して報告しますが、プログラムは他の操作を続行できます。ただし、ここでは、開始した操作が中止されたにもかかわらず、 somethingUsefulOneAsync がバックグラウンドでまだ実行されたままになってしまいます。この問題は、以下のセクションに示すように、構造化された同時実行では発生しません。


## async を使用した構造化された同時実行

[非同期を使用した同時実行](#async-を使用した同時実行) の例を取り上げて、 doSomethingUsefulOne と doSomethingUsefulTwo を同時に実行し、その結果の合計を返す関数を抽出してみましょう。 async コルーチンビルダーは CoroutineScope の拡張機能として定義されているため、コルーチンスコープ内で使用する必要があり、 coroutineScope 関数がそのスコープを提供することができます。

```kotlin
suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}
```

この方法では、 concurrentSum 関数のコード内で何か問題が発生して例外がスローされた場合、そのスコープ内で起動されたすべてのコルーチンがキャンセルされます。

```kotlin
fun main() = runBlocking<Unit> {
    val time = measureTimeMillis {
        println("The answer is ${concurrentSum()}")
    }
    println("Completed in $time ms")
}
```

```
実行結果

The answer is 42
Completed in 1017 ms
```

キャンセルは常にコルーチン階層を通じて伝播されます。

```kotlin
fun main() = runBlocking<Unit> {
    try {
        failedConcurrentSum()
    } catch(e: ArithmeticException) {
        println("Computation failed with ArithmeticException")
    }
}

suspend fun failedConcurrentSum(): Int = coroutineScope {
    val one = async<Int> { 
        try {
            // two が先に例外を発生させるように一時停止します。
            delay(5000)
            42
        } finally {
            println("First child was cancelled")
        }
    }
    val two = async<Int> { 
        println("Second child throws an exception")
        throw ArithmeticException()
    }
    one.await() + two.await()
}
```

two で発生した例外によって、 one とその親コルーチンがキャンセルされます。

```
実行結果

Second child throws an exception
First child was cancelled
Computation failed with ArithmeticException
```
