- [共有可変状態と同時実行](#共有可変状態と同時実行)
  - [問題](#問題)
  - [Volatile は役に立ちません](#volatile-は役に立ちません)
  - [スレッドセーフなデータ構造](#スレッドセーフなデータ構造)
  - [きめ細かいスレッド制限](#きめ細かいスレッド制限)
  - [粗いスレッド制限](#粗いスレッド制限)
  - [Mutual exclusion（相互排他 / 排他制御）](#mutual-exclusion相互排他--排他制御)
    - [Mutex でロックの取得リクエストが出された順に再開する](#mutex-でロックの取得リクエストが出された順に再開する)
    - [Mutex のロックは、 Mutex インスタンスに紐づく](#mutex-のロックは-mutex-インスタンスに紐づく)
    - [ReentrantLock](#reentrantlock)
  - [引用元資料](#引用元資料)


# 共有可変状態と同時実行

コルーチンは、 Dispatchers.Default のようなマルチスレッドディスパッチャを使用して並列実行できます。この場合も、通常の並列処理に関する問題は発生します。主な問題は、共有された可変状態へのアクセスの同期です。コルーチンの世界におけるこの問題の解決策の一部は、マルチスレッドの世界の解決策に似ていますが、独自の解決策もあります。


## 問題

100 個のコルーチンを起動して、それぞれのコルーチンで同じアクションを 1,000 回実行します。比較するために、完了時間を測定します。

```kotlin
// massive とは、大規模という意味
suspend fun massiveRun(action: suspend () -> Unit) {
    // 起動するコルーチンの数
    val n = 100
    // 各コルーチンで繰り返されるアクションの回数
    val k = 1000
    val time = measureTimeMillis {
        coroutineScope {
            repeat(n) {
                launch {
                    repeat(k) { action() }
                }
            }
        }
    }
    println("Completed ${n * k} actions in $time ms")    
}
```

まず、マルチスレッドの Dispatchers.Default を使用して共有の可変変数を増分する非常に単純なアクションから始めます。

```kotlin
var counter = 0

fun main() = runBlocking {
    withContext(Dispatchers.Default) {
        massiveRun {
            counter++
        }
    }
    println("Counter = $counter")
}
```

最後に何が出力されるでしょうか？ 100 個のコルーチンが複数のスレッドから同期なしで同時にカウンターを増分するため、 Counter = 100000 が出力される可能性はほとんどありません。

```
実行結果 (例)

Completed 100000 actions in 37 ms
Counter = 87034
```


## Volatile は役に立ちません

変数を Volatile にすると並行性の問題が解決するという誤解がよくあります。試してみましょう。

Volatile について、詳しくは、 [メモリ可視性の問題](../../../Java/マルチスレッド/メモリ可視性の問題.md) や [AtomicInteger と volatile Integer の違い](../../../Java/マルチスレッド/AtomicInteger%20と%20volatile%20Integer%20の違い.md) を参照してください。

```kotlin
// Kotlin では、 volatile はアノテーションで定義されます。
@Volatile
var counter = 0

fun main() = runBlocking {
    withContext(Dispatchers.Default) {
        massiveRun {
            counter++
        }
    }
    println("Counter = $counter")
}
```

```
実行結果

Completed 100000 actions in 41 ms
Counter = 98338
```

このコードの動作は遅くなりますが、それでも最後に Counter = 100000 になるとは限りません。これは、 Volatile 変数は対応する変数への単純な読み取りと単純な書き込み (※) のスレッドセーフを保証しますが、より大きなアクション (この場合はインクリメント) のアトミック性を提供しないためです。

※ これを atomic の専門用語で線形可能化 ( linearizable ) と言います。


## スレッドセーフなデータ構造

スレッドとコルーチンの両方で役に立つ一般的な解決策は、スレッドセーフなデータ構造を使用することです。このデータ構造は、共有状態の上で動作する必要がある処理に、必要な同期を提供します。単純なカウンターの場合は、アトミックな `incrementAndGet` 操作を持つ `AtomicInteger` クラスを使用できます。

```kotlin
val counter = AtomicInteger()

fun main() = runBlocking {
    withContext(Dispatchers.Default) {
        massiveRun {
            counter.incrementAndGet()
        }
    }
    println("Counter = $counter")
}
```

```
実行結果

Completed 100000 actions in 40 ms
Counter = 100000
```

これは、この特定の問題に対する最速のソリューションです。単純なカウンター、コレクション、キュー、その他の標準データ構造、およびそれらに対する基本操作で機能します。ただし、複雑な状態や、すぐに使用できるスレッドセーフな実装がない複雑な操作には簡単に使用できません。


## きめ細かいスレッド制限

スレッド制限は、共有された可変状態の問題に対するアプローチであり、特定の共有状態へのすべてのアクセスが 1 つのスレッドに制限されます。これは通常、すべての UI 状態が単一のイベントディスパッチ (アプリケーションスレッド) に制限される UI アプリケーションで使用されます。シングルスレッドのコンテキストを使用することで、コルーチンで簡単に適用できます。

```kotlin
val counterContext = newSingleThreadContext("CounterContext")
var counter = 0

fun main() = runBlocking {
    withContext(Dispatchers.Default) {
        massiveRun {
            // 全てインクリメント処理をシングルスレッドコンテキストに制限する
            withContext(counterContext) {
                counter++
            }
        }
    }
    println("Counter = $counter")
}
```

```
実行結果

Completed 100000 actions in 2142 ms
Counter = 100000
```

このコードは、きめ細かいスレッド制限を行うため、非常に低速で動作します。各インクリメント処理は、 withContext(counterContext) ブロックを使用して、マルチスレッドの Dispatchers.Default コンテキストからシングルスレッドのコンテキストに切り替わります。


## 粗いスレッド制限

以下のように、コンテキストスイッチを大きなスコープで一回だけ実施すると、コンテキストスイッチが多発しないため、動作が高速になります。

```kotlin
// newSingleThreadContext 関数は、 2024 年 6 月現在は、実験中の API であるため、使用の際には注意してください。実験中の API には問題が残っていたり、今後、動作が変更になる可能性があります。
val counterContext = newSingleThreadContext("CounterContext")
var counter = 0

fun main() = runBlocking {
    // 
    // confine everything to a single-threaded context
    withContext(counterContext) {
        massiveRun {
            counter++
        }
    }
    println("Counter = $counter")
}
```

この方法では、ずいぶんと早く動作し、結果も正確です。

```
実行結果

Completed 100000 actions in 44 ms
Counter = 100000
```


## Mutual exclusion（相互排他 / 排他制御）

この問題に対する排他制御の解決策は、同時に実行されることのないクリティカルセクションを生成して、共有状態のすべての変更を保護することです。ブロッキング環境では、通常、そのために synchronized または ReentrantLock を使用します。 Coroutine の代替手段は [Mutex](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/) と呼ばれます。 ( Mutex は、 Mutual Exclusion を短くした造語です。) これらの主な違いは、 `Mutex.lock()` は suspend 関数となっており、スレッドをブロックしない点です。つまり、ロックを取得できなかったスレッドは、ブロックされるのではなく、一時停止します。

Mutex には、クリティカルセクションを区切るための 「ロック関数」 と 「ロック解除関数」 があります。

また、 `mutex.lock(); try { ... } finally { mutex.unlock() }` パターンを便利に表す `mutex.withLock{}` 拡張関数もあります。 withLock は、処理が完了すると暗黙的に unlock を実施してくれます。

```kotlin
val mutex = Mutex()
var counter = 0

fun main() = runBlocking {
    withContext(Dispatchers.Default) {
        massiveRun {
            // 各インクリメントをロックで守ります。
            mutex.withLock {
                counter++
            }
        }
    }
    println("Counter = $counter")
}
```

この例のロックは粒度が細かいため、パフォーマンス的な代償を払うことになります。ただし、共有状態を定期的に変更する必要があり、この状態が制限される自然なスレッドが存在しない状況では、このロックは適切な選択です。


### Mutex でロックの取得リクエストが出された順に再開する

デフォルトでは公平性 (ロックの取得リクエストが出された順に再開すること) は、保証されませんが、公平性を持つ Mutex を作成することもできます。

公平性を必要とする場合、 `Mutex(fair = true)` を使用することで、ロックがリクエストされた順序に基づいて、コルーチンを再開することができます。

```kotlin
val fairMutex = Mutex(fair = true)
```


### Mutex のロックは、 Mutex インスタンスに紐づく

Java の synchronized 修飾子は、そのロックが、そのメソッドを呼び出したインスタンスに紐づくように、 Kotlin の Mutex は、そのロックが、 Mutex() インスタンスに紐づきます。

つまり、共有リソースを排他制御するには、必ず同じ Mutex インスタンスを共有する必要があります。


### ReentrantLock

reentrant という単語には、 「再入可能な」 という意味があります。 特に、関数の特性を表すのに用いられ、 reentrant な関数とは、複数のスレッドによって、同時に複数の場所から呼び出されても、問題なく動作することを指します。

```java
class X {
    private final ReentrantLock lock = new ReentrantLock();
    // ...

    public void m() {
        lock.lock();  // block until condition holds
        try {
            // ... method body
        } finally {
            lock.unlock()
        }
    }
}
```

[ReentrantLock クラス - Java 公式ドキュメント](https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/locks/ReentrantLock.html)


## 引用元資料

- [Shared mutable state and concurrency](https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html)

