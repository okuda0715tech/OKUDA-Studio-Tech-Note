- [要素をまとめて取得する](#要素をまとめて取得する)
  - [Slice](#slice)
  - [Take と Drop](#take-と-drop)
    - [Take](#take)
    - [Drop](#drop)
    - [条件判定付きの Take と Drop](#条件判定付きの-take-と-drop)
  - [Chunked（かたまり、ぶつ切り）](#chunkedかたまりぶつ切り)
    - [基本形](#基本形)
    - [Chunk を何かに変換する](#chunk-を何かに変換する)
  - [Windowed](#windowed)
    - [基本形](#基本形-1)
    - [ステップの変更](#ステップの変更)
    - [要素数が割り切れない場合でも小さいサイズのリストを生成する](#要素数が割り切れない場合でも小さいサイズのリストを生成する)
    - [分割後のリストに関数を適用する](#分割後のリストに関数を適用する)
    - [List\<Pair\> を生成する特別な関数](#listpair-を生成する特別な関数)


# 要素をまとめて取得する

## Slice

`slice()` 関数は、インデックスで指定した複数の要素を List オブジェクトで返します。インデックスは、 Range 型か Int 型のコレクションで指定することが可能です。関数で返される List オブジェクトは、元のコレクションとは別のインスタンスですが、要素自体は同じインスタンスを参照しています。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five", "six")    

println(numbers.slice(1..3))
// [two, three, four]

println(numbers.slice(0..4 step 2))
// [one, three, five]

println(numbers.slice(setOf(3, 5, 0)))
// [four, six, one]
```


## Take と Drop

Take も Drop も戻り値の型は、 List になります。 takeLast() 及び dropLast() は、 List オブジェクトのみで使用可能です。 Set オブジェクトでは使用できません。


### Take

コレクションの先頭から指定した数の要素を取得したい場合は、 `take()` 関数を使用します。逆に、後ろから取得したい場合は `takeLast()` 関数を使用します。コレクションのサイズよりも大きな数字が指定された場合には、全ての要素を返します。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five", "six")
println(numbers.take(3))
// [one, two, three]
println(numbers.takeLast(3))
// [four, five, six]
println(numbers.take(7))
// [one, two, three, four, five, six]
println(numbers.takeLast(7))
// [one, two, three, four, five, six]
```


### Drop

コレクションの先頭から指定した数の要素を除外した残りの要素を取得したい場合は、 `drop()` 関数を使用します。逆に、後ろから除外した残りの要素を取得したい場合は `dropLast()` 関数を使用します。コレクションのサイズよりも大きな数字が指定された場合には、カラの List を返します。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five", "six")

println(numbers.drop(1))
// [two, three, four, five, six]
println(numbers.dropLast(5))
// [one]
println(numbers.drop(7))
// []
println(numbers.dropLast(7))
// []
```


### 条件判定付きの Take と Drop

Take と Drop のそれぞれの関数の末尾に while を付与した名前の関数は、引数に条件文を指定することができます。 Take なら、条件を満たしている間は要素を取得し、一度でも条件を満たさなくなったら残りの全ての要素を除外します。逆に、 Drop なら、条件を満たしている間は要素を除外し、一度でも条件を満たさなくなったら残りの全ての要素を取得します。一度でも条件を満たさない要素が検出されたら、そこで判定は終了します。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five", "six")

// Take は先頭から判定を行い、条件に一致している間は要素を取得し、
// 条件を満たさない要素が検出されたら残りの要素は全て除外する

println(numbers.takeWhile { !it.startsWith('f') })
// [one, two, three]
println(numbers.takeLastWhile { it != "three" })
// [four, five, six]

// Drop は条件に一致している間は要素を除外し、
// 条件を満たさない要素が検出されたら残りの要素を全て取得する

println(numbers.dropWhile { it.length == 3 })
// [three, four, five, six]
println(numbers.dropLastWhile { it.contains('i') })
// [one, two, three, four]
```


## Chunked（かたまり、ぶつ切り）

### 基本形

`chunked()` 関数は、 Iterable オブジェクトを指定したサイズの List に分割します。戻り値の型は `List<List<E>>` となります。元の要素の数が、指定したサイズで割り切れない場合は、最後の List は、他のリストよりも短くなります。

```kotlin
val numbers = (0..13).toList()
println(numbers)
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
println(numbers.chunked(3))
// [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13]]
```


### Chunk を何かに変換する

`chunked()` 関数にラムダ式を与えることで、 Chunk (ぶつ切りにされた個別の List ) に対してすぐに何らかの処理を実施し、その結果を格納した List を返すことが可能です。

```kotlin
val numbers = (0..13).toList() 
// it は Chunk を示します。
// ラムダ式の結果は新しい List の要素になります。
println(numbers.chunked(3) { it.sum() })
// [3, 12, 21, 30, 25]
```


## Windowed

### 基本形

`windowed()` 関数は、 `chunked()` 関数のように、 Iterable オブジェクトを指定したサイズの List に分割します。戻り値の型は `List<List<E>>` となります。引数で与えられた要素数の List に分割していきます。

chunked() 関数との違いは、二つあります。

1. 隣り合う List の要素が重複するかどうか
   - chunked() 関数は、隣り合う List の要素が重複しません
   - windowed() 関数は、隣り合う List の要素が重複します
2. 元の Iterable オブジェクトの要素数が指定した List のサイズで割り切れない場合の挙動
   - chunked() 関数は、指定したサイズよりも小さいサイズのリストが生成されます。
   - windowed() 関数は、デフォルトでは、指定したサイズよりも小さいサイズのリストは生成されません。

windowed() 関数は、元の Iterable オブジェクトを一つずつスライドしながら分割していきます。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five")    

println(numbers.windowed(3))
// [[one, two, three], [two, three, four], [three, four, five]]

println(numbers.windowed(4))
// [[one, two, three, four], [two, three, four, five]]
```


### ステップの変更

デフォルトでは、元の Iterable オブジェクトの要素を一つずつスライドしながら分割していきますが、ステップを指定することで、任意の数ずつスライドすることが可能です。

```kotlin
val numbers = (1..5).toList()
println(numbers.windowed(3, step = 2))
// [[1, 2, 3], [3, 4, 5]]
```


### 要素数が割り切れない場合でも小さいサイズのリストを生成する

引数に `partialWindows = true` を指定することで、元の Iterable オブジェクトの要素数が指定した List のサイズで割り切れない場合に、そのサイズよりも小さいサイズのリストを生成することができます。

```kotlin
val numbers = (1..4).toList()
println(numbers.windowed(3, partialWindows = true))
// [[1, 2, 3], [2, 3, 4], [3, 4], [4]]
```


### 分割後のリストに関数を適用する

windowed() 関数にラムダ式を与えることで、分割後のリストに関数を適用することが可能です。ラムダ式の結果の型 E の `List<E>` オブジェクトが返されます。

```kotlin
val numbers = (1..4).toList()
println(numbers.windowed(3))
// [[1, 2, 3], [2, 3, 4]]
println(numbers.windowed(3) { it.sum() })
// [6, 9]
```


### List\<Pair> を生成する特別な関数

`zipWithNext()` 関数は、 windowed() 関数の一種です。 必ず要素を二つごとに分割し `List<Pair<T, T>>` オブジェクトを返します。分割後に関数を適用することも可能です。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five")    

println(numbers.zipWithNext())
// [(one, two), (two, three), (three, four), (four, five)]

println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})
// [false, false, true, false]
```




