- [構造の変更](#構造の変更)
  - [Map (マッピング)](#map-マッピング)
    - [List 以外から List への変換](#list-以外から-list-への変換)
      - [null や特定の値を除外したい場合](#null-や特定の値を除外したい場合)
    - [ある Map から別の Map への変換](#ある-map-から別の-map-への変換)
    - [【応用】Immutable な List の特定の要素を更新する](#応用immutable-な-list-の特定の要素を更新する)
  - [Zip](#zip)
    - [概要](#概要)
    - [レシーバーを取得する](#レシーバーを取得する)
    - [逆変換する](#逆変換する)
  - [Associate](#associate)
    - [元のコレクションの要素をキーとして Map を生成](#元のコレクションの要素をキーとして-map-を生成)
    - [元のコレクションの要素を値として Map を生成](#元のコレクションの要素を値として-map-を生成)
    - [元のコレクションの要素に関数を適用してキーと値を生成した Map を生成](#元のコレクションの要素に関数を適用してキーと値を生成した-map-を生成)
  - [Flatten](#flatten)
    - [概要](#概要-1)
    - [コレクションの中に直接コレクションが格納されていない場合](#コレクションの中に直接コレクションが格納されていない場合)
  - [String representation](#string-representation)
    - [基本形](#基本形)
    - [prefix, postfix, separator](#prefix-postfix-separator)
    - [連結する要素数の上限指定](#連結する要素数の上限指定)
    - [要素を個別に加工する](#要素を個別に加工する)


# 構造の変更

## Map (マッピング)

**ここでいう Map とは、 Collection のサブクラスの Map ではなく、 「あるコレクションから別のコレクションへのマッピング」 という意味なので、注意してください。**


### List 以外から List への変換

マッピングには、 `map()` 関数、もしくは `mapIndexed()` 関数を使用します。この関数を実行すると、あるコレクションを別の List に変換して返します。

要素の並び順は、元のコレクションと同じになります。

```kotlin
val numbers = setOf(1, 2, 3)
println(numbers.map { it * 3 }) // [3, 6, 9]
// 引数に要素番号を使用したい場合
println(numbers.mapIndexed { idx, value -> value * idx }) // [0, 2, 6]
```


#### null や特定の値を除外したい場合

null や特定の値を除外したい場合には、 `map()` 関数の代わりに `mapNotNull()` 関数を使用します。または、 `mapIndexed()` 関数の代わりに `mapIndexedNotNull()` 関数を使用します。

これらは、要素が null の場合は要素を除外します。特定の値を除外したい場合は、その値の場合に null を返すようにします。

```kotlin
val numbers = setOf(1, 2, 3)
println(numbers.mapNotNull { if ( it == 2) null else it * 3 })
// [3, 9]

println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })
// [2, 6]
```


### ある Map から別の Map への変換

Collection のサブクラスの Map クラスにもマッピング関数が用意されています。値はそのままでキーだけマッピングする場合は、 `mapKeys()` 関数を使用し、キーはそのままで値だけマッピングする場合は、 `mapValues()` 関数を使用します。これらは、関数の引数に Map の要素を持っているため、関数内で Map のキーと値の両方が使用可能です。

```kotlin
val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key11" to 11)

// 値はそのままでキーだけマッピングする
println(numbersMap.mapKeys { it.key.uppercase() })
// {KEY1=1, KEY2=2, KEY3=3, KEY11=11}

// キーはそのままで値だけマッピングする
println(numbersMap.mapValues { it.value + it.key.length })
// {key1=5, key2=6, key3=7, key11=16}
```


### 【応用】Immutable な List の特定の要素を更新する

以下は、特定のインデックスの要素を更新する例です。

```kotlin
val originalList = listOf(1, 2, 3, 4, 5)

// 例えば、2 番目の要素（インデックス 1）を 42 に更新する場合
val updatedList = originalList.mapIndexed { index, value ->
    if (index == 1) 42 else value
}

println(updatedList) // [1, 42, 3, 4, 5]
```

以下は、特定の値の要素を更新する例です。

```kotlin
val updatedList = originalList.map { value ->
    if (value == 3) 42 else value
}

println(updatedList) // [1, 2, 42, 4, 5]
```


## Zip

### 概要

`zip()` 関数は、二つのコレクションもしくは配列の同一インデックスの要素同士を Pair オブジェクトに格納し、 `List<Pair>` を生成する関数です。

二つのコレクション or 配列の要素数が異なる場合は、長さが短い方の長さに合わせられて、はみ出した要素は、 `List<Pair>` には含まれません。

```kotlin
val colors = listOf("red", "brown", "grey")
val animals = listOf("fox", "bear", "wolf")

println(colors zip animals)
// [(red, fox), (brown, bear), (grey, wolf)]

val twoAnimals = listOf("fox", "bear")

println(colors.zip(twoAnimals))
// [(red, fox), (brown, bear)]
```


### レシーバーを取得する

`zip()` 関数の第二引数を使用すれば、レシーバーオブジェクトを取得することが可能です。

```kotlin
val colors = listOf("red", "brown", "grey")
val animals = listOf("fox", "bear", "wolf")

println(colors.zip(animals) { color, animal ->
    "The ${animal.replaceFirstChar { it.uppercase() }} is $color"
})
```


### 逆変換する

`unzip()` 関数を使用することによって、 `List<Pair>` オブジェクトから二つのリストを生成することができます。

```kotlin
val numberPairs = listOf("one" to 1, "two" to 2, "three" to 3, "four" to 4)
println(numberPairs.unzip())
// ([one, two, three, four], [1, 2, 3, 4])
```

unzip() 関数の戻り値の型は `Pair<List<T>, List<R>>` です。


## Associate

### 元のコレクションの要素をキーとして Map を生成

`associateWith()` 関数は、元のコレクションに対して、任意の関数を適用し、元のコレクションの要素をキーとして、関数の戻り値をバリューとした Map を返します。

```kotlin
val numbers = listOf("one", "two", "three", "four")
println(numbers.associateWith { it.length })
// {one=3, two=3, three=5, four=4}
```

結果は Map に格納するため、キーが重複する場合には、 Map の仕様通り、後から格納された値で上書きされます。


### 元のコレクションの要素を値として Map を生成

引数が一つの `associateBy()` 関数は、元のコレクションに対して、任意の関数を適用し、元のコレクションの要素を Map の値として、関数の戻り値を Map のキーとした Map を返します。

```kotlin
val numbers = listOf("one", "two", "three", "four")

println(numbers.associateBy { it.first().uppercaseChar() })
// {O=one, T=three, F=four}
```


### 元のコレクションの要素に関数を適用してキーと値を生成した Map を生成

【方法 1 】

引数が二つの `associateBy()` 関数は、元のコレクションに対して、任意の関数を適用し、 Map のキーと値を生成し、その Map を返します。

```kotlin
val numbers = listOf("one", "two", "three", "four")

println(
    numbers.associateBy(
        keySelector = { it.first().uppercaseChar() },
        valueTransform = { it.length })
)
// {O=3, T=5, F=4}
```

【方法 2 】

`associate()` 関数も元のコレクションに対して、任意の関数を適用し、 Map のキーと値を生成し、その Map を返すことができます。この方法では、 Pair を生成する必要があります。ごく短い期間だけのために生成される Pair オブジェクトはパフォーマンスを少し下げる原因になり得るため、パフォーマンスに影響が出る場合には、 `associateBy()` 関数の使用を検討しましょう。

```kotlin
val names = listOf("Alice Adams", "Brian Brown", "Clara Campbell")

println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })
// {Adams=Alice, Brown=Brian, Campbell=Clara}
```


## Flatten

### 概要

`flatten()` 関数は、ネストされたコレクションのネストを解消して、ネストされていないコレクションとして扱うのに使用されます。

例えば、 List<Set> 型のリストに flatten() 関数を適用すると以下のようになります。

```kotlin
val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))

println(numberSets.flatten())
// [1, 2, 3, 4, 5, 6, 1, 2]
```


### コレクションの中に直接コレクションが格納されていない場合

コレクションの中に別のコレクションが直接格納されておらず、何らかのコンテナオブジェクトを挟んでいる場合、そのコンテナオブジェクトから取り出してフラットな List を返すことも可能です。

```kotlin
data class StringContainer(val values: List<String>)

fun main() {
    val containers = listOf(
        StringContainer(listOf("one", "two", "three")),
        StringContainer(listOf("four", "five", "six")),
        StringContainer(listOf("seven", "eight"))
    )
    // it は containers を表します。
    // flatMap 関数の引数の関数型は Iterable なオブジェクトである必要があります。
    println(containers.flatMap { it.values })
    // [one, two, three, four, five, six, seven, eight]
}
```

複雑なデータ構造なので、あまり使う場合がなさそうかと思いましたが、 JSON などでよくあるデータ構造のようにも思えました。


## String representation

### 基本形

`joinToString()` 関数は、コレクションの要素を連結し、一つの String 型のデータを返します。

また、 `joinTo()` 関数は、 `joinToString()` 関数と同じ機能を持っています。つまり、レシーバーの要素を連結して String 型で返す機能です。そして、さらに、引数で与えられた文字列の後ろにその String 型のデータを連結する機能を持っています。


```kotlin
val numbers = listOf("one", "two", "three", "four")

println(numbers)         
// [one, two, three, four]
println(numbers.joinToString())
// one, two, three, four

val listString = StringBuffer("The list of numbers: ")
numbers.joinTo(listString)
println(listString)
// The list of numbers: one, two, three, four
```


### prefix, postfix, separator

prefix, postfix, separator を指定することで、リストの先頭、リストの末尾、要素間の三種類の文字列を追加することが可能です。

```kotlin
val numbers = listOf("one", "two", "three", "four")
println(
    numbers.joinToString(
        separator = " | ",
        prefix = "start: ",
        postfix = ": end"
    )
)
// start: one | two | three | four: end
```


### 連結する要素数の上限指定

limit を指定することで、連結する要素数の上限を指定することが可能です。上限を超えた要素は連結されず、代わりに truncated 引数で指定された文字列が一つ連結されます。

```kotlin
val numbers = (1..100).toList()
println(numbers.joinToString(limit = 10, truncated = "<...>"))
// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, <...>
```


### 要素を個別に加工する

`joinToString()` 関数は `transform:((T) -> CharSequence)?` という関数型の引数を持っています。この関数は要素のデータを個別に加工する関数です。

```kotlin
val numbers = listOf("one", "two", "three", "four")
println(numbers.joinToString { "Element: ${it.uppercase()}"})
// Element: ONE, Element: TWO, Element: THREE, Element: FOUR
```


