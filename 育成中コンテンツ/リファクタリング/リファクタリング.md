<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [リファクタリングのコツ](#リファクタリングのコツ)
  - [変数に単位がある場合は変数名やgetterメソッドに単位を付ける](#変数に単位がある場合は変数名やgetterメソッドに単位を付ける)
  - [データはプリミティブ型で扱わず、クラスでパッケージングする](#データはプリミティブ型で扱わずクラスでパッケージングする)
  - [共通化できるコードは早めに共通化する](#共通化できるコードは早めに共通化する)
  - [一部の機能が同じであるボタンはよくあると思うので、真っ先に共通化できないか検討する](#一部の機能が同じであるボタンはよくあると思うので真っ先に共通化できないか検討する)
  - [ビジネスロジックは前処理、主処理、後処理に分ける](#ビジネスロジックは前処理主処理後処理に分ける)
  - [変数、フィールドは何でもかんでもパッケージ化（クラス化）しない](#変数フィールドは何でもかんでもパッケージ化クラス化しない)
  - [Activityのコールバックメソッドなどはメソッド名が処理内容を表していないため、処理内容を表すメソッドを呼び出すようにする。](#activityのコールバックメソッドなどはメソッド名が処理内容を表していないため処理内容を表すメソッドを呼び出すようにする)
  - [パッと見で意味を把握できない処理群は、通常はメソッド化したほうがわかりやすいが、コメントを記述するだけで良い場合もある。](#パッと見で意味を把握できない処理群は通常はメソッド化したほうがわかりやすいがコメントを記述するだけで良い場合もある)
  - [メソッドの呼び出し元で引数や戻り値のキャストが必要な場合は、ジェネリクスメソッド化を検討する。](#メソッドの呼び出し元で引数や戻り値のキャストが必要な場合はジェネリクスメソッド化を検討する)
<!-- TOC END -->


# リファクタリングのコツ

## 変数に単位がある場合は変数名やgetterメソッドに単位を付ける

- メリット
  - 単位があると一目で単位の変換が必要か不要かわかる。
  - 異なる単位どうしで計算している場合に、コードを見ただけでバグだとすぐにわかる。

## データはプリミティブ型で扱わず、クラスでパッケージングする

- メリット
  - データの再利用性が高まる。
    - 複数箇所で同一データを利用しやすくなる。
    - 後続処理が共通化しやすくなる。
      - プリミティブ型だと同じ変数でも変数名が異なっているなどして共通化できることに気がつきにくい。

## 共通化できるコードは早めに共通化する

- メリット
  - 片方だけ修正し忘れる事によるバグの発生を防げる。

## 一部の機能が同じであるボタンはよくあると思うので、真っ先に共通化できないか検討する

- メリット
  - 早期共通化で開発効率のアップ

## ビジネスロジックは前処理、主処理、後処理に分ける

- メリット
  - 主処理が本来のビジネスロジックにあたる。
  - アプリ本来の機能のための処理と定型処理が明確に分離されるため、可読性が上がる。


## 変数、フィールドは何でもかんでもパッケージ化（クラス化）しない

- メリット
  - ちょっとした変数を使用するだけなら、パッケージ化せずにプリミティブ型や最初から定義されている参照型の変数を使用した方がシンプルで可読性が高い。

データをプリミティブ型などの変数で一つ一つ持つのではなく、独自クラスを作成してその中に  
持つことはいいことであるが、時には、変数一つ一つ持った方がシンプルでわかりやすい実装になる。  
例えば、独自クラスの中のたった一つのフィールドだけを使用したい場合、  
わざわざ独自クラスを使用すると、使用したい変数がクラス名で隠れてしまう。  
また、独自クラスを使用するということは、そのクラス内のたくさんの変数を使用する可能性を  
連想させられるため、パッと見、すごく複雑な処理に思えてしまう。  
そのため、コードを修正する際には、色々と影響が出るのではないかと多くの調査をすることになり、  
時間が余計にかかってしまう。

独自クラスを作成する際には、そのクラスにどんなフィールドを持たせるかによって、  
最初からどんな使い方をするのかを想定しているはず。  
その本来の目的以外の部分で、独自クラスを使用するべきではない。  
なぜなら、そのクラス自体の使用方法が曖昧になり、改修時に影響が把握しきれずに  
改修できなくなってしまうためである。


## Activityのコールバックメソッドなどはメソッド名が処理内容を表していないため、処理内容を表すメソッドを呼び出すようにする。

Activityのコールバックメソッドをはじめとした「オーバーライドするメソッド」は、  
メソッド名が呼び出すタイミング等を表す名前になっており、処理内容を表していない。  
そのため、そのようなメソッドに直接的にビジネスロジックを記述すると、パッと見たときに、  
処理内容がわかりづらくなることがほとんどである。  
そのため、処理内容を表すメソッドを別途定義して、それを呼び出すようにすると良い。


## パッと見で意味を把握できない処理群は、通常はメソッド化したほうがわかりやすいが、コメントを記述するだけで良い場合もある。

たかだか数行の処理の場合は、わざわざメソッド抽出するとメソッドが増えすぎてしまい、  
今度は、メソッド一覧を閲覧するときの読解速度が低下してしまう。  
そのような場合は、処理群の直前に一行コメントを書くだけにしたほうが読解速度が上がる。


## メソッドの呼び出し元で引数や戻り値のキャストが必要な場合は、ジェネリクスメソッド化を検討する。

ジェネリクスメソッド化することで、メソッドの呼び出し元でのキャストが不要になり、  
キャストが失敗するリスクを減らし、メソッドの使用者の負担も軽減できる可能性があります。



