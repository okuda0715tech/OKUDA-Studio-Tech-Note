<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [別画面に遷移する場合、画面は一旦破棄される](#別画面に遷移する場合画面は一旦破棄される)
  - [概要](#概要)
  - [画面遷移時に遷移元画面をバックスタックに保持することはできない](#画面遷移時に遷移元画面をバックスタックに保持することはできない)
    - [ViewModelを全画面を統括するActivityのライフサイクルに関連づけるのも基本的にNGである](#viewmodelを全画面を統括するactivityのライフサイクルに関連づけるのも基本的にngである)
<!-- TOC END -->


# 別画面に遷移する場合、画面は一旦破棄される

## 概要

ドロワーメニューで別画面に遷移する場合、遷移元の Fragment は一旦破棄される。  
破棄はメモリ不足による物ではなく、明示的な破棄であるため、その Fragment のライフサイクルに  
連動している ViewModel も破棄される。

遷移元画面に再度戻ってきた場合に、画面の状態を復元したい場合は、データを永続化しておく必要がある。


## 画面遷移時に遷移元画面をバックスタックに保持することはできない

バックスタックは、その名の通りスタックなので、例えば、 `[A -> B -> C -> D]` のように  
画面遷移した場合、その後、 `B` に戻りたい場合に、 `CとD` をポップする必要がある。  
ポップした `CとD` は、せっかく状態を保存していたのに復元できなくなってしまう。  
遷移した順番によって、保持される画面と破棄される画面があるとユーザーは混乱してしまうため、  
そのようなUIは良くない。

上記の例において、もちろん、スタックの途中にある `B` のみを削除して、一旦  
`[A -> C -> D]` の状態にして、その後、後ろに `B` を追加することによって、  
`[A -> C -> D -> B]` の状態を作る。ということも不可能である。  
なぜなら、バックスタックはスタックであるため、途中にある `B` だけを削除することができないためである。


### ViewModelを全画面を統括するActivityのライフサイクルに関連づけるのも基本的にNGである

画面の状態を ViewModel で保持したい場合は、 ViewModel を各ページの Fragment の  
ライフサイクルに関連づけるのではなく、全てのページを統括している Activity の  
ライフサイクルに関連づけるようにすれば良いように思われる。しかし、そうすると、  
各ページに遷移した時に、 DB 等から最新のデータを読み込むことができなくなる。  
なぜなら、 DB から最新のデータを読み込むと、 ViewModel のデータが上書きされてしまうためである。  
かといって、最新データの読み込みタイミングをユーザー操作にゆだねると、ユーザーが  
ViewModel と DB のデータを連携しないままアプリを使用してしまう可能性があり、  
そうすると、ユーザーが画面上のデータが既に保存されているものだと思い込んで、アプリを  
終了してしまう可能性があるため、その後、データが保存されていないことが発覚すると  
ユーザーに混乱を招いてしまう。
