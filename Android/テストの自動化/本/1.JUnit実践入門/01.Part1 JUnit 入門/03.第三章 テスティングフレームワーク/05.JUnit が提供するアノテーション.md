- [05.JUnit が提供するアノテーション](#05junit-が提供するアノテーション)
  - [@Test](#test)
    - [expected 属性](#expected-属性)
    - [timeout 属性](#timeout-属性)
  - [@Ignore](#ignore)
  - [@Before](#before)
  - [@After](#after)
  - [@BeforeClass](#beforeclass)
  - [@AfterClass](#afterclass)


# 05.JUnit が提供するアノテーション

## @Test

メソッドに @Test アノテーションを付与することで、そのメソッドがテストメソッドとして認識されます。

@Test アノテーションを付与したメソッドは、以下の特徴を持ちます。

- メソッドの戻り値は void である。
- メソッドは引数を持たない。
- メソッドは public である。
- expected と timeout という属性を持つことができる。


### expected 属性

テスト対象が送出する例外が、具体的にどのクラスの例外を送出するのかを検証するのに使用します。

```java
@Test(expected = IllegalArgumentException.class)
public void 例外テスト() throws Exception {
    sut.doSomething();
}
```

テストメソッドが、 expected 属性で指定したクラスの例外、または、そのサブクラスの例外が送出された場合、そのテストケースは成功となります。

ただし、この方法で例外を検証する場合、例外の型以外は検証できません。つまり、本来、例外を送出すべき場所以外で、同じ型の例外が送出された場合も、成功とみなされます。また、例外のメッセージを検証することもできません。

より詳細に例外を検証したい場合は、 「ルール」 の一つである ExpectedException を使用してください。 (詳細は、第九章のセクション 2 で説明します。)


### timeout 属性

timeout 属性を指定すると、テストにかかる時間が timeout 値を超えた場合に、テストが失敗したとみなされます。

テスト対象で、無限ループやデッドロックが発生した場合に、他のテストを止めてしまわないようにする保険の機能です。 (決してパフォーマンスを測定するためのものではない点に、注意してください。)

```java
@Test(timeout = 100L)
public void タイムアウトテスト() {
    // ...
}
```


## @Ignore

@Test アノテーションを付与したテストメソッドを、一時的にテストの対象から除外したい場合に @Ignore アノテーションを使用します。

@Ignore アノテーションは、テストメソッドに付与することも、テストクラスに付与することも可能です。

テストクラスに付与した場合は、そのクラス内の全てのテストメソッドが、テストから一時的に除外されます。

```java
@Ignore("未実装")
@Test
public void ～テスト() {
    // ...
}
```


## @Before

JUnit によるユニットテストでは、テスト対象のクラスごとにテストクラスを作成し、テストクラスに複数のメソッドを定義していきます。すると、自然と初期化処理に重複したコードが生まれます。それらを抽出し、一つのメソッドにまとめる場合に @Before アノテーションは使用されます。

```java
// 慣例的にメソッド名は、 setUp とします。
@Before
public void setUp() throws Exception {
    sut = new Calculator();
    sut.init();
}
```

@Before アノテーションを付与したメソッドは、以下の制約を満たす必要があります。

- メソッドの戻り値は、 void とする。
- メソッドは、引数を持たない。
- メソッドは、 public とする。

また、複数のクラスに共通する処理を抽出するには、 「ルール」 を使用します。ルールについては、第九章で説明します。


## @After

@After アノテーションは、複数のテストケースに共通する後処理を別のメソッドに抽出するのに使用されます。

@After アノテーションを付与したメソッドは、以下の制約を満たす必要があります。 ( @Before アノテーションと同様)

- メソッドの戻り値は、 void とする。
- メソッドは、引数を持たない。
- メソッドは、 public とする。

```java
// 慣例的にメソッド名は、 tearDown とします。
@After
public void tearDown() throws Exception {
    sut.shutDown();
}
```

@After で定義された後処理は、テストケースの成功 / 失敗にかかわらず実行されます。そのため、必ず実行する必要のある後処理に対して使用します。


## @BeforeClass

@BeforeClass アノテーションは、 @Before アノテーション同様に、共通する事前処理を抽出するのに使用します。これらの違いは、それが実行されるタイミングと、実行される回数です。その用途を含め、違いを以下の表にまとめます。

|                | @Before                                            | @BeforeClass                                                     |
| -------------- | -------------------------------------------------- | ---------------------------------------------------------------- |
| 実行タイミング | 各テストメソッドの実行前に実行                     | テストクラス内のいずれか最初のテストメソッドが実行される前に実行 |
| 実行回数       | 何度でも                                           | テスト全体を通じて 1 回のみ                                      |
| 用途           | 各テストケースで個別に必要とされるリソースの初期化 | テスト全体を通じて共通で使用されるリソースの初期化 |

@BeforeClass アノテーションを付与したメソッドは、 static である必要があります。 ( 【参考】 @Before アノテーションを付与したメソッドは、 static としてはいけません。)

```java
@BeforeClass
public static void setUpClass() throws Exception {
    // JDBC ドライバの読み込み
    Class.forName("com.mysql.jdbc.Driver");
}
```


## @AfterClass

@AfterClass を付与した事後処理メソッドは、対象のテストクラス内のすべてのテストメソッドが実行された後に、 1 回だけ実行する処理に使用します。








