- [02.テストケースの整理](#02テストケースの整理)
  - [テストケースをグループ化する](#テストケースをグループ化する)
  - [Enclosed によるテストクラスの構造化](#enclosed-によるテストクラスの構造化)


# 02.テストケースの整理

## テストケースをグループ化する

例えば、商品の在庫を管理する ItemStock インターフェースに対するテストコードを整理することを考えます。

```java
public interface ItemStock {

    /**
     * 商品と数量を指定して追加する.
     * 
     * @param item 商品名
     * @param num 追加する数量
     */
    viod add(String item, int num);

    /**
     * 商品を指定して、商品の在庫数を返す.
     * 
     * @param item 商品名
     * @return 在庫数。登録されていない場合は 0 。
     */
    int size(String item);

    /**
     * 商品の在庫が残っている場合に true を返す.
     * 
     * @param item 商品名
     * @return 在庫が 1 以上の場合に true 。
     */
    boolean contains(String item);
}
```

このインターフェースに対するテストケースを次のように抽出したとします。

- ItemStock が初期状態のとき、 size に商品 A を指定すると 0 を返す。
- ItemStock が初期状態のとき、 contains に商品 A を指定すると false を返す。
- ItemStock が初期状態のとき、 add で商品 A を 1 追加すると、商品 A の size が 1 を返す。
- ItemStock に商品 A が 1 個含まれるとき、 size に商品 A を指定すると 1 を返す。
- ItemStock に商品 A が 1 個含まれるとき、 contains に商品 A を指定すると true を返す。
- ItemStock に商品 A が 1 個含まれるとき、 add で商品 A を 1 追加すると、商品 A の size が 2 を返す。

これを共通の初期化処理によってグループ化すると、 ItemStock が 「初期状態」 の場合と、 「商品 A が 1 個含まれる」 場合に分けることができます。


## Enclosed によるテストクラスの構造化

- Enclosed テストランナーを指定する
  - 外側のクラスのテストランナーに Enclosed クラスを指定すると、その中にネストされたクラスは、テストクラスであるとみなされます。
- クラスの命名規則
  - 外側のクラスのクラス名は、通常の命名規則にしたがって、 「テスト対象クラス + Test 」 とします。
  - ネストされたクラスのクラス名は、前提条件を表す名前にします。
- 事前準備が共通のテストケースを各ネストされたクラスにまとめます。
- 仕様書としての価値
  - Enclosed でグループ化されたテストクラスは、 Android Studio の 「クラスの構造表示」 機能で表示した際に、テスト対象クラスの仕様書として十分に役に立つドキュメントとなります。

```java
@RunWith(Enclosed.class)
public class ItemStockTest {

    public static class 空の場合 {
    
        ItemStock sut;

        @Before
        public void setUp() throws Exception {
            sut = new ItemStockImpl();
        }

        @Test
        public void size_Aが0を返す() throws Exception {
            assertThat(sut.size("A"), is(0));
        }

        @Test
        public void contains_Aはfalseを返す () throws Exception {
            assertThat(sut.contains("A"), is(false))
        }
    }

    public static class 商品Aを1件含む場合 {
    
        ItemStock sut;

        @Before
        public void setUp() throws Exception {
            sut = new ItemStockImpl();
            sut.add("A", 1);
        }

        @Test
        public void size_Aが1を返す() throws Exception {
            assertThat(sut.size("A"), is(1));
        }

        @Test
        public void contains_Aはtrueを返す () throws Exception {
            assertThat(sut.contains("A"), is(true))
        }
    }
}
```







