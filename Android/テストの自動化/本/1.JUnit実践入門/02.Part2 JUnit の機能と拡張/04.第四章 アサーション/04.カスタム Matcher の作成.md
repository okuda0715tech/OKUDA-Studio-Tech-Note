- [04.カスタム Matcher の作成](#04カスタム-matcher-の作成)
  - [例 : Date オブジェクトの検証](#例--date-オブジェクトの検証)
    - [カスタム Matcher の定義](#カスタム-matcher-の定義)
    - [テストコード](#テストコード)
    - [実行結果](#実行結果)
  - [エラーメッセージ](#エラーメッセージ)
    - [フォーマット](#フォーマット)
    - [appendValue() と appendText() の違い](#appendvalue-と-appendtext-の違い)


# 04.カスタム Matcher の作成

カスタム Matcher を作成する際の主なポイントは、以下の 2 点です。

- BaseMatcher を継承したクラスを定義します。
- 定義したクラスで以下の 2 つのメソッドをオーバーライドします。
  - matches(Object) : 独自の検証内容を実装します。
  - describeTo(Description) : エラー時のメッセージをカスタマイズします。


## 例 : Date オブジェクトの検証

ここでは、 Date 型のオブジェクトの日付部分 (年月日) のみが期待通りの値になっているかどうかを検証する例を示します。つまり、時分秒は検証の対象外とします。


### カスタム Matcher の定義

```java
/**
 * カスタム Matcher の定義.
 * 
 * BaseMatcher クラスを継承します。
 * BaseMatcher の型パラメータには、実測値の型を指定します。
 */
public class IsDate extends BaseMatcher<Date> {

    // 期待値
    private final int yyyy;
    private final int mm;
    private final int dd;
    // 実測値
    Object actual;

    IsDate(int yyyy, int mm, int dd) {
        this.yyyy = yyyy;
        this.mm = mm;
        this.dd = dd;
    }

    /**
     * 検証で実行する処理内容を定義する.
     * 
     * @param actual 実測値が渡されてくる。
     * @return true を返した場合はテスト成功、 false を返した場合は失敗となります。
     */
    @Override
    public boolean matches(Object actual) {
        // 親のフィールドで保持
        this.actual = actual;
        
        // 型をチェック
        if (!(actual instanceOf Date)) false;

        Calendar cal = Calendar.getInstance();
        cal.setTime((Date) actual);

        // 各フィールドを検証する
        if (yyyy != cal.get(Calendar.YEAR)) return false;
        if (mm != cal.get(Calendar.MONTH) + 1) return false;
        if (dd != cal.get(Calendar.DATE)) return false;

        // 問題なければ true を返す
        return true;
    }

    /**
     * テストに失敗した場合に出力するメッセージを定義します。
     * 
     * パラメータで渡されてくる Description オブジェクトに、
     * 出力したいメッセージを追加していきます。
     * エラーメッセージについての詳細は、後述のセクションで説明します。
     * 
     * @param desc エラーメッセージの出力に使用される Description オブジェクト
     */
    @Override
    public void describeTo(Description desc) {
        desc.appendValue(String.format("%d/%02d/%02d", yyyy, mm, dd));
        if (actual != null) {
            desc.appendText(" but actual is ");
            desc.appendValue(
                new SimpleDateFormat("yyyy/MM/dd").format((Date) actual)
            );
        }
    }

    /**
     * Matcher を返すファクトリーメソッド.
     * 
     * assertThat() メソッドの第二引数に値を渡す際に使用するメソッドです。
     * 
     * プロジェクト内で、複数のカスタム Matcher を作成する場合には、
     * ファクトリーメソッドを一つのクラス内にまとめて定義すると良いでしょう。
     * 
     * Matcher API は、 static インポートで利用すると、
     * 自然言語のように読めるテストコードが生成できるため、
     * static インポートするのが一般的です。
     * そのため、このメソッドも static メソッドとなっています。
     * ( static インポートは、クラス名の記述無しで static なメンバーを参照するテクニックです。)
     * 
     * @param 期待値
     */
    public static Matcher<Date> dateOf(int yyyy, int mm, int dd) {
        return new IsDate(yyyy, mm, dd)
    }
}
```


### テストコード

テストコードは次の通りです。

```java
@Test
public void 日付の比較() throws Exception {
    Date actual = new Date();
    assertThat(actual, is(dateOf(2011, 2, 10)));
}
```


### 実行結果

この例では、次のようなエラーが出力されます。

```
java.lang.AssertionError:
    Expected: is "2011/02/10" but actual is "2025/01/30"
        got: <Thu Jan 30 18:08:59 JST 2025>
```


## エラーメッセージ

### フォーマット

assertThat() メソッドが失敗した場合のメッセージは、次のようなフォーマットで出力されます。

```
java.lang.AssertionError:
    Expected: is <<Description オブジェクトの文字列表記>>
        got: <<実測値の toString() で返される文字列>>
```

デフォルトのフォーマットでは、 `Expected: ～` の行に期待値を表示し、 `got: ～` の行に実測値を表示することが想定されています。

ただし、上記の Date の検証の例では、 Date を toString() で文字列を表示した場合に、期待値のフォーマット (yyyy/mm/dd) と実測値のフォーマット (yyyy/mm/dd ではない) が異なるため、ログの確認がしづらい状況となってしまいます。そのため、あえて、実測値のフォーマットを期待値に合わせた上で、 Expected: の行に実測値を yyyy/mm/dd で表示するようにしています。


### appendValue() と appendText() の違い

`Description.appendValue()` メソッドは、その引数に与えられた文字列を、ダブルクォーテーションで囲んだ文字列をログに出力します。そのため、実測値と期待値のようなデータには、 appendValue() メソッドを使用するのが良いでしょう。

一方で、 Description.appendText() メソッドは、その引数に与えられた文字列を、そのままログに出力します。そのため、期待値や実測値のような、データではない単なる文字列を出力するのに使用すると良いです。



