- [01.テスタビリティを高めるリファクタリング](#01テスタビリティを高めるリファクタリング)
  - [メソッドの抽出](#メソッドの抽出)
  - [委譲オブジェクトの抽出](#委譲オブジェクトの抽出)
    - [インターフェース化した例](#インターフェース化した例)


# 01.テスタビリティを高めるリファクタリング

## メソッドの抽出

以下のテスト対象クラスがあったとします。

```java
public class MethodExtractExample() {

    Date date = new Date();

    public void doSomething() {
        this.date = new Date();
        // 何らかの処理を行う。
    }

}
```

`new Date()` の部分をメソッドに抽出すると、以下のようになります。

```java
public class MethodExtractExample() {

    Date date = newDate();

    public void doSomething() {
        this.date = newDate();
        // 何らかの処理を行う。
    }

    Date newDate() {
        return new Date();
    }

}
```

以下のコードを見てください。メソッドに抽出したことによって、 `newDate()` メソッドの挙動を、テストコード側で変更できるようになったことがわかります。

```java
public class MethodExtractExampleTest {

    @Test
    public void doSomethingを実行するとdateに現在時刻が設定される() throws Exception {
        final Date current = new Date();
        MethodExtractExample sut = new MethodExtractExample() {
            @Override
            Date newDate() {
                return current;
            }
        };
        sut.doSomething();
        assertThat(sut.date, is(sameInstance(current)));
    }
}
```

このテクニックを使用することによって、後ほど説明する 「スタブ」 の実装が可能になります。


## 委譲オブジェクトの抽出

この方法は、先ほどの 「メソッド抽出」 の方法と似ていますが、異なる点は、 「テストコードで挙動を変更したいメソッドを、外部のクラスに定義し、そのオブジェクトをフィールドに保持する」 という点です。外部クラスを定義することで、様々なクラスから再利用可能になる点がメリットだと思われます。

ここでも、メソッドの抽出と同じ例を取り上げます。

`newDate()` メソッドは、先ほどは、 `MethodExtractExample` クラスに定義されていました。しかし、今回は別のクラス ( `DateFactory` ) に定義します。

```java
public class DateFactory() {
    Date newDate() {
        return new Date();
    }
}
```

テスト対象クラスで、上記の DateFactory クラスを利用する方法を以下に記載します。

```java
public class DelegateObjectExample {

    // テストコードで置き換えたいメソッドを持った外部クラスを
    // テスト対象クラスのフィールドに保持します。
    DateFactory dateFactory = new DateFactory();

    Date date = new Date();

    public void doSomething() {
        this.date = dateFactory.newDate();
        // 何らかの処理を実行する。
    }
}
```

このテスト対象クラスをテストするテストクラスは、以下のようになります。

```java
public class DelegateObjectExampleTest() {
    @Test
    public void doSomethingを実行するとdateに現在時刻が設定される() throws Exception {
        
        final Date current = new Date();
        DelegateObjectExample sut = new DelegateObjectExample();
        // テスト用にカスタマイズしたメソッドを持つオブジェクトで、 SUT のフィールドを更新します。
        sut.dateFactory = new DateFactory() {
            // テストコードで、 newDate() メソッドをカスタマイズできる。
            @Override
            public Date newDate() {
                return current;
            }
        }
    }
}
```


### インターフェース化した例

上記の 「委譲オブジェクトの抽出」 で取り上げた例を、インターフェースを使用して書き換えた例を以下に示します。

インターフェース化を行うと、若干コード量が増えます。インターフェース化するかどうかは、よく考えて決めましょう。

```java
// インターフェースの定義
public interface DateFactory {
    Date newDate();
}
```

```java
// インターフェースを実装
//
// ここでは、テスト対象クラスで使用するデフォルトの実装を提供します。
public class DateFactoryImpl implements DateFactory {
    @Override
    public Date newDate() {
        return new Date();
    }
}
```

```java
// テスト対象クラスの実装
public class DelegateObjectExample {

    // テスト対象クラスでは、フィールドの初期化時に
    // デフォルトの実装を行っているオブジェクトを渡します。
    DateFactory dateFactory = new DateFactoryImpl();
    Date date = new Date();

    public void doSomething() {
        this.date = dateFactory.newDate();
    }
}
```

テストコードは、上記の 「委譲オブジェクトの抽出」 で示したテストコードのように、オーバーライドしたオブジェクトを、 dateFactory フィールドに渡します。



