- [Android での Kotlin Flow](#android-での-kotlin-flow)
  - [Flow の作成](#flow-の作成)
  - [ストリームの変更（中間演算子の使用）](#ストリームの変更中間演算子の使用)
  - [Flow からの収集](#flow-からの収集)
  - [予期しない例外のキャッチ](#予期しない例外のキャッチ)
  - [別の CoroutineContext での実行](#別の-coroutinecontext-での実行)
  - [Jetpack ライブラリの Flow](#jetpack-ライブラリの-flow)
  - [コールバックベースの API を Flow に変換する](#コールバックベースの-api-を-flow-に変換する)


# Android での Kotlin Flow

Flow は、 Kotlin の機能で、複数の値を生成される度に一つ一つ取得する方法です。 Flow は、ある値を取得してから、次の値が生成されるまでの間、スレッドをブロックすることはありません。

Flow のデータストリームには、以下の 3 つのエンティティがあります。

- プロデューサ
  - ストリームに出力するデータを生成します。コルーチンであるため、Flow は非同期にデータを生成できます。
- インターミディアリ (任意)
  - ストリームに出力された各値、または、ストリームそのものを変更する役割があります。
- コンシューマ
  - ストリームから得られた値を使用します。

<img src="./画像/データストリームに含まれるエンティティ.png" width="600">

Android の場合、通常は 「リポジトリ」 が UI データのプロデューサで、最終的にデータを表示するユーザーインターフェース ( UI ) を備えています。また、 UI レイヤがユーザー入力イベントのプロデューサとなり、その他のレイヤがコンシューマになる場合もあります。プロデューサとコンシューマの間のレイヤは通常、後続レイヤの要件に合わせてデータストリームを変更するインターミディアリとして機能します。


## Flow の作成

Flow は、 flow ビルダーで作成し、 emit 関数で結果を発行します。

次の例では、データソースが最新のニュースを一定間隔で自動的に取得します。suspend 関数は複数の値を続けて返せないため、データソースはそれが可能な Flow を作成して返します。ここでは、データソースがプロデューサの役割を果たしています。

```kotlin
class NewsRemoteDataSource(
    private val newsApi: NewsApi,
    private val refreshIntervalMs: Long = 5000
) {
    val latestNews: Flow<List<ArticleHeadline>> = flow {
        while(true) {
            val latestNews = newsApi.fetchLatestNews()
            // 結果を発行します。
            emit(latestNews)
            // コルーチンをしばらく一時停止します。
            delay(refreshIntervalMs)
        }
    }
}

// suspend 関数でネットワークリクエストを行う手段を提供するインターフェース
interface NewsApi {
    suspend fun fetchLatestNews(): List<ArticleHeadline>
}
```

次の点に注意してください。

flow ビルダーを使用して、プロデューサが別の CoroutineContext から値を emit することはできません。したがって、新しいコルーチンを作成したり、 withContext コードブロックを使用したりすることで、別の CoroutineContext で emit を呼び出さないでください。この場合、 [callbackFlow](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html) などの他のフロービルダーを使用できます。


## ストリームの変更（中間演算子の使用）

インターミディアリは中間演算子を使うことで、値を使用することなくデータストリームを変更できます。この演算子は、データストリームに一連のオペレーションを設定する関数ですが、そのオペレーションは値を使用するときまで実行されません。

次の例では、リポジトリレイヤで中間演算子 map を使用して、View に表示されるデータを変換します。

```kotlin
class NewsRepository(
    private val newsRemoteDataSource: NewsRemoteDataSource,
    private val userData: UserData
) {
    val favoriteLatestNews: Flow<List<ArticleHeadline>> =
        newsRemoteDataSource.latestNews
            .map { news -> news.filter { userData.isFavoriteTopic(it) } }
            .onEach { news -> saveInCache(news) }
}
```

中間演算子を順次適用して、アイテムが Flow に出力された場合に遅延実行される一連のオペレーションを形成できます。なお、中間演算子をストリームに適用するだけでは、Flow の収集は開始されません。


## Flow からの収集

Flow をトリガーして値のリッスンを開始するには、末端演算子を使用します。ストリーム内のすべての値を出力されたとおりに収集するには、 collect を使用します。

collect は suspend 関数であるため、コルーチン内で実行する必要があります。パラメータとしてラムダを取り、収集した値ごとに呼び出されます。また、 suspend 関数であるため、 collect を呼び出すコルーチンは Flow が終了するまで停止することがあります。

上記の例の続きとして、リポジトリレイヤからのデータを使用する ViewModel の簡単な実装例を次に示します。

```kotlin
class LatestNewsViewModel(
    private val newsRepository: NewsRepository
) : ViewModel() {

    init {
        viewModelScope.launch {
            // collect で、要素を取得します。
            newsRepository.favoriteLatestNews.collect { favoriteNews ->
                // 最新の favoriteNews で UI を更新します。
            }
        }
    }
}
```

Flow の collect 関数を実行するとプロデューサがトリガーされ、一定間隔で最新ニュースを更新してネットワークリクエストの結果を出力します。プロデューサは while(true) ループで常にアクティブなため、データストリームが終了するのは ViewModel が破棄されて viewModelScope がキャンセルされたときです。

Flow の収集は、次の場合に停止する可能性があります。

- 上記の例に示したように、収集中のコルーチンをキャンセルした場合。これにより、収集元のプロデューサも停止します。
- プロデューサがアイテムの出力を終了した場合。この場合はデータ ストリームが終了し、collect を呼び出したコルーチンの後続処理が再開します。

他の中間演算子で指定しない限り、 Flow は 「コールド」 かつ 「遅延」 となります。つまり、 Flow の末端演算子が呼び出されるたびにプロデューサコードが実行されることになります。上記の例では、複数の Flow コレクタがあると、データソースによる一定間隔での最新ニュース取得がさまざまなタイミングで行われます。複数のコンシューマが同時に収集を行う Flow を最適化して共有するには、 shareIn 演算子を使用します。


## 予期しない例外のキャッチ

プロデューサの実装は、サードパーティ ライブラリのものである場合があります。つまり、予期しない例外がスローされる可能性があります。これらの例外を処理するには、 catch 中間演算子を使用します。

```kotlin
class LatestNewsViewModel(
    private val newsRepository: NewsRepository
) : ViewModel() {

    init {
        viewModelScope.launch {
            newsRepository.favoriteLatestNews
                // catch 中間演算子
                // 例外がスローされたら、キャッチして UI を更新します。
                .catch { exception -> notifyError(exception) }
                .collect { favoriteNews ->
                    // 最新の favoriteNews で UI を更新します。
                }
        }
    }
}
```

上記の例では、例外が発生した場合、新しいアイテムをまだ受け取っていないため、 collect ラムダは呼び出されません。

catch を使用してアイテムを Flow に emit することもできます。次の例のリポジトリ レイヤは、代わりにキャッシュに保存された値を emit します。

```kotlin
class NewsRepository(...) {
    val favoriteLatestNews: Flow<List<ArticleHeadline>> =
        newsRemoteDataSource.latestNews
            .map { news -> news.filter { userData.isFavoriteTopic(it) } }
            .onEach { news -> saveInCache(news) }
            // エラーが発生した場合は、最新のキャッシュを発行します。
            .catch { exception -> emit(lastCachedNews()) }
}
```

この例では、例外が発生すると、それにより新しいアイテムがストリームに出力されて、 collect ラムダが呼び出されます。


## 別の CoroutineContext での実行

デフォルトでは、 flow ビルダーのプロデューサは収集を行うコルーチンの CoroutineContext で実行され、前述のとおり、別の CoroutineContext から値を emit することはできません。ただ、これが適切でない場合もあります。たとえば、このトピック全体を通して使用している例では、リポジトリレイヤは、 viewModelScope が使用する Dispatchers.Main でオペレーションを実行しません。

Flow の CoroutineContext を変更するには、中間演算子 flowOn を使用します。 flowOn は、 「アップストリーム Flow」 (つまり、flowOn の 「前または上位」 に適用されるプロデューサとすべての中間演算子) の CoroutineContext を変更します。 「ダウンストリーム Flow」 ( flowOn の 「後」 の中間演算子およびコンシューマ) は影響を受けず、その Flow からの collect に使用される CoroutineContext で実行されます。 flowOn 演算子が複数ある場合は、それぞれが現在の場所から見たアップストリームを変更します。

```kotlin
class NewsRepository(
    private val newsRemoteDataSource: NewsRemoteDataSource,
    private val userData: UserData,
    private val defaultDispatcher: CoroutineDispatcher
) {
    val favoriteLatestNews: Flow<List<ArticleHeadline>> =
        newsRemoteDataSource.latestNews
            .map { news -> // defaultDispatcher で実行される
                news.filter { userData.isFavoriteTopic(it) }
            }
            .onEach { news -> // defaultDispatcher で実行される
                saveInCache(news)
            }
            // flowOn は、アップストリーム ( ↑ ) の Flow に影響を与える
            .flowOn(defaultDispatcher)
            // ダウンストリーム ( ↓ ) の Flow には影響を与えない 
            .catch { exception -> // コンシューマーのコンテキストで実行される
                emit(lastCachedNews())
            }
}
```

このコードでは、 onEach 演算子と map 演算子は defaultDispatcher を使用しますが、 catch 演算子とコンシューマは viewModelScope が使用する Dispatchers.Main で実行されます。

データソースレイヤは I/O オペレーションを行うため、次のようにして I/O オペレーションに最適化されたディスパッチャを使用します。

```kotlin
class NewsRemoteDataSource(
    ...,
    private val ioDispatcher: CoroutineDispatcher
) {
    val latestNews: Flow<List<ArticleHeadline>> = flow {
        // IO dispatcher 上で実行します。
        ...
    }
        .flowOn(ioDispatcher)
}
```


## Jetpack ライブラリの Flow

Flow は多くの Jetpack ライブラリと統合されており、 Android サードパーティ ライブラリでも広く使用されています。 Flow は、リアルタイムのデータ更新やエンドレスのデータ ストリームに適しています。

Room によるフローを使用して、データベースの変更について通知を受けることができます。データアクセスオブジェクト ( DAO ) を使用する場合は、 Flow 型を返すことでリアルタイムに更新データを取得できます。

```kotlin
@Dao
abstract class ExampleDao {
    @Query("SELECT * FROM Example")
    abstract fun getExamples(): Flow<List<Example>>
}
```

Example テーブルが変更されるたびに、データベース内の新しいアイテムを含む新しいリストが出力されます。


## コールバックベースの API を Flow に変換する

[callbackFlow](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html) は、コールバック ベースの API をフローに変換できるフロービルダーです。たとえば、少し前までは、 Firebase Firestore Android API は、コールバックを使用する API でした。 (最新のバージョンの firebase-ktx には、 Flow を返す snapshots() 拡張機能が含まれています。)

次のコードを使用すると、以前のコールバック形式の API を Flow に変換して Firestore データベースの更新をリッスンできます。

```kotlin
class FirestoreUserEventsDataSource(
    private val firestore: FirebaseFirestore
) {
    // Firestore database からユーザーイベントを取得する関数
    fun getUserEvents(): Flow<UserEvents> = callbackFlow {

        // Firestore のインスタンスへの参照
        var eventsCollection: CollectionReference? = null
        try {
            eventsCollection = FirebaseFirestore.getInstance()
                .collection("collection")
                .document("app")
        } catch (e: Throwable) {
            // Firebaseを初期化できない場合は、データフローのストリームを閉じて、
            // コンシューマーは収集を停止し、コルーチンが再開されます。
            close(e)
        }

        // 新しいイベントで呼ばれる firestore のコールバックを登録する
        val subscription = eventsCollection?.addSnapshotListener { snapshot, _ ->
            if (snapshot == null) { return@addSnapshotListener }
            // flow にイベントを贈り、コンシューマーは新しいイベントを受け取ります。
            try {
                offer(snapshot.getEvents())
            } catch (e: Throwable) {
                // イベントが flow に送信されなかった場合
            }
        }

        // flow が閉じられたかキャンセルされたとき、 awaitClose 内のコールバックが実行されます。
        // この場合、 Firestore からコールバックを削除します。
        awaitClose { subscription?.remove() }
    }
}
```

内部的には、 callbackFlow はチャネルを使用します。そのため、 flow ビルダーとは異なり、 callbackFlow では、 [send](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html) 関数を使用して別の CoroutineContext から、または [trySend](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/try-send.html) 関数を使用してコルーチンの外部から、値を出力できます。

callbackFlow で作成されるチャネルのデフォルトの容量は 64 要素です。空きのないチャネルに要素を追加しようとした場合、 send はプロデューサを停止して空きができるまで待ちますが、 offer は要素をチャネルに追加せずにすぐ false を返します。






