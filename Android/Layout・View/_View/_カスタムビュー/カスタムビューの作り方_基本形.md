- [基本的なカスタムビューの作り方](#基本的なカスタムビューの作り方)
  - [1. 既存の何かの View を継承する](#1-既存の何かの-view-を継承する)
  - [2. カスタム属性を定義する](#2-カスタム属性を定義する)
  - [3. 定義したカスタム属性をレイアウト xml 内で使用する](#3-定義したカスタム属性をレイアウト-xml-内で使用する)
    - [カスタム View が、あるクラスの内部クラスの場合は、 `$` 記号でつなげます。](#カスタム-view-があるクラスの内部クラスの場合は--記号でつなげます)
  - [4. カスタム属性にセットされた値を読み取って View に設定する](#4-カスタム属性にセットされた値を読み取って-view-に設定する)
  - [5. プロパティとイベントを追加する](#5-プロパティとイベントを追加する)


# 基本的なカスタムビューの作り方

## 1. 既存の何かの View を継承する

最低限、 `Context` オブジェクトと `AttributeSet` オブジェクトをパラメータとして取る  
コンストラクタを用意する必要があります。

このコンストラクタにより、 Layout Editor でビューのインスタンスを作成、編集することが可能になります。


## 2. カスタム属性を定義する

カスタム属性の定義は、一般的に `values/attrs.xml` ファイルに定義します。

```xml
<resources>
    <!-- declare-styleable タグは、 attr タグのスコープをその内部だけに限定する役割がある。 -->
    <!-- name 属性の値は、一般的には、カスタム View のクラス名と同じに設定します。 -->
    <declare-styleable name="PieChart">
        <!-- name 属性は、カスタム View で使用したい属性の名前を設定する。 -->
        <attr name="showText" format="boolean" />
        <attr name="labelPosition" format="enum">
            <enum name="left" value="0"/>
            <enum name="right" value="1"/>
        </attr>
    </declare-styleable>
</resources>
```


## 3. 定義したカスタム属性をレイアウト xml 内で使用する

属性名が既存の属性名と重複するのを避けるために、独自の名前空間を定義します。  
名前空間は `http://schemas.android.com/apk/res/[your package name]` とします。

名前空間以外は既存の属性との違いはなく、既存の属性と同様に使用することができます。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- 独自の名前空間を定義します。 -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:custom="http://schemas.android.com/apk/res/com.example.customviews">

    <!-- View の名前は完全修飾名を指定する必要がある -->
    <com.example.customviews.charting.PieChart
        custom:showText="true"
        custom:labelPosition="left" />

</LinearLayout>
```

### カスタム View が、あるクラスの内部クラスの場合は、 `$` 記号でつなげます。

例えば、 PieChart クラスの中に、 PieView という内部クラスがあるとします。  
このクラスのカスタム属性を使用する場合は、 `$` 記号でつなげます。

公式ドキュメントには 2 種類の実装方法が載っており、どちらが正しいのか、  
あるいはどちらも正しいのかわからないので、試してみる必要があります。

**方法 1**

`<com.example.customviews.charting.PieChart$PieView>` というタグを使用します。

```xml
    <com.example.customviews.charting.PieChart$PieView
        custom:showText="true"
        custom:labelPosition="left" />
```

**方法 2**

タグは `<view>` にします。  
さらに、 `class` 属性で `$` 記号を使用して内部クラスを指定します。

```xml
    <view class="com.example.customviews.charting.PieChart$PieView"
        custom:showText="true"
        custom:labelPosition="left"  />
```


## 4. カスタム属性にセットされた値を読み取って View に設定する

**Javaサンプル**

```java
    public PieChart(Context context, AttributeSet attrs) {
        super(context, attrs);
        // 直接 AttributeSet にアクセスしてしまうとスタイルが適用されていないため、
        // obtainStyledAttributes() メソッドを介して値を取得します。
        TypedArray a = context.getTheme().obtainStyledAttributes(
            attrs,
            R.styleable.PieChart,
            0, 0);

        try {
            mShowText = a.getBoolean(R.styleable.PieChart_showText, false);
            textPos = a.getInteger(R.styleable.PieChart_labelPosition, 0);
        } finally {
            // TypedArray オブジェクトは共有リソースであり、使用後にリサイクルする必要があります。
            a.recycle();
        }
    }
```

**Kotlinサンプル**

```kotlin
    init {
        // 直接 AttributeSet にアクセスしてしまうとスタイルが適用されていないため、
        // obtainStyledAttributes() メソッドを介して値を取得します。
        context.theme.obtainStyledAttributes(
                attrs,
                R.styleable.PieChart,
                0, 0).apply {

            try {
                mShowText = getBoolean(R.styleable.PieChart_showText, false)
                textPos = getInteger(R.styleable.PieChart_labelPosition, 0)
            } finally {
                // TypedArray オブジェクトは共有リソースであり、使用後にリサイクルする必要があります。
                recycle()
            }
        }
    }
```


## 5. プロパティとイベントを追加する

属性はビューの動作と外観を制御するための強力な方法ですが、  
属性を読み取ることができるのはビューが初期化されたときだけです。

動的な動作を実現するには、各カスタム属性のプロパティゲッターとプロパティセッターのペアを準備します。

```java
    public boolean isShowText() {
       return mShowText;
    }

    public void setShowText(boolean showText) {
       mShowText = showText;
       // 外観を変える可能性があるプロパティを変更した後は、ビューを再描画する必要がある。
       // (基本的に必須と思って問題ないはず。)
       invalidate();
       // ビューのサイズまたは形状に影響する可能性があるプロパティを変更したときは、
       // 新しいレイアウトをリクエストする必要がある。
       // (基本的に必須と思って問題ないはず。)
       requestLayout();
    }
```

```kotlin
    fun isShowText(): Boolean {
        return mShowText
    }

    fun setShowText(showText: Boolean) {
        mShowText = showText
        // 外観を変える可能性があるプロパティを変更した後は、ビューを再描画する必要がある。
        // (基本的に必須と思って問題ないはず。)
        invalidate()
        // ビューのサイズまたは形状に影響する可能性があるプロパティを変更したときは、
        // 新しいレイアウトをリクエストする必要がある。
        // (基本的に必須と思って問題ないはず。)
        requestLayout()
    }
```

また、必要に応じて `OnItemChanged()` のようなイベントリスナーを実装し、  
外部のクラスに公開する必要があります。


