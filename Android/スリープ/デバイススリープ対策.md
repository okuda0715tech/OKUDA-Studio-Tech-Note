<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [デバイススリープ対策](#デバイススリープ対策)
	- [スリープとは](#スリープとは)
	- [時間が経過しても画面が真っ暗にならないようにする方法](#時間が経過しても画面が真っ暗にならないようにする方法)
	- [画面が真っ暗になってもCPUを動かし続ける方法](#画面が真っ暗になってもcpuを動かし続ける方法)
		- [Service を BroadcastReceiver "以外" から起動する場合](#service-を-broadcastreceiver-以外-から起動する場合)
		- [Service を BroadcastReceiver から起動する場合](#service-を-broadcastreceiver-から起動する場合)
<!-- TOC END -->


# デバイススリープ対策

## スリープとは

デバイスがスリープするとは、一般的には **画面が真っ暗になる状態** のことを指しますが、  
アプリ開発者の観点で見ると、さらに、 **CPUが動いている状態** と **動いていない状態** の  
二つの状態にわけることができます。  
特に、 **CPUが動いていない状態** を公式ドキュメントでは **デバイスのアイドル状態** と言うことがあります。

つまり、開発者としては、以下の三つの場合を考える必要があります。

- 画面に何らかの表示がなされている状態 (画面に表示しているためCPUは動いている)
- 画面が真っ暗で、かつ、CPUが動いている状態
- 画面が真っ暗で、かつ、CPUが動いていない状態


## 時間が経過しても画面が真っ暗にならないようにする方法

ここに示す方法を使用すると、時間が経過しても画面が真っ暗になることがなく、画面の表示を継続することができます。

```java
// 動的に設定する場合
public class MainActivity extends Activity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    // この一行を追加する
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  }
}
```

```xml
<!-- 静的に設定する場合 -->
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:keepScreenOn="true">
  ...
</RelativeLayout>
```

ここに示した方法は、設定したアプリがフォアグラウンドになっている状態でのみ有効です。  
つまり、他のアプリに切り替えた場合は、時間が経過するといずれ画面が真っ暗な状態になります。  
また、他のアプリから自分のアプリに切り替えた場合は、いくら時間が経過しても画面は真っ暗にはなりません。


## 画面が真っ暗になってもCPUを動かし続ける方法

画面が真っ暗になってもCPUを動かし続けるには、 `PowerManager` の `WakeLock` を使用します。

実装の方法は、以下の二つのどちらの場合に該当するかによって、異なります。

- BroadcastReceiverからServiceを起動する場合
- BroadcastReceiver以外からServiceを起動する場合

ただし、いづれの場合もマニフェストに以下の記述をする必要があります。

```xml
<uses-permission android:name="android.permission.WAKE_LOCK" />
```


### Service を BroadcastReceiver "以外" から起動する場合

`Service` 内で以下のようにして `WakeLock` の取得と解放を行います。

```java
PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);
WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
        "MyApp::MyWakelockTag");

// WakeLockの取得
wakeLock.acquire();

// WakeLockの解放
wakeLock.release();
```

解放し忘れることがないように注意してください。


### Service を BroadcastReceiver から起動する場合

以下の方法は、`Android Oreo`のバックグラウンドサービスの実行制限に抵触する恐れがあるため、  
`WakefulBroadcastReceiver` は deprecated となりました。  
代わりに `JobScheduler` の使用が推奨されています。  
`JobScheduler` は、タスクの実行中の `WakeLock` を管理してくれるため、開発者が  
`WakeLock` のことを気にする必要はありません。

`IntentService` にのみ対応しています。  
`WakefulBroadcastReceiver` を使用することで、 `IntentService` 側でロックを解放するまで、  
`WakeLock` を取得し続けます。ロックの解放忘れに注意しましょう。

```java
// WakefulBroadcastReceiverクラスを継承したBroadcastReceiverを作成します。
public class MyWakefulReceiver extends WakefulBroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Intent service = new Intent(context, MyIntentService.class);
        // startService()メソッドの代わりにstartWakefulService()メソッドを使用します。
        // WakeLockを取得したサービスを開始します。
        startWakefulService(context, service);
    }
}
```

```java
public class MyIntentService extends IntentService {

    public static final int NOTIFICATION_ID = 1;
    private NotificationManager notificationManager;
    NotificationCompat.Builder builder;

    public MyIntentService() {
        super("MyIntentService");
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        Bundle extras = intent.getExtras();
        // サービスで実行したい何らかの処理
        // ...
        // ロックを解放する
        MyWakefulReceiver.completeWakefulIntent(intent);
    }
}
```
