- [ローカル単体テストを作成する](#ローカル単体テストを作成する)
  - [ローカルテストの場所](#ローカルテストの場所)
  - [テスト用の依存関係の追加](#テスト用の依存関係の追加)
  - [ローカル単体テストクラスを作成する](#ローカル単体テストクラスを作成する)
  - [モック可能な Android ライブラリ](#モック可能な-android-ライブラリ)
    - [Android 依存関係のモック](#android-依存関係のモック)
    - [エラー: 「Method ... not mocked」](#エラー-method--not-mocked)


# ローカル単体テストを作成する

ローカルテストは、Android デバイスやエミュレータではなく、独自のワークステーションで直接実行されます。そのため、Android デバイスではなく、ローカルの Java 仮想マシン（JVM）を使用してテストを実行します。ローカルテストを使用すると、アプリのロジックをより迅速に評価できます。ただし、Android フレームワークを操作できないため、実行できるテストの種類に制限があります。

単体テストでは、コードの小さなセクション（テスト対象ユニット）の動作を検証します。この処理は、該当するコードを実行して結果をチェックすることで行われます。

通常、単体テストはシンプルですが、テスト対象ユニットがテストのしやすさを念頭に置いて設計されていない場合、セットアップに問題が生じる可能性があります。

- 確認するコードは、テストからアクセス可能である必要があります。たとえば、プライベート メソッドを直接テストすることはできません。代わりに、公開 API を使用してクラスをテストします。
- 単体テストを独立して実行するには、テスト対象の単体テストの依存関係を、フェイクやその他のテストダブルなど、管理対象コンポーネントに置き換える必要があります。これは、コードが Android フレームワークに依存している場合は特に問題になります。
Android での一般的な単体テスト戦略については、 [テスト項目](../2.基本/2.Android%20でのテスト項目.md) をご覧ください。


## ローカルテストの場所

デフォルトでは、ローカル単体テストのソースファイルは module-name/src/test/ に配置されています。Android Studio で新しいプロジェクトを作成するときに、このディレクトリは、自動的に生成されます。


## テスト用の依存関係の追加

また、 [JUnit](https://junit.org/junit5/) テストフレームワークによって提供される標準 API を使用するように、プロジェクトのテスト依存関係を構成する必要があります。

これを行うには、アプリのモジュールの build.gradle ファイルを開き、次のライブラリを依存関係として指定します。 `testImplementation` 関数を使用して、それらがアプリではなく、ローカルのテストソースセットに適用されることを示します。

```gradle
dependencies {
    // Required -- JUnit 4 framework
    testImplementation "junit:junit:$jUnitVersion"
    // Optional -- Robolectric environment
    testImplementation "androidx.test:core:$androidXTestVersion"
    // Optional -- Mockito framework
    testImplementation "org.mockito:mockito-core:$mockitoVersion"
    // Optional -- mockito-kotlin
    testImplementation "org.mockito.kotlin:mockito-kotlin:$mockitoKotlinVersion"
    // Optional -- Mockk framework
    testImplementation "io.mockk:mockk:$mockkVersion"
}
```

**注**: testImplementation はローカルテストの依存関係を追加し、 androidTestImplementation はインストルメンテーションテストの依存関係を追加します。


## ローカル単体テストクラスを作成する

ローカル単体テストクラスは、 [JUnit 4](https://junit.org/junit4/) テストクラスとして記述します。

そのためには、1 つ以上のテストメソッドを含むクラスを作成します。通常は `module-name/src/test/` 内にあります。テストメソッドは `@Test` アノテーションで始まり、テストするコンポーネントの単一の側面を検証して実行するためのコードが含まれています。

次の例は、ローカル単体テストクラスの実装方法を示しています。テストメソッド `emailValidator_correctEmailSimple_returnsTrue()` は、アプリ内のメソッドである `isValidEmail()` の検証を試みます。isValidEmail() も true を返した場合、テスト関数は true を返します。

```kotlin
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Test

class EmailValidatorTest {
    @Test fun emailValidator_CorrectEmailSimple_ReturnsTrue() {
        assertTrue(EmailValidator.isValidEmail("name@email.com"))
    }
}
```

アプリ内のコンポーネントが期待される結果を返すかどうかを評価する、読み取り可能なテストを作成する必要があります。 [junit.Assert](http://junit.org/javadoc/latest/org/junit/Assert.html) 、 [Hamcrest](https://github.com/hamcrest) 、 [Truth](https://truth.dev/) などのアサーションライブラリを使用することをおすすめします。上のスニペットは、 junit.Assert の使用方法の例です。


## モック可能な Android ライブラリ

ローカル単体テストを実行すると、 Android Gradle プラグインは、 Android API をプロジェクトに取り込みます。ただし、ローカル単体テストは PC 上で実行されるため、 Android OS に備わっている API は、使用できません。そのため、それらの API の中身は空になります。よって、 Android API をローカル単体テストで呼び出すと例外がスローされます。

ローカル単体テストで、 Context などの Android フレームワーク内のクラスを参照する場合は、モックフレームワークを使用することで、テストを正常に実施することが可能になります。

注: モックはテストダブルの一種で、そのインタラクションに関する期待値と、動作を定義できます。 [倍精度浮動小数点をテストする](https://developer.android.com/training/testing/fundamentals/test-doubles?hl=ja&_gl=1*snu7a0*_up*MQ..*_ga*MzgzNjQyNS4xNzIzMTAyNTUx*_ga_6HH9YJMN9M*MTcyMzEwMjU1MC4xLjAuMTcyMzEwMjU1MC4wLjAuMA..) をご覧ください。


### Android 依存関係のモック

よくある問題は、クラスが文字列リソースを使用していることです。文字列リソースを取得するには、Context クラスの getString() メソッドを呼び出します。ただし、ローカルテストでは Android フレームワークに属する Context や、そのメソッドを使用できません。 getString() の呼び出しが、クラスから移動するのが理想的ですが、これは必ずしも現実的ではありません。この問題を解決するには、 getString() メソッドが呼び出されたときに、常に同じ値を返す Context のモック、または、スタブを作成します。

Mockable Android ライブラリと、 [Mockito](https://github.com/mockito/mockito) や [MockK](https://mockk.io/) などのモックフレームワークを使用すると、単体テスト内の Android クラスのモックの動作をプログラミングできます。

Mockito を使用して、ローカル単体テストにモックオブジェクトを追加するには、次のプログラミングモデルに従います。

1. [テスト環境を設定する](../4.インストルメンテーションテスト/3.%20AndroidX%20のテストライブラリ/1.%20AndroidX%20Test%20用にプロジェクトをセットアップする.md/#gradle-の依存関係を追加する) の説明に従って、 Mockito ライブラリの依存関係を build.gradle ファイルに含めます。
2. 単体テストクラス定義の先頭に、 `@RunWith(MockitoJUnitRunner.class)` アノテーションを追加します。このアノテーションは、フレームワークの使用が正しいことを検証し、モック オブジェクトの初期化を簡素化するように Mockito テストランナーに指示します。
3. Android の依存関係のモックオブジェクトを作成するには、フィールド宣言の前に `@Mock` アノテーションを追加します。
4. 依存関係の動作をスタブするには、 `when()` メソッドと `thenReturn()` メソッドを使用して、条件を指定し、条件が満たされたときに値を返すようにします。

次の例は、 [Mockito-Kotlin](https://github.com/mockito/mockito-kotlin) で作成された Kotlin のモックの Context オブジェクトを使用する単体テストの作成方法を示しています。

```kotlin
import android.content.Context
import org.junit.Assert.assertEquals
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.junit.MockitoJUnitRunner
import org.mockito.kotlin.doReturn
import org.mockito.kotlin.mock

private const val FAKE_STRING = "HELLO WORLD"

@RunWith(MockitoJUnitRunner::class)
class MockedContextTest {

    @Mock
    private lateinit var mockContext: Context

    @Test
    fun readStringFromContext_LocalizedString() {
        // getString(R.string.name_label) が呼び出されたら
        // FAKE_STRING を返すモックを定義する。
        val mockContext = mock<Context> {
            on { getString(R.string.name_label) } doReturn FAKE_STRING
        }

        val myObjectUnderTest = ClassUnderTest(mockContext)

        // ...when the string is returned from the object under test...
        val result: String = myObjectUnderTest.getName()

        // ...then the result should be the expected one.
        assertEquals(result, FAKE_STRING)
    }
}
```

Mockito フレームワークの使用方法については、 [Mockito API リファレンス](https://github.com/mockito/mockito-kotlin) と、 [サンプルコード](https://github.com/android/testing-samples/tree/main/unit/BasicSample) の SharedPreferencesHelperTest クラスをご覧ください。 [Android テスト Codelab (古いため非推奨)](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-basics?hl=ja&_gl=1*o4p9y5*_up*MQ..*_ga*MzgzNjQyNS4xNzIzMTAyNTUx*_ga_6HH9YJMN9M*MTcyMzEwMjU1MC4xLjAuMTcyMzEwMjU1MC4wLjAuMA..) もお試しください。

注意: 複雑なモックは使用しないでください。代わりに、フェイクや [Robolectric](http://robolectric.org/) シャドウ（ Android クラスの場合）など、さまざまなタイプのテストダブルを使用できます。また、インストルメンテーションテストで、依存関係の実際の実装を使用することを検討してください。


### エラー: 「Method ... not mocked」

Error: "Method ... not mocked メッセージを含むメソッドにアクセスしようとすると、 Mockable Android ライブラリは例外をスローします。

例外がスローされるのではなく、デフォルト値を返したい場合もあります。その場合は、 Groovy でプロジェクトの最上位の build.gradle ファイルに次の構成を追加します。メソッドの戻り値の型に応じて null 、または、ゼロを返すように動作を変更できます。

```gradle
android {
    
    // ...

    testOptions {
        unitTests.returnDefaultValues = true
    }
}
```

**注意** : returnDefaultValues プロパティを true に設定する際は注意してください。戻り値が null 、または、ゼロの場合、テストの回帰 (デグレ) が発生する可能性があります。その場合、デバッグが難しくなり、テストが不合格になる可能性があります。これは最後の手段としてのみ使用してください。



