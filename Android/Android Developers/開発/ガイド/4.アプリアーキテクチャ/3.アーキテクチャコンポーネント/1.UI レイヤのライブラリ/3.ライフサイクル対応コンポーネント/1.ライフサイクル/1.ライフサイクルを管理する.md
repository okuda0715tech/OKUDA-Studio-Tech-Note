- [ライフサイクル対応コンポーネントによるライフサイクルへの対応](#ライフサイクル対応コンポーネントによるライフサイクルへの対応)
  - [Lifecycle](#lifecycle)
  - [LifecycleOwner](#lifecycleowner)
    - [カスタムの LifecycleOwner の実装](#カスタムの-lifecycleowner-の実装)
  - [ライフサイクル対応コンポーネントに関するおすすめの方法](#ライフサイクル対応コンポーネントに関するおすすめの方法)
  - [ライフサイクル対応コンポーネントのユースケース](#ライフサイクル対応コンポーネントのユースケース)
  - [停止イベントへの対処](#停止イベントへの対処)


# ライフサイクル対応コンポーネントによるライフサイクルへの対応

ライフサイクル対応コンポーネントは、別のコンポーネント（アクティビティやフラグメントなど）のライフサイクル ステータスの変化に対応してアクションを実行します。このコンポーネントを使用することで、適切に整理された、メンテナンスが容易な軽量のコードを作成できます。

一般的なパターンでは、従属関係にあるコンポーネントのアクションをアクティビティとフラグメントのライフサイクル メソッドに実装します。ただし、このパターンではコードをうまく整理できず、エラーの発生が増加します。ライフサイクル対応コンポーネントを使用すると、従属関係にあるコンポーネントのコードをライフサイクル メソッドから移動してコンポーネント自体に組み込むことができます。

androidx.lifecycle パッケージには、ライフサイクル対応コンポーネントを作成するためのクラスとインターフェースが用意されています。ライフサイクル対応コンポーネントは、アクティビティやフラグメントの現在のライフサイクルの状態に基づいて動作を自動的に調整できるコンポーネントです。

注: androidx.lifecycle を Android プロジェクトにインポートするには、 [ライフサイクルのリリースノート](https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=ja&_gl=1*1xw3evd*_up*MQ..*_ga*MTE1ODIzNDI5Ny4xNzIxNzE2Njk2*_ga_6HH9YJMN9M*MTcyMTg3ODI0MC4yLjAuMTcyMTg3ODI0MC4wLjAuMA..#declaring_dependencies) で依存関係を宣言する手順をご覧ください。

Android フレームワークで定義されているアプリ コンポーネントは、その大部分にライフサイクルがアタッチされています。ライフサイクルは、オペレーティング システム、またはプロセス内で実行されるフレームワーク コードによって管理されます。ライフサイクルは Android の動作にとって非常に重要であり、アプリはライフサイクルに従う必要があります。そうしないと、メモリリークやアプリのクラッシュが発生する可能性があります。

画面に端末の位置情報を表示するアクティビティについて考えてみましょう。一般的な実装は次のようになります。

```kotlin
internal class MyLocationListener(
        private val context: Context,
        private val callback: (Location) -> Unit
) {

    fun start() {
        // システムロケーションサービスに接続
    }

    fun stop() {
        // システムロケーションサービスの接続を解除
    }
}

class MyActivity : AppCompatActivity() {
    private lateinit var myLocationListener: MyLocationListener

    override fun onCreate(...) {
        myLocationListener = MyLocationListener(this) { location ->
            // UI を更新する
        }
    }

    public override fun onStart() {
        super.onStart()
        myLocationListener.start()
        // アクティビティのライフサイクルに連動する必要のある
        // 他の様々なコンポーネントを管理する
    }

    public override fun onStop() {
        super.onStop()
        myLocationListener.stop()
        // アクティビティのライフサイクルに連動する必要のある
        // 他の様々なコンポーネントを管理する
    }
}
```

このサンプルは、問題ないように見えますが、 2 つの問題を抱えています。

1. **ライフサイクルコールバック関数の肥大化**

onStart() や onStop() 関数が肥大化し、コードのメンテナンスが困難になる可能性があります。

2. **長時間処理による予期せぬ動作**

もし onStart() での処理に長時間かかるものがあった場合、 onStart() メソッドの前に onStop() メソッドが終了するという競合状態が発生する可能性があります。この場合、コンポーネントが必要以上に長い間稼働し続けることになります。

```kotlin
class MyActivity : AppCompatActivity() {
    private lateinit var myLocationListener: MyLocationListener

    override fun onCreate(...) {
        myLocationListener = MyLocationListener(this) { location ->
            // update UI
        }
    }

    public override fun onStart() {
        super.onStart()
        Util.checkUserStatus { result ->
            // もしアクティビティがストップした後にこの処理が実行されたらどうなってしまうでしょうか？
            // クラッシュする可能性があります。
            if (result) {
                myLocationListener.start()
            }
        }
    }

    public override fun onStop() {
        super.onStop()
        myLocationListener.stop()
    }
}
```

androidx.lifecycle パッケージに含まれているクラスとインターフェースを使用することで、上記の問題を回復性のある分離された方法で解決できます。

また、詳しくは後程説明しますが、ライフサイクル対応クラスを生成することで、クラスの再利用性が向上します。


## Lifecycle

[Lifecycle](https://developer.android.com/reference/androidx/lifecycle/Lifecycle?_gl=1*1m2wn17*_up*MQ..*_ga*MTE1ODIzNDI5Ny4xNzIxNzE2Njk2*_ga_6HH9YJMN9M*MTcyMTg5MDE4OC4zLjAuMTcyMTg5MDE4OC4wLjAuMA..#summary) は、コンポーネント（アクティビティやフラグメントなど）のライフサイクルの状態に関する情報を保持するクラスです。このクラスを使用すると、他のオブジェクトでその状態を監視できます。

Lifecycle は、 「イベント」 と 「状態」 を使用して、関連するコンポーネントのライフサイクルステータスを追跡します。

1. イベント
   - フレームワークと Lifecycle クラスからディスパッチされるライフサイクル イベント。これらのイベントは、アクティビティとフラグメントのコールバックイベントにマッピングされます。
2. 状態
   - Lifecycle オブジェクトによって追跡されるコンポーネントの現在の状態。

次の図は、アクティビティのライフサイクルを構成する状態とイベントを図にしたものです。状態はグラフのノード、イベントはそれらのノード間のエッジとそれぞれ考えることができます。

<img src="./画像/Activity のライフサイクルを構成する状態とイベント.svg" width="600">

ライフサイクルコンポーネントのライフサイクルステータスを監視するには、 `DefaultLifecycleObserver` インターフェースを実装し、 onCreate , onStart などの対応するメソッドをオーバーライドします。そして、ライフサイクルコンポーネントの addObserver() メソッドを呼び出して、引数にオブザーバーのインスタンスを渡します。

```kotlin
// ライフサイクルを監視したい (持たせたい) クラス
class MyObserver : DefaultLifecycleObserver {
    override fun onResume(owner: LifecycleOwner) {
        // onResume() に連動したい何らかの処理
        connect()
    }

    override fun onPause(owner: LifecycleOwner) {
        // onPause() に連動したい何らかの処理
        disconnect()
    }
}

// myLifecycleOwner は、 Activity などのライフライクルを持つオブジェクトです。
// MyObserver が、 myLifecycleOwner のライフサイクルに連動するようになります。
myLifecycleOwner.getLifecycle().addObserver(MyObserver())
```


## LifecycleOwner

LifecycleOwner インターフェースは、それを実装しているクラスがライフサイクル ( Lifecycle オブジェクト) を持っていることを示します。 **このインターフェースには、たった一つの抽象関数 ( getLifecycle() ) が定義されており、 Lifecycle オブジェクトを返すように実装されている必要があります。**

LifecycleOwner インターフェースは、任意のクラスで実装することが可能です。

DefaultLifecycleObserver を実装するコンポーネントは、LifecycleOwner を実装するコンポーネントとライフサイクルを連携します。実装方法は、前のセクション ( [Lifecycle](#lifecycle) ) を参照してください。

注意 : DefaultLifecycleObserver インターフェースを実装したクラス自身は、 Lifecycle を持っていません ( LifecycleOwer を実装していません) 。あくまで、連携した LifecycleOwner の状態が変更された際に、イベントを受け取るだけです。そのため、そのままでは、任意の場所で Lifecycle インスタンスを参照することはできません。 Lifecycle インスタンスを参照するには、オブザーバークラスのコンストラクタ等で、あらかじめ Lifecycle インスタンスを渡しておく必要があります。

```kotlin
class MyActivity : AppCompatActivity() {
    private lateinit var myLocationListener: MyLocationListener

    override fun onCreate(...) {
        // オブザーバーに LifecycleOwner の Lifecycle インスタンスを渡します。
        myLocationListener = MyLocationListener(this, lifecycle) { location ->
            // UI を更新します。
        }
        Util.checkUserStatus { result ->
            if (result) {
                myLocationListener.enable()
            }
        }
    }
}
```

オブザーバー ( MyLocationListener ) のコンストラクタで、 Lifecycle オブジェクトを渡したので、通常の関数で Lifecycle の状態を参照できるようになりました。

```kotlin
internal class MyLocationListener(
        private val context: Context,
        private val lifecycle: Lifecycle, // Lifecycle を渡す
        private val callback: (Location) -> Unit
): DefaultLifecycleObserver {

    private var enabled = false

    override fun onStart(owner: LifecycleOwner) {
        if (enabled) {
            // ...
        }
    }

    // 通常の関数 (ライフサイクルイベントではない関数)
    fun enable() {
        enabled = true
        // LifecycleOwner の Lifecycle を参照できる。
        if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
            // ...
        }
    }

    override fun onStop(owner: LifecycleOwner) {
        // ...
    }
}
```

これで、オブザーバーが完全にライフサイクル対応クラスになりました。

ライフサイクル対応クラスを作成するメリットは、再利用性を上げることができる点です。

別のアクティビティやフラグメントから MyLocationListener を使用する場合に必要なのは、初期化のみです。セットアップとティアダウンの処理はすべて、クラス自体で管理されます。

Android のライフサイクルと連動する必要があるクラスをライブラリで提供する場合は、ライフサイクル対応コンポーネントを使用することをおすすめします。これらのコンポーネントはライブラリ クライアントで簡単に統合できます。クライアント側でライフサイクルを手動で管理する必要はありません。


### カスタムの LifecycleOwner の実装

独自のクラスを LifecycleOwner 化することもできます。

次の例は、 MyActivity クラスを LifecycleOwner 化します。 ( MyActivity は、 Activity を継承しているので、手を加えなくても親の Lifecycle を使えば済みますが、ここでは実装方法を説明するためのものなので、その点は無視してください。)

```kotlin
class MyActivity : Activity(), LifecycleOwner {

    // LifecycleRegistry クラスは Lifecycle 抽象クラスを実装しているため、
    // Lifecycle オブジェクトとして使用します。
    private lateinit var lifecycleRegistry: LifecycleRegistry

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleRegistry = LifecycleRegistry(this)

        // Lifecycle オブジェクトの状態を CREATED に変更します。
        lifecycleRegistry.markState(Lifecycle.State.CREATED)
    }

    public override fun onStart() {
        super.onStart()

        // Lifecycle オブジェクトの状態を STARTED に変更します。
        lifecycleRegistry.markState(Lifecycle.State.STARTED)
    }

    // LifecycleOwner インターフェースを実装する必要があるため、
    // getLifecycle() 関数を実装します。
    override fun getLifecycle(): Lifecycle {
        return lifecycleRegistry
    }
}
```


## ライフサイクル対応コンポーネントに関するおすすめの方法

知っていることばかりなので省略。


## ライフサイクル対応コンポーネントのユースケース

ライフサイクル対応コンポーネントを使用すると、さまざまなケースにおいてライフサイクルを極めて簡単に管理できるようになります。以下に例を示します。

大まかな現在地情報と詳細な現在地情報の切り替え。ライフサイクル対応コンポーネントを使用すると、現在地情報アプリが表示されている間は詳細な現在地情報を有効にし、そのアプリがバックグラウンドで実行されているときには大まかな現在地情報に切り替えることができます。ライフサイクル対応コンポーネントである LiveData を使用すると、ユーザーが移動したときにアプリで UI を自動更新できます。
動画のバッファリングの停止と開始。ライフサイクル対応コンポーネントを使用すると、可能な限り早く動画のバッファリングを開始できます。ただし、アプリが完全に起動するまで再生が延期されます。また、ライフサイクル対応コンポーネントを使用することで、アプリが破棄されたときにバッファリングを終了することもできます。
ネットワーク接続の開始と停止。ライフサイクル対応コンポーネントを使用すると、アプリがフォアグラウンドで実行されている間、ネットワーク データのリアルタイム更新（ストリーミング）を有効にすることができます。また、アプリがバックグラウンドに移動されたときには、リアルタイム更新を自動的に一時停止できます。
アニメーション ドローアブルの一時停止と再開。ライフサイクル対応コンポーネントを使用すると、アプリがバックグラウンドで実行されているときはアニメーション ドローアブルを一時停止し、アプリがフォアグラウンドで実行されるようになったらドローアブルを再開することができます。


## 停止イベントへの対処

Lifecycle が AppCompatActivity または Fragment に属している場合、Lifecycle の状態は CREATED に変わり、AppCompatActivity または Fragment の onSaveInstanceState() が呼び出されると ON_STOP イベントがディスパッチされます。

Fragment または AppCompatActivity の状態が onSaveInstanceState() を介して保存された場合、ON_START が呼び出されるまでその UI は変更不可と見なされます。状態が保存された後に UI を変更しようとすると、アプリのナビゲーションの状態に不整合が生じる可能性があります。状態が保存された後にアプリで FragmentTransaction を実行した場合に FragmentManager が例外をスローするのはこのためです。詳しくは、commit() をご覧ください。

LiveData は、オブザーバーに関連付けられた Lifecycle の状態が STARTED 以上でなければオブザーバーを呼び出さないようにして、こうしたエッジケースを追加設定なしで防止しています。バックグラウンドでは、オブザーバーを呼び出すことを決定する前に isAtLeast() が呼び出されます。

残念ながら、AppCompatActivity の onStop() メソッドは onSaveInstanceState() の後に呼び出されるため、UI の状態の変更は許可されず、Lifecycle の状態もまだ CREATED の状態に遷移していないというギャップが残ります。

この問題が発生しないように、バージョン beta2 以下の Lifecycle クラスでは、イベントをディスパッチせずに状態を CREATED としてマークします。これにより、onStop() がシステムによって呼び出されるまでイベントはディスパッチされなくなりますが、現在の状態をチェックするすべてのコードで実際の値を取得できるようになります。

ただし、このソリューションには次の 2 つの大きな問題があります。

- API レベルが 23 以下の場合、アクティビティの状態の保存は、部分的に別のアクティビティの対象であっても、実際には Android システムが行います。つまり、Android システムは onSaveInstanceState() を呼び出しますが、必ずしも onStop() を呼び出すわけではありません。このため、UI の状態が変更不可であっても、ライフサイクルがアクティブであるとオブザーバーが判断するインターバルが長くなる可能性があります。
- LiveData クラスに同様の動作を公開するクラスは、Lifecycle バージョン beta 2 以下で提供されている回避策を実装する必要があります。

注: このフローを簡素化し、以前のバージョンとの互換性を高めるために、バージョン 1.0.0-rc1 以降では、onSaveInstanceState() が呼び出された場合は onStop() メソッドの呼び出しを待たずに Lifecycle オブジェクトが CREATED としてマークされ、ON_STOP がディスパッチされます。これがコードに影響を及ぼす可能性はあまりありませんが、API レベルが 26 以下の Activity クラスにおける呼び出し順序と一致しないため、注意が必要です。


