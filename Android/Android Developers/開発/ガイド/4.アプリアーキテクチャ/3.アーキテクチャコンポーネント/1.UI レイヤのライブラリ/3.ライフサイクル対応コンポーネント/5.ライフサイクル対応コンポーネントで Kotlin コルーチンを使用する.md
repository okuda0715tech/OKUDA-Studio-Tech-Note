- [ライフサイクル対応コンポーネントで Kotlin コルーチンを使用する](#ライフサイクル対応コンポーネントで-kotlin-コルーチンを使用する)
  - [KTX 依存関係を追加する](#ktx-依存関係を追加する)
  - [ライフサイクル対応コルーチン スコープ](#ライフサイクル対応コルーチン-スコープ)
    - [ViewModelScope](#viewmodelscope)
    - [LifecycleScope](#lifecyclescope)
  - [再実行可能なライフサイクル対応コルーチン](#再実行可能なライフサイクル対応コルーチン)
    - [ライフサイクル対応フロー収集](#ライフサイクル対応フロー収集)
  - [ライフサイクル対応コルーチンを停止する](#ライフサイクル対応コルーチンを停止する)
  - [LiveData でコルーチンを使用する](#livedata-でコルーチンを使用する)


# ライフサイクル対応コンポーネントで Kotlin コルーチンを使用する

Kotlin のコルーチンには、非同期コードを記述できる API が用意されています。Kotlin コルーチンを使用すると、CoroutineScope を定義して、コルーチンを実行するタイミングを管理できます。非同期操作はそれぞれ、特定のスコープで実行されます。

ライフサイクル対応コンポーネントは、アプリ内の論理スコープ用コルーチンと、LiveData との相互運用レイヤを万全の体制でサポートしています。このトピックでは、ライフサイクル対応コンポーネントでコルーチンを効果的に使用する方法について説明します。


## KTX 依存関係を追加する

このトピックで説明する組み込みのコルーチン スコープは、対応する各コンポーネントの KTX 拡張機能に含まれています。これらのスコープを使用するときは、必ず適切な依存関係を追加してください。

- ViewModelScope には、androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.0 以降を使用します。
- LifecycleScope には、androidx.lifecycle:lifecycle-runtime-ktx:2.4.0 以降を使用します。
- liveData には、androidx.lifecycle:lifecycle-livedata-ktx:2.4.0 以降を使用します。


## ライフサイクル対応コルーチン スコープ

ライフサイクル対応コンポーネントでは、アプリで使用できる次の組み込みスコープが定義されます。


### ViewModelScope

ViewModelScope は、アプリで ViewModel ごとに定義されます。このスコープ内で起動されたすべてのコルーチンは、ViewModel が消去されると自動的にキャンセルされます。ViewModel がアクティブな場合にのみ行う必要がある作業があるとき、コルーチンが役に立ちます。

ViewModel の CoroutineScope にアクセスするには、次の例に示すように ViewModel の viewModelScope プロパティを使用します。

```kotlin
class MyViewModel: ViewModel() {
    init {
        viewModelScope.launch {
            // Coroutine that will be canceled when the ViewModel is cleared.
        }
    }
}
```


### LifecycleScope

LifecycleScope は、Lifecycle オブジェクトごとに定義されます。このスコープ内で起動されたすべてのコルーチンは、Lifecycle が破棄されたときにキャンセルされます。Lifecycle の CoroutineScope には、lifecycle.coroutineScope プロパティまたは lifecycleOwner.lifecycleScope プロパティを介してアクセスできます。

```kotlin
class MyFragment: Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewLifecycleOwner.lifecycleScope.launch {
            // do something.
        }
    }
}
```


## 再実行可能なライフサイクル対応コルーチン

長時間実行オペレーションは、Lifecycle が DESTROYED の場合、lifecycleScope により適切な方法で自動的にキャンセルされますが、Lifecycle が特定の状態のときにコードブロックの実行の開始が、また別の状態のときにキャンセルが必要な場合もあります。たとえば、Lifecycle が STARTED のときに Flow を収集し、STOPPED になるとコレクションをキャンセルする必要がある場合もあります。この方法では、UI が画面に表示されるときにのみ Flow 出力を処理することで、リソースを節約し、場合によってはアプリのクラッシュを回避します。

このようなケースのために、Lifecycle と LifecycleOwner にはこれを実現する `suspend repeatOnLifecycle` API が用意されています。次の例には、関連する Lifecycle が少なくとも STARTED 状態にあるたびに実行し、Lifecycle が STOPPED になるとキャンセルするコードブロックが含まれています。

```kotlin
class MyFragment : Fragment() {

    val viewModel: MyViewModel by viewModel()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {

            // repeatOnLifecycle は、ライフサイクルが STARTED 状態 (またはそれ以上) になるたびに新しいコルーチンを生成して、ブロックを開始し、 STOPPED になるとブロックをキャンセルします。
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // flow をトリガーし、値の収集を開始します。
                // STARTED になったら収集を開始し、
                // STOPPED になったら収集を停止します。
                viewModel.someDataFlow.collect {
                    // アイテムを処理
                }
            }
        }
    }
}
```


### ライフサイクル対応フロー収集

ライフサイクルに連動して Flow の収集を行いたい場合、かつ、一つの Flow からしか収集を行わない場合は、 repeatOnLifecycle() よりも、 Flow.flowWithLifecycle() を使用したほうが記述が簡素化できます。

```kotlin
viewLifecycleOwner.lifecycleScope.launch {
    exampleProvider.exampleFlow()
        .flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)
        .collect {
            // viewLifecycleOwner が STARTED 以上の場合にのみ
            // Flow の収集を行い、それ以外の場合は、収集をキャンセルします。
        }
}
```

複数の Flow から平行して収集収集を行う場合は、引き続き repeatOnLifecycle() を使用すると効率的です。

```kotlin
viewLifecycleOwner.lifecycleScope.launch {
    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
        launch {
            flow1.collect { /* Process the value. */ }
        }

        launch {
            flow2.collect { /* Process the value. */ }
        }
    }
}
```


## ライフサイクル対応コルーチンを停止する

公式ドキュメントでは、このセクションで、以下の関数の使用方法について解説されています。

- [LifecycleOwner.whenStarted](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary?_gl=1*jxjtje*_up*MQ..*_ga*NzczNTA3MDc1LjE3MjIyNTA2MDM.*_ga_6HH9YJMN9M*MTcyMjI1MDYwMy4xLjAuMTcyMjI1MDYwMy4wLjAuMA..#(androidx.lifecycle.LifecycleOwner).whenStarted(kotlin.coroutines.SuspendFunction1))
- [Lifecycle.whenStarted](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary?_gl=1*jxjtje*_up*MQ..*_ga*NzczNTA3MDc1LjE3MjIyNTA2MDM.*_ga_6HH9YJMN9M*MTcyMjI1MDYwMy4xLjAuMTcyMjI1MDYwMy4wLjAuMA..#(androidx.lifecycle.Lifecycle).whenStarted(kotlin.coroutines.SuspendFunction1))

ただし、これらの関数は既に非推奨となっています。 whenStarted は、ライフサイクル状態が指定された状態を下回ったときに作業をキャンセルするのではなく、一時停止する一時停止ディスパッチャーでブロックを実行するため、非推奨になりました。ライフサイクルが変更されたときに 1 回だけ実行する必要がある、一時停止しない作業には、代わりに withStarted が使用できます。

- [LifecycleOwner.withStarted](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary?_gl=1*jxjtje*_up*MQ..*_ga*NzczNTA3MDc1LjE3MjIyNTA2MDM.*_ga_6HH9YJMN9M*MTcyMjI1MDYwMy4xLjAuMTcyMjI1MDYwMy4wLjAuMA..#(androidx.lifecycle.LifecycleOwner).withStarted(kotlin.Function0))
- [Lifecycle.withStarted](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary?_gl=1*jxjtje*_up*MQ..*_ga*NzczNTA3MDc1LjE3MjIyNTA2MDM.*_ga_6HH9YJMN9M*MTcyMjI1MDYwMy4xLjAuMTcyMjI1MDYwMy4wLjAuMA..#(androidx.lifecycle.Lifecycle).withStarted(kotlin.Function0))


この Lifecycle / LifecycleOwner の Lifecycle.State が少なくとも Lifecycle.State.STARTED の状態でブロックを実行し、その結果で再開します。呼び出し時またはブロックが実行可能になる前にライフサイクルが Lifecycle.State.DESTROYED に達した場合は、CancellationException をスローします。

whenStated 関数の使用方法についてはあまりドキュメントがなかったため、サンプルコードは省略します。

公式ドキュメントでは、このセクションでは、さらに launchWhenStarted 関数の使用方法について解説されていますが、この関数も既に非推奨となっています。 launchWhenStarted は、場合によってはリソースの無駄につながる可能性があるため非推奨です。Lifecycle 状態が少なくとも Lifecycle.State.STARTED であるときはいつでもブロックを実行するには、 repeatOnLifecycle を一時停止するように置き換えます。


## LiveData でコルーチンを使用する

LiveData を使用する場合、値の非同期的な計算が必要になることがあります。たとえば、ユーザーの優先設定を取得して UI に提供する場合などです。このような場合、liveData ビルダー関数を使用して suspend 関数を呼び出し、結果を LiveData オブジェクトとして提供できます。

以下の例で、loadUser() は他の場所で宣言された suspend 関数です。liveData ビルダー関数を使用して loadUser() を非同期で呼び出したら、emit() を使用して結果を放出します。

```kotlin
val user: LiveData<User> = liveData {
    val data = database.loadUser() // loadUser is a suspend function.
    emit(data)
}
```

liveData 関数は、コルーチンと LiveData の間で構造化された同時実行プリミティブ (つまりコルーチン) として機能します。コードブロックの実行は、LiveData が有効になると開始し、 LiveData が無効になったときに設定可能なタイムアウトが経過すると、コルーチンは自動的にキャンセルされます。完了前にキャンセルされた場合は、 LiveData が再びアクティブになると、コルーチンは再開されます。 **以前の実行で正常に完了した場合は再開されません。再開されるのは、自動的にキャンセルされた場合だけです。** 他の理由 ( CancellationException のスローなど) でブロックがキャンセルされた場合は、再開されません。

ブロックから複数の値を出力することもできます。

```kotlin
val user: LiveData<Result> = liveData {
    // emit があるということは、ここはワーカースレッドで実行されているはず。
    emit(Result.loading())
    try {
        // fetchUser は、 liveData{} ブロックのスコープで実行されているので、 fetchUser の結果が返ってくるまで、 liveData{} ブロックは終了しないはず。
        emit(Result.success(fetchUser()))
    } catch(ioException: Exception) {
        emit(Result.error(ioException))
    }
}
```

また、次の例のように liveData と Transformations を組み合わせることもできます。

```kotlin
class MyViewModel: ViewModel() {
    private val userId: LiveData<String> = MutableLiveData()
    val user = userId.switchMap { id ->
        liveData(context = viewModelScope.coroutineContext + Dispatchers.IO) {
            emit(database.loadUserById(id))
        }
    }
}
```

新しい値を出力する必要がある場合は、emitSource() 関数を呼び出すことで LiveData から複数の値を出力できます。 emit() または emitSource() を呼び出すたびに、以前追加したソースが削除されます。

```kotlin
class UserDao: Dao {
    @Query("SELECT * FROM User WHERE id = :id")
    fun getUser(id: String): LiveData<User>
}

class MyRepository {
    fun getUser(id: String) = liveData<User> {
        // disposable は、 LiveData<Result> 型です。
        val disposable = emitSource(
            userDao.getUser(id).map {
                Result.loading(it)
            }
        )
        try {
            val user = webservice.fetchUser(id)
            // 更新されたユーザーがいるにもかかわらず 'loading' イベントが伝搬することを回避するために、以前のエミッションを停止します。
            disposable.dispose()
            // データベースを更新する
            userDao.insert(user)
            // Success 型で放出を再構築する
            emitSource(
                userDao.getUser(id).map {
                    Result.success(it)
                }
            )
        } catch(exception: IOException) {
            // 'emit' を呼び出すと、以前のものが自動的に破棄されるため、ここで明示的に破棄する必要はありません。
            emitSource(
                userDao.getUser(id).map {
                    Result.error(exception, it)
                }
            )
        }
    }
}
```

