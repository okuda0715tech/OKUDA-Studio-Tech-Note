- [ViewModel の概要](#viewmodel-の概要)
  - [ViewModel のメリット](#viewmodel-のメリット)
    - [永続性](#永続性)
      - [ViewModel のスコープ](#viewmodel-のスコープ)
      - [SavedStateHandle](#savedstatehandle)
    - [ビジネスロジックへのアクセス](#ビジネスロジックへのアクセス)
  - [Jetpack Compose](#jetpack-compose)
  - [ViewModel を実装する](#viewmodel-を実装する)
    - [ViewModel でコルーチンを使用する](#viewmodel-でコルーチンを使用する)
  - [ViewModel のライフサイクル](#viewmodel-のライフサイクル)
    - [ViewModel の依存関係をクリアする](#viewmodel-の依存関係をクリアする)
  - [ベストプラクティス](#ベストプラクティス)
  - [追加情報](#追加情報)


# ViewModel の概要

**ViewModel クラスは、ビジネスロジックまたは画面レベルの状態ホルダーです。状態を UI に公開し、関連するビジネスロジックをカプセル化します。** 状態がキャッシュに保存され、構成が変更されてもそれが維持されることが主なメリットです。つまり、アクティビティ間を移動するときや、画面の回転などの構成の変更に従うときに、 UI でデータを再度取得する必要がありません。

目標: このガイドでは、ViewModel の基本、最新の Android 開発における位置づけ、およびそれらをアプリに実装する方法について説明します。


## ViewModel のメリット

ViewModel の代わりに、UI に表示するデータを保持するプレーンクラスを利用できます。これは、アクティビティ間や Navigation デスティネーション間を移動する際に問題になることがあります。インスタンス状態保存メカニズムを使用して保存せずにこれを行うと、そのデータが破棄されます。ViewModel であれば、データの永続性のための便利な API を利用して、この問題を解決できます。

ViewModel クラスの主なメリットは基本的に次の 2 つです。

- UI 状態を保持できます。
- ビジネス ロジックにアクセスできます。

ViewModel は、Hilt や Navigation、Compose などの主な Jetpack ライブラリとの統合を完全にサポートしています。


### 永続性

**ViewModel は、ViewModel で保持される状態と、ViewModel でトリガーされるオペレーションの両方で、永続性を実現します。** このようにキャッシュに保存されることで、一般的な構成の変更（画面回転など）があってもデータを再度取得する必要がなくなります。


#### ViewModel のスコープ

ViewModel をインスタンス化する場合、ViewModelStoreOwner インターフェースを実装するオブジェクトを渡します。これは、Navigation デスティネーション、Navigation グラフ、アクティビティ、フラグメント、その他のインターフェースを実装するなんらかのタイプになります。これにより、ViewModelStoreOwner のライフサイクルに ViewModel のスコープが設定されます。これは、ViewModelStoreOwner が完全に削除されるまでメモリ内に残ります。

ViewModelStoreOwner インターフェースを実装しているクラスは以下になります。

- 直接サブクラス
  - ComponentActivity
  - Fragment
  - NavBackStackEntry
- 間接サブクラス
  - [ViewModelStoreOwner リファレンス](https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModelStoreOwner?_gl=1*1i0fm7p*_up*MQ..*_ga*OTUyMjc1MjUxLjE3MjE4OTg2NzQ.*_ga_6HH9YJMN9M*MTcyMTk2MTI4Ny4yLjAuMTcyMTk2MTI4Ny4wLjAuMA..) をご覧ください。


#### SavedStateHandle

[SavedStateHandle](./4.ViewModel%20の保存済み状態のモジュール.md) を使用すると、構成の変更でのみならず、プロセスの再作成後もデータを保持できます。つまり、ユーザーがアプリを閉じてから後で開いた場合でも、UI の状態を維持できます。


### ビジネスロジックへのアクセス

ビジネスロジックの大部分はデータレイヤに存在しますが、UI レイヤにビジネスロジックも含めることができます。特に次のような場合が該当します。

- 複数のリポジトリからのデータを組み合わせて画面 UI の状態を作成する場合
- 特定の種類のデータにデータレイヤが不要な場合
- etc ...

ViewModel は、UI レイヤでビジネスロジックを処理するのに適した場所です。また、アプリデータにアクセスする必要がある場合に、 ViewModel はイベントの処理も担い、階層の他のレイヤに委任します。


## Jetpack Compose

Jetpack Compose を使用する場合、ViewModel は、コンポーザブルに画面 UI の状態を公開する主要な手段です。アクティビティとフラグメントでコンポーズ可能な関数をホストするだけです。

以前は、アクティビティやフラグメントで再利用可能な UI を作成することがそれほど単純で直感的ではありませんでしたが、これが簡単に実現できるようになり、 UI コントローラとしてはるかに有効になりました。

Compose で ViewModel を使用する場合に理解すべき最も重要なことは、 **ViewModel のスコープをコンポーザブルに設定できない** ことです。これは、実装的な理由としては、コンポーザブルが ViewModelStoreOwner ではないためです。根本的な原因としては、コンポーザブルは構成変更に対応するためのクラスであり、コンポーザブルのライフサイクルと Activity などのライフサイクルは異なるものであるためです。

Compose で ViewModel からメリットを得るには、各画面をフラグメントまたはアクティビティでホストするか、 [Compose Navigation](https://developer.android.com/develop/ui/compose/navigation?hl=ja) ( [ComposeNavigator](https://developer.android.com/reference/kotlin/androidx/navigation/compose/ComposeNavigator) ) を使用して、Navigation デスティネーションにできるだけ近いコンポーズ可能な関数で ViewModel を使用します。これは、ViewModel のスコープを Navigation デスティネーション、Navigation グラフ、アクティビティ、フラグメントに設定できるためです。


## ViewModel を実装する

ユーザーがサイコロを振ることができる画面の ViewModel の実装例を次に示します。

重要: この例で、ユーザーリストの取得と保持は、アクティビティやフラグメントが直接行うのではなく、ViewModel が担います。

```kotlin
data class DiceUiState(
    val firstDieValue: Int? = null,
    val secondDieValue: Int? = null,
    val numberOfRolls: Int = 0,
)

class DiceRollViewModel : ViewModel() {

    // 画面 UI 状態を公開する
    private val _uiState = MutableStateFlow(DiceUiState())
    val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()

    // ビジネスロジック
    fun rollDice() {
        _uiState.update { currentState ->
            currentState.copy(
                firstDieValue = Random.nextInt(from = 1, until = 7),
                secondDieValue = Random.nextInt(from = 1, until = 7),
                numberOfRolls = currentState.numberOfRolls + 1,
            )
        }
    }
}
```

次のように、ViewModel にはアクティビティからアクセスできます。

```kotlin
import androidx.activity.viewModels

class DiceRollActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        // システムがアクティビティの onCreate() メソッドを初めて呼び出したときに ViewModel を作成します。
        // 再作成されたアクティビティは、最初のアクティビティによって作成されたものと同じ DiceRollViewModel インスタンスを受け取ります。

        // 'by viewModels()' プロパティデリゲートを使用します
        val viewModel: DiceRollViewModel by viewModels()
        // Activity スコープのコルーチンを生成する
        lifecycleScope.launch {
            // this が省略されているため、 Activity のライフサイクルに紐づけられている。
            // Acitivity のライフサイクルが STARTED 以上になった場合に新しいコルーチンを生成して、
            // ブロック内の処理を実行する。
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect {
                    // Update UI elements
                }
            }
        }
    }
}
```

**注意**: ViewModel では、ビュー、Lifecycle、またはアクティビティ コンテキストへの参照が保持されている可能性があるクラスを通常は参照しないようにします。ViewModel のライフサイクルは UI よりも大きいため、ViewModel にライフサイクル関連の API を保持するとメモリリークが発生する可能性があります。

注: Android プロジェクトに ViewModel をインポートするには、 [ライフサイクルのリリースノート](https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=ja&_gl=1*1eigvac*_up*MQ..*_ga*OTUyMjc1MjUxLjE3MjE4OTg2NzQ.*_ga_6HH9YJMN9M*MTcyMTk2MTI4Ny4yLjAuMTcyMTk2MTI4Ny4wLjAuMA..#declaring_dependencies) にある依存関係の宣言手順を参照してください。

`by viewModels()` デリゲーションでは、具体的な型を指定しなくても、型推論によって、具体的な ViewModel のインスタンスが生成されます。 `viewModels<T>()` のように、ジェネリクスが使用されています。


### ViewModel でコルーチンを使用する

ViewModel には、Kotlin コルーチンのサポートが含まれています。UI 状態を永続化する場合と同じ方法で、非同期処理を永続化できます。

詳しくは、 [Android アーキテクチャコンポーネントで Kotlin コルーチンを使用する](../5.ライフサイクル対応コンポーネントで%20Kotlin%20コルーチンを使用する.md) をご覧ください。


## ViewModel のライフサイクル

ViewModel のライフサイクルは、設定されている ViewModelStoreOwner が消えるまでメモリ内にとどまります。主な ViewModel の破棄のタイミングは以下の通りです。

| ViewModelStoreOwner | ViewModel が破棄されるタイミング |
| ------------------- | -------------------------------- |
| アクティビティ      | 明示的な破棄時                   |
| フラグメント        | デタッチ時                       |
| Navigation エントリ | バックスタックからの削除時       |


### ViewModel の依存関係をクリアする

ViewModel は、ライフサイクル中に ViewModelStoreOwner によって破棄されると、 `onCleared` メソッドが呼び出されます。これにより、ViewModel のライフサイクルに従う処理や依存関係をクリーンアップできます。

次の例は、カスタムコルーチンスコープを `onCleared` 関数で、クリーンアップ (キャンセル) する例です。通常、 ViewModel 内で実行される処理は、組み込みの viewModelScope を使用しますが、テストを容易にするためにカスタムスコープのコルーチンを使用したいとします。

```kotlin
class MyViewModel(
    private val coroutineScope: CoroutineScope =
        CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)
) : ViewModel() {

    // Other ViewModel logic ...

    // ViewModel が破棄される際に呼ばれるコールバック
    override fun onCleared() {
        // この coroutineScope は、 ViewModel のスコープに
        // 連動していないため、明示的にスコープをキャンセルして、
        // クリーンアップします。
        coroutineScope.cancel()
    }
}
```

ライフサイクル バージョン 2.5 以降では、 ViewModel のコンストラクタに 1 つ以上の Closeable オブジェクトを渡すことができます。 Closable オブジェクトは、 close 関数を持っており、これは、 ViewModel のインスタンスが破棄されるときに、自動的に呼ばれます。

```kotlin
// Closable インターフェースを実装したクラス
class CloseableCoroutineScope(
    context: CoroutineContext = SupervisorJob() + Dispatchers.Main.immediate
) : Closeable, CoroutineScope {
    override val coroutineContext: CoroutineContext = context

    // close 関数は、 ViewModel が破棄される際に呼ばれます。
    override fun close() {
        coroutineContext.cancel()
    }
}

class MyViewModel(
    private val coroutineScope: CoroutineScope = CloseableCoroutineScope()
) : ViewModel(coroutineScope) {
    // Other ViewModel logic ...
}
```


## ベストプラクティス

ViewModel を実装する際は、次の主要なベスト プラクティスを行う必要があります。

- ViewModel を画面レベルの状態ホルダーの実装の詳細として使用します。再利用可能な UI コンポーネント（チップグループやフォームなど）の状態ホルダーとしては使用しないでください。そうしないと、チップごとに明示的なビューモデルキーを使用する場合を除き、同じ ViewModelStoreOwner の下で、同じ UI コンポーネントを異なる使用法で使用して同じ ViewModel インスタンスを取得します。
- ViewModel が、UI 実装の詳細を認識しないようにします。ViewModel API が公開するメソッドの名前と、UI の状態フィールドの名前は、できるだけ汎用的なものにしてください。このようにすることで、ViewModel があらゆる種類の UI（スマートフォン、折りたたみ式デバイス、タブレット、Chromebook）に対応できるようになります。
- ViewModel は ViewModelStoreOwner よりも長く存続する可能性があるため、メモリリークを防ぐため、Context や Resources など、ライフサイクル関連の API の参照を保持しないでください。
- ViewModel を他のクラス、関数、その他の UI コンポーネントに渡さないようにします。プラットフォームで管理するため、可能な限りプラットフォームの近くに置く必要があります。アクティビティ、フラグメント、画面レベルのコンポーズ可能な関数の近くです。これにより、下位レベルのコンポーネントが必要以上にデータやロジックにアクセスすることを防止できます。



## 追加情報

データの複雑さが増すと、データの読み込みのためだけに別のクラスを使用することがあります。ViewModel の目的は、UI コントローラのデータをカプセル化して、構成の変更後にもデータが引き継がれるようにすることです。構成の変更の前後におけるデータの読み込み、永続化、管理の方法については、 [保存された UI の状態](../4.UI%20の状態を保存する.md) をご覧ください。

Android アプリのアーキテクチャ ガイドでは、これらの機能を処理するためにリポジトリ クラスを作成することが推奨されています。



