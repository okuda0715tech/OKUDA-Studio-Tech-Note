- [UI の状態を保存する](#ui-の状態を保存する)
  - [ユーザーの期待とシステムの動作](#ユーザーの期待とシステムの動作)
    - [ユーザーが開始する UI の状態の破棄](#ユーザーが開始する-ui-の状態の破棄)
    - [システムによって開始される UI の状態の解除](#システムによって開始される-ui-の状態の解除)
  - [UI の状態の保持オプション](#ui-の状態の保持オプション)
  - [ViewModel を使用して構成の変更を処理する](#viewmodel-を使用して構成の変更を処理する)
  - [システムによるプロセスの終了を保存済みインスタンスでバックアップする](#システムによるプロセスの終了を保存済みインスタンスでバックアップする)
    - [SavedStateRegistry を使用して保存済み状態に接続する](#savedstateregistry-を使用して保存済み状態に接続する)
  - [永続ローカル ストレージを使用して、複雑なデータまたは大規模なデータのプロセスの終了を処理する](#永続ローカル-ストレージを使用して複雑なデータまたは大規模なデータのプロセスの終了を処理する)
  - [UI の状態の管理 : 分割統治](#ui-の状態の管理--分割統治)
  - [複雑な状態の復元 : 断片を組み立て直す](#複雑な状態の復元--断片を組み立て直す)


# UI の状態を保存する

このガイドでは、UI の状態に関するユーザーの期待と、状態を保持するために利用できるオプションについて説明します。

システムによってアクティビティまたはアプリが破棄された後、アクティビティの UI の状態をすばやく保存して復元することは、優れたユーザー エクスペリエンスに不可欠です。ユーザーは UI の状態が変わらないことを期待しますが、アクティビティとその保存されている状態はシステムによって破棄される可能性があります。

ユーザーの期待とシステムの動作のギャップを埋めるには、次の方法を組み合わせて使用します。

- ViewModel オブジェクト
- 次のコンテキストで保存されたインスタンスの状態
  - Jetpack Compose : rememberSaveable
  - Activity / Fragment : onSaveInstanceState() API
  - ViewModel : SavedStateHandle
- アプリとアクティビティの遷移中に UI の状態を保持するローカル ストレージ

最適なソリューションは、次の要素によって、決まります。

- UI データの複雑さ
- アプリのユースケース
- データアクセス速度とメモリ使用量のバランス

アプリがユーザーの期待を満たし、高速でレスポンシブなインターフェースを提供するようにします。UI にデータを読み込む際、特に回転などの一般的な構成変更の後で、遅延が発生しないようにします。


## ユーザーの期待とシステムの動作

ユーザーは自分が行う操作に応じて、アクティビティ状態がクリアされる、または保持されることを期待します。ユーザーが期待する処理が、システムによって自動的に実行される場合もあれば、ユーザーの期待とは逆の処理が実行されることもあります。


### ユーザーが開始する UI の状態の破棄

アクティビティを開始したユーザーは、 **ユーザー自身が、そのアクティビティを明示的に終了するまで、その時点での一時的な UI の状態が変わらないことを期待します。** ユーザーがアクティビティを明示的に終了する方法には次のものがあります。

- アクティビティをスワイプして最近使用したアプリ一覧から削除する。
- 設定画面でアプリを中止または強制終了する。
- デバイスを再起動する。
- なんらかの 「終了」 アクション ( Activity.finish() 系) を完了する。

これらのケースにおいては、システムの動作はユーザーの期待に一致するため、ほとんどの場合、何も実装を行う必要はありません。つまり、 **アクティビティインスタンスは、そのインスタンスに保存されている状態と、アクティビティに関連するデータをメモリ上から削除します。**

まれにこの動作がユーザーの期待と異なるユースケースがあります。たとえば、最近使用したアプリの一覧からブラウザアプリを終了する場合、ユーザーは、最後に閲覧していたウェブページが再びブラウザに表示されることを期待している場合があります。


### システムによって開始される UI の状態の解除

ユーザーが期待するのは、構成の変更 (**たとえば回転やマルチウィンドウ モードへの切り替え**) 後も、アクティビティの UI の状態が変わらないことです。しかし、デフォルトでは、そうした構成の変更後にアクティビティは破棄され、アクティビティインスタンスに保存されている UI の状態はすべてワイプ (除去) されます。デバイスの構成について詳しくは、 [Configuration のリファレンス](https://developer.android.com/reference/android/content/res/Configuration?hl=ja&_gl=1*1ot9wlw*_up*MQ..*_ga*MTE3NjE0ODY1NC4xNzIxOTcyNjA1*_ga_6HH9YJMN9M*MTcyMjE1NDk2MC4zLjAuMTcyMjE1NTI0OS4wLjAuMA..#lfields) ページをご覧ください。なお、構成変更のデフォルトの動作をオーバーライドすることもできます（ただし、推奨されません）。詳しくは、 [構成の変更を自分で処理する](https://developer.android.com/guide/topics/resources/runtime-changes?hl=ja&_gl=1*1mt9w2n*_up*MQ..*_ga*MTE3NjE0ODY1NC4xNzIxOTcyNjA1*_ga_6HH9YJMN9M*MTcyMjE1NDk2MC4zLjAuMTcyMjE1NTI0OS4wLjAuMA..#HandlingTheChange) をご覧ください。

ユーザーはまた、一時的に別のアプリに切り替えた後に元のアプリに戻ってきたときも、アクティビティの UI の状態が変わっていないことを期待します。たとえば、検索アクティビティで検索を実行した後、ホームボタンを押すか電話に出たユーザーは、その後検索アクティビティに戻ったときに前とまったく同じ検索キーワードと検索結果がまだ表示されていることを期待します。

このシナリオではアプリはバックグラウンドにあり、システムは、アプリのプロセスをメモリに保持しようと最善を尽くします。しかし、ユーザーが元のアプリを離れ、他のアプリを操作している間にアプリのプロセスがシステムによって破棄されることがあります。この場合、アクティビティ インスタンスは、そのインスタンスに保存されているすべての状態と一緒に破棄されます。ユーザーがアプリを再起動すると、アクティビティは期待に反してクリーンな状態になります。プロセス停止について詳しくは、 [プロセスとアプリのライフサイクル](https://developer.android.com/guide/components/activities/process-lifecycle?hl=ja&_gl=1*1mt9w2n*_up*MQ..*_ga*MTE3NjE0ODY1NC4xNzIxOTcyNjA1*_ga_6HH9YJMN9M*MTcyMjE1NDk2MC4zLjAuMTcyMjE1NTI0OS4wLjAuMA..) をご覧ください。


## UI の状態の保持オプション

UI の状態に関するユーザーの期待がデフォルトのシステム動作と一致しない場合は、システムによる破棄がユーザーに影響を与えないよう、ユーザーの UI の状態を保存し、復元する必要があります。

UI の状態の保持オプションは、ユーザー エクスペリエンスに影響を与える次の項目によって異なります。

|                                                    | ViewModel                                                                    | 保存済みインスタンスの状態 (※ 1 )                                      | 永続ストレージ                                                                                              |
| -------------------------------------------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| 保存先                                             | メモリ内                                                                     | メモリ内                                                       | ディスクまたはネットワーク上                                                                                |
| 構成変更後も保持                                   | ○                                                                            | ○                                                              | ○                                                                                                           |
| システムによるプロセス終了後も保持                 | ×                                                                            | ○                                                              | ○                                                                                                           |
| ユーザーによるアクティビティ終了 or onFinish() 後も保持 | ×                                                                            | ×                                                              | ○                                                                                                           |
| データの上限                                       | 複雑なオブジェクトは問題ないが、使用可能なメモリによってスペースが制限される | プリミティブ型と String などのシンプルな小さなオブジェクトのみ | ネットワーク リソースからのディスク スペースまたはネットワークからの取得コスト / 時間によってのみ制限される |
| 読み取り / 書き込み時間                            | 高速（メモリアクセスのみ）                                                   | 低速（シリアル化 / シリアル化解除が必要）                      | 低速（ディスク アクセスまたはネットワーク トランザクションが必要）                                          |

(※ 1 ) 保存済みインスタンスの状態には、onSaveInstanceState() API と rememberSaveable API、および ViewModel の一部としての SavedStateHandle が含まれています。


## ViewModel を使用して構成の変更を処理する

ユーザーがアプリをアクティブに使用している場合は、ViewModel を使用して、UI 関連データを保存し管理することをおすすめします。これにより、UI データに迅速にアクセスでき、回転やウィンドウのサイズ変更などの一般的な構成変更の後もネットワークやディスクからのデータの再取得を回避できます。ViewModel の実装方法については、ViewModel ガイドをご覧ください。

ViewModel ではデータがメモリに保持されます。つまり、ディスクやネットワークからデータを取得するよりもコストがかかりません。ViewModel はアクティビティ（または他のライフサイクル所有者）に関連付けられており、構成の変更中はメモリに保持されます。その後、構成の変更後に生成された新しいアクティビティ インスタンスへの ViewModel の関連付けがシステムによって自動的に行われます。

ViewModel は、ユーザーがアクティビティまたはフラグメントを終了するかアプリが finish() を呼び出すと、自動的に破棄されます。つまり、こうしたシナリオでは、ユーザーの期待どおりに状態がクリアされます。

保存済みインスタンスの状態とは異なり、ViewModel はシステムによって開始されたプロセスの終了時に破棄されます。システムによってプロセスが終了させられた後、 **ViewModel でデータの再読み込みを行うには、SavedStateHandle API を使用します。または、データが UI に関連していて ViewModel で保持する必要がない場合は、ビューシステムの onSaveInstanceState() または Jetpack Compose の rememberSaveable を使用します。** データがアプリデータである場合は、ディスクに保存する方が適切です。

構成が変わっても UI の状態が保存されるメモリ内ソリューションがすでに存在する場合は、ViewModel を使用する必要はありません。


## システムによるプロセスの終了を保存済みインスタンスでバックアップする

ビューシステムの onSaveInstanceState() コールバック、Jetpack Compose の rememberSaveable、ViewModel の SavedStateHandle は、アクティビティやフラグメントなどの UI コントローラをシステムが破棄した後で再作成する場合、UI コントローラの状態の再読み込みに必要なデータを保存します。onSaveInstanceState を使用して保存済みインスタンスの状態を実装する方法については、アクティビティ ライフサイクル ガイドのアクティビティの状態の保存と復元に関するトピックをご覧ください。

保存済みインスタンス状態のバンドルは、構成の変更後もプロセスの終了後も保持されますが、さまざまな API がデータのシリアル化を行うため、ストレージと速度が制限されます。シリアル化されるオブジェクトが複雑な場合、シリアル化によって大量のメモリが消費されることがあります。 **このプロセスは構成の変更時にメインスレッドで実行されるため、シリアル化に時間がかかりすぎるとフレームが欠けたり、画面がスムーズに表示されないことがあります。**

キーポイント: 保存済みインスタンス状態 API は、Activity が停止した (STOPPED 状態になった) ときにのみ、アクティビティに書き込まれたデータを保存します。このライフサイクル状態の間に書き込みを行うと、次の停止ライフサイクル イベントまで保存オペレーションが延期されます。

**アプリのユースケースによっては、保存済みインスタンスの状態を使用する必要がまったくない場合もあります。** たとえば、ユーザーがブラウザアプリを明示的に終了し、その後、再度ブラウザアプリを起動したとします。この時、閲覧していたウェブページが、再び表示されるアプリを作成する場合、保存済みインスタンスで状態を保存する代わりに、データベース等にデータを永続化することで機能が実現できます。

**重要なポイント** : 通常、保存済みインスタンスの状態に保存されるデータは、ユーザーの入力またはナビゲーションに依存する一時的な状態です。たとえば、以下のものがあります。

- リストのスクロール位置
- ユーザーが詳細を確認したいと思うアイテムの ID
- 選択している途中のユーザー設定
- テキストフィールドへの入力

また、インテントからアクティビティを開くと、その Intent に Extra が付与されている場合があります。その場合は、保存済み状態から状態を復元するのではなく、 Extra から状態を生成する場合があります。

保持する UI データが単純かつ軽量である場合は、 ViewModel を使用せず、保存済みインスタンス状態 API のみを使用して状態データを保持する方法も検討できます。

**キーポイント** : 使用する API は、状態が保持される場所と、それに必要なロジックによって異なります。ビジネス ロジックで使用される状態の場合は、ViewModel に保持し、SavedStateHandle を使用して保存します。UI ロジックで使用される状態の場合は、ビューシステムの onSaveInstanceState API または Compose の rememberSaveable を使用します。


### SavedStateRegistry を使用して保存済み状態に接続する

SavedStateRegistry を使用すると、 Activity や Fragment の Bundle への状態保存処理を、 Activity や Fragment から切り離すことが可能です。

```kotlin
// カスタム SavedStateProvider クラスの定義
class SearchManager(registryOwner: SavedStateRegistryOwner) : SavedStateRegistry.SavedStateProvider {
    companion object {
        // プロバイダー名の定義
        private const val PROVIDER = "search_manager"
        private const val QUERY = "query"
    }

    private val query: String? = null

    init {
        // レジストリオーナーのライフライフサイクルを監視する。
        registryOwner.lifecycle.addObserver(LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_CREATE) {
                // レジストリオーナーからレジストリを取得する。
                val registry = registryOwner.savedStateRegistry

                // SavedStateRegistry に、プロバイダ名を指定して、このプロバイダ ( SearchManager ) を登録する。
                // Activity や Fragment の onCreate 内の
                // super.onCreate を呼び出した後に登録が可能です。
                // このコードのように、レジストリオーナーを監視して、
                // その ON_CREATE イベントが発生した際に登録することも可能です。
                registry.registerSavedStateProvider(PROVIDER, this)

                // 名前を指定してプロバイダを取得し、そのプロバイダで生成した Bundle を取得する。
                val state = registry.consumeRestoredStateForKey(PROVIDER)

                // Bundle から、以前に保存した状態を取得する。
                query = state?.getString(QUERY)
            }
        }
    }

    // Bundle を生成する独自処理
    // レジストリオーナーが STOPPED 状態になった際に呼ばれる。
    override fun saveState(): Bundle {
        return bundleOf(QUERY to query)
    }

    ...
}

class SearchFragment : Fragment() {
    private var searchManager = SearchManager(this)
    ...
}
```

注: SavedStateRegistry は、他の保存済みインスタンス状態 API と同じ Bundle にデータを保存するので、同じ考慮事項とデータ制限が適用されます。


## 永続ローカル ストレージを使用して、複雑なデータまたは大規模なデータのプロセスの終了を処理する

当たり前の内容なので、省略します。


## UI の状態の管理 : 分割統治

永続ストレージに保存するか、 ViewModel で保持するか、保存済み状態で保持するか考えましょうという話。当たり前なので、省略します。


## 複雑な状態の復元 : 断片を組み立て直す

今までの話をまとめると、システムによってアプリが強制終了させられた場合と、構成変更が発生した場合は、 「保存済み状態」 と 「 ViewModel 」 を使用して、適切に状態を保存することが望ましいということになります。それ以外の場合は、何も手を加えなくても、ユーザーの期待通りになっている可能性が高いです。

