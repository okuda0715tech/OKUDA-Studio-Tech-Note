- [DataStore](#datastore)
  - [Preferences DataStore と Proto DataStore](#preferences-datastore-と-proto-datastore)
  - [DataStore を正しく使用する](#datastore-を正しく使用する)
  - [セットアップ](#セットアップ)
    - [Preferences DataStore](#preferences-datastore)
    - [Proto DataStore](#proto-datastore)
  - [Preferences DataStore を使用して Key-Value ペアを保存する](#preferences-datastore-を使用して-key-value-ペアを保存する)
    - [Preferences DataStore を作成する](#preferences-datastore-を作成する)
    - [Preferences DataStore から読み取る](#preferences-datastore-から読み取る)
      - [注意点](#注意点)
    - [Preferences DataStore に書き込む](#preferences-datastore-に書き込む)
  - [Proto DataStore で型付きオブジェクトを保存する](#proto-datastore-で型付きオブジェクトを保存する)
    - [スキーマを定義する](#スキーマを定義する)
    - [Proto DataStore を作成する](#proto-datastore-を作成する)
    - [Proto DataStore から読み取る](#proto-datastore-から読み取る)
    - [Proto DataStore に書き込む](#proto-datastore-に書き込む)
  - [同期コードで（スレッドをブロックして） DataStore を使用する](#同期コードでスレッドをブロックして-datastore-を使用する)
  - [マルチプロセスコードで DataStore を使用する](#マルチプロセスコードで-datastore-を使用する)
  - [参考情報](#参考情報)
    - [サンプル](#サンプル)
    - [ブログ](#ブログ)
    - [Codelab](#codelab)


# DataStore

Jetpack DataStore は、 Key-Value ペア形式のデータや、 [プロトコルバッファ](https://protobuf.dev/) (※ 1 ) を使用した型付きオブジェクト形式のデータを格納できるデータ ストレージ ソリューションです。DataStore は、Kotlin コルーチンと Flow を使用して、データを非同期的に、一貫した形で、トランザクションとして保存します。

(※ 1 )  
Protocol Buffers（Protobuf）は、Googleが開発した効率的で柔軟なシリアライズフォーマットです。データをバイナリ形式でエンコードするため、JSONやXMLと比べてパフォーマンスに優れており、かつデータの構造を明確に定義できる点が特徴です。

現在 SharedPreferences を使用してデータを保存している場合は、DataStore に移行することを検討してください。

**注**: 大規模なデータセットや複雑なデータセット、部分更新、参照整合性をサポートする必要がある場合は、DataStore ではなく Room の使用を検討してください。DataStore は、小規模で単純なデータセットに適したものであり、部分更新や参照整合性をサポートしていないためです。


## Preferences DataStore と Proto DataStore

DataStore には、Preferences DataStore と Proto DataStore の 2 種類があります。

- **Preferences DataStore**
  - キーを使用してデータの保存およびアクセスを行います。
  - この実装では、スキーマを定義する必要ありません。
  - タイプセーフではありません。
- **Proto DataStore**
  - カスタムデータ型のインスタンスとしてデータを保存します。
  - この実装では、プロトコルバッファを使用してスキーマを定義する必要があります。
  - タイプセーフです。


## DataStore を正しく使用する

DataStore を正しく使用するには、常に次のルールに準拠してください。

1. **同じプロセス内の所定ファイルに対し DataStore の複数のインスタンスを作成しないこと。** 複数作成すると、DataStore のすべての機能を使用できなくなる可能性があります。同じプロセス内の所定ファイルに対しアクティブな DataStore インスタンスが複数あると、DataStore はデータのレンダリングまたは更新の際に IllegalStateException をスローします。

2. **DataStore の汎用型は不変でなければならない。** DataStore で使用される型を変えると、DataStore による保証が無効となり、重大な検出しにくいバグが発生する可能性があります。不変性が保証され、シンプルな API と効率的なシリアル化を実現するプロトコル バッファを使用することを強くおすすめします。

3. 同じファイルに対し **SingleProcessDataStore と MultiProcessDataStore を混在させない。** 複数のプロセスから DataStore にアクセスする場合は、常に [MultiProcessDataStore](https://developer.android.com/topic/libraries/architecture/datastore?hl=ja&_gl=1*ocoqmb*_up*MQ..*_ga*MTA2MDU2MzI0LjE3MjI5MjYzNjg.*_ga_6HH9YJMN9M*MTcyMjkyNjM2Ny4xLjAuMTcyMjkyNjM2Ny4wLjAuMA..#multiprocess) を使用します。


## セットアップ

アプリで Jetpack DataStore を使用するには、使用する実装に応じて Gradle ファイルに以下を追加します。


### Preferences DataStore

```kotlin
    // Preferences DataStore (SharedPreferences like APIs)
    dependencies {
        implementation("androidx.datastore:datastore-preferences:1.1.1")

        // optional - RxJava2 support
        implementation("androidx.datastore:datastore-preferences-rxjava2:1.1.1")

        // optional - RxJava3 support
        implementation("androidx.datastore:datastore-preferences-rxjava3:1.1.1")
    }

    // Android 以外で使用する場合
    dependencies {
        implementation("androidx.datastore:datastore-preferences-core:1.1.1")
    } 
```


### Proto DataStore

```kotlin
    // Typed DataStore (Typed API surface, such as Proto)
    dependencies {
        implementation("androidx.datastore:datastore:1.1.1")

        // optional - RxJava2 support
        implementation("androidx.datastore:datastore-rxjava2:1.1.1")

        // optional - RxJava3 support
        implementation("androidx.datastore:datastore-rxjava3:1.1.1")
    }

    // Android 以外で使用する場合
    dependencies {
        implementation("androidx.datastore:datastore-core:1.1.1")
    }
```

注: Proguard で datastore-preferences-core アーティファクトを使用する場合は、フィールドが削除されないように、Proguard ルールを proguard-rules.pro ファイルに手動で追加する必要があります。必要なルールは [こちら](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:datastore/datastore-preferences/proguard-rules.pro?hl=ja) で確認できます。


## Preferences DataStore を使用して Key-Value ペアを保存する

Preferences DataStore の実装では、DataStore クラスと Preferences クラスを使用して、単純な Key-Value ペアをディスクに保持します。


### Preferences DataStore を作成する

`preferencesDataStore()` 関数によって作成されたプロパティ デリゲートを使用して `Datastore<Preferences>` のインスタンスを作成します。kotlin ファイルのトップレベルでインスタンスを 1 回呼び出し、アプリケーションの他の部分でこのプロパティを介してアクセスします。これにより、DataStore をシングルトンとして簡単に保持できます。ただし、 RxJava を使用している場合は、 `RxPreferenceDataStoreBuilder` を使用してください。必須の `name` パラメータは、 Preferences DataStore の名前です。

```kotlin
// kotlin file のトップレベルに以下を記述します。
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")
```


### Preferences DataStore から読み取る

Preference DataStore は定義済みのスキーマを使用しないため、キーの定義時に、型を明示する関数を使用します。たとえば、int 値を保持するキーを定義するには、intPreferencesKey() を使用します。次に、DataStore.data プロパティを使用し、Flow を使って適切な保存値を公開します。

```kotlin
// example_counter とうい名前のキーを定義します。
// Int 型の値を格納することができます。
val EXAMPLE_COUNTER = intPreferencesKey("example_counter")

val exampleCounterFlow: Flow<Int> = context.dataStore.data
    .map { preferences ->
        // タイプセーフではありません。
        preferences[EXAMPLE_COUNTER] ?: 0
}
```

**参考** : PreferencesDataStore の data プロパティは、 Flow 型のデータを返します。 Flow は、コールドフローであるため、過去の値も放出するという特徴があります。しかし、実際には、 data プロパティが過去の値を放出することはありません。これは、 data プロパティが最新の値のみを保持しているためだそうです。


#### 注意点

上記の例では、 DataStore から一つの項目のみを取得していますが、実際には、一つの DataStore に複数の項目が含まれている場合が多く、その場合は、全ての項目を返すようにしたほうが良いです。

DataStore.data が返す Flow は、 Preferences オブジェクトであるため、そこから、一つのプリファレンスファイルに含まれる、すべての項目が取得可能です。

よって、項目ごとに Flow を作成するより、一つの Flow から全ての項目を取得するほうがコードが簡潔になると思います。

また、別の理由として、 DataStore.data が返す Flow 単体では、どの項目が更新されたのかがわかりません。もし、更新された項目を判別したい場合は、いったん、全部の項目を取得し、更新前の値と比較する必要があるため、どのみち、全部の項目を取得しなければいけないためです。

逆に、取得が不要で取得したくない項目がある場合は、その項目は、別のプリファレンスファイルに分離しましょう。分離することで、不要な更新通知を受け取ることを回避できます。

全部の項目を取得するサンプルを以下に示します。

```kotlin
val githubPreferences: Flow<GithubPreferences> = context.githubPrefDataStore.data
    .map { githubPref ->
        val pat = githubPref[PAT] ?: ""
        val patVisibility = githubPref[PAT_VISIBILITY] ?: false
        val retainPat = githubPref[RETAIN_PAT] ?: false
        
        GithubPreferences(pat = pat, patVisibility = patVisibility, retainPat = retainPat)
    }
```


### Preferences DataStore に書き込む

Preferences DataStore には、DataStore 内のデータをトランザクションとして更新する [edit()](https://developer.android.com/reference/kotlin/androidx/datastore/preferences/core/package-summary?hl=ja&_gl=1*1lgj5qy*_up*MQ..*_ga*MTA2MDU2MzI0LjE3MjI5MjYzNjg.*_ga_6HH9YJMN9M*MTcyMjkyNjM2Ny4xLjAuMTcyMjkyNjQzOS4wLjAuMA..#edit) 関数が用意されています。この関数の transform パラメータは、必要に応じて値を更新できるコードのブロックを受け入れます。変換ブロック内のすべてのコードは単一のトランザクションとして扱われます。このトランザクション機能は、 SharedPreferences よりも PreferencesDataStore を使用するメリットになります。

```kotlin
suspend fun incrementCounter() {
    context.dataStore.edit { settings ->
        // このブロック内は一つのトランザクションになっている。

        // 読み取り
        val currentCounterValue = settings[EXAMPLE_COUNTER] ?: 0
        // 書き込み
        settings[EXAMPLE_COUNTER] = currentCounterValue + 1
    }
}
```

## Proto DataStore で型付きオブジェクトを保存する

Proto DataStore 実装では、DataStore と [プロトコルバッファ](https://protobuf.dev/) を使用して型付きオブジェクトをディスクに保存します。


### スキーマを定義する

Proto DataStore では、 `app/src/main/proto/` ディレクトリの `xxx.proto` ファイル内に定義済みスキーマが必要です。このスキーマは、Proto DataStore で保持するオブジェクトの型を定義します。proto スキーマの定義の詳細については、 [protobuf 言語ガイド](https://developers.google.com/protocol-buffers/docs/proto3?hl=ja) 、もしくは、 [proto スキーマの定義](./proto%20スキーマの定義.md) をご覧ください。

```proto
// proto3 シンタックスを使用することを宣言
// もし記述しなかった場合は proto2 が使用されます。
// 必ず、最初の一行目に記述する必要があります。
syntax = "proto3";

option java_package = "com.example.application";
option java_multiple_files = true;

message Settings {
    int32 example_counter = 1;
}
```

### Proto DataStore を作成する

まずは、以下のコードを確認してください。

```kotlin
// Serializer<T> を実装するクラスを定義する。
object SettingsSerializer : Serializer<Settings> {

    // デフォルト値を設定
    override val defaultValue: Settings = Settings.getDefaultInstance()

    // 読み取り方法を定義
    override suspend fun readFrom(input: InputStream): Settings {
        try {
            return Settings.parseFrom(input)
        } catch (exception: InvalidProtocolBufferException) {
            throw CorruptionException("Cannot read proto.", exception)
        }
    }

    // 書き込み方法を定義
    override suspend fun writeTo(
        t: Settings,
        output: OutputStream) = t.writeTo(output)
}

// プロパティデリゲートを使用して、 DataStore<T> のインスタンスを生成
val Context.settingsDataStore: DataStore<Settings> by dataStore(
    // データの保存に使用するファイルの名前
    fileName = "settings.pb",
    // 上で定義したシリアライザークラスを渡す
    serializer = SettingsSerializer
)
```

型付きオブジェクトを格納する Proto DataStore を作成するには、次の 2 つの手順を行います。

1. `Serializer<T>` を実装するクラスを定義します。ここで、 `T` は proto ファイルで定義される型です。このシリアライザー クラスは、データ型の読み取り / 書き込みの方法を DataStore に指示します。まだファイルが作成されていない場合は、使用するシリアライザーのデフォルト値を必ず指定してください。
2. dataStore によって作成されたプロパティ デリゲートを使用して、DataStore<T> のインスタンスを作成します。ここで、T は proto ファイルで定義される型です。kotlin ファイルの最上位でインスタンスを 1 回呼び出し、アプリの他の部分でこのプロパティ デリゲートを介してアクセスします。filename パラメータは、データの保存に使用するファイルを DataStore に指示します。serializer パラメータは、手順 1 で定義されたシリアライザー クラスの名前を DataStore に指示します。


### Proto DataStore から読み取る

DataStore.data を使用して、保存されたオブジェクトから適切なプロパティの Flow を公開します。

```kotlin
val exampleCounterFlow: Flow<Int> = context.settingsDataStore.data
    .map { settings ->
        // exampleCounter プロパティは、スキーマから生成されます。
        settings.exampleCounter
    }
```

### Proto DataStore に書き込む

Proto DataStore には、保存されたオブジェクトをトランザクションとして更新する [updateData()](https://developer.android.com/reference/kotlin/androidx/datastore/core/DataStore?hl=ja&_gl=1*xqliaw*_up*MQ..*_ga*MTA2MDU2MzI0LjE3MjI5MjYzNjg.*_ga_6HH9YJMN9M*MTcyMjkyNjM2Ny4xLjAuMTcyMjkyNjQzOS4wLjAuMA..#updatedata) 関数が用意されています。updateData() は、データ型のインスタンスとしてデータの現在の状態を提供し、アトミックな読み取り - 書き込み - 修正オペレーションでデータをトランザクションとして更新します。

```kotlin
suspend fun incrementCounter() {
    context.settingsDataStore.updateData { currentSettings ->
        currentSettings.toBuilder()
            .setExampleCounter(currentSettings.exampleCounter + 1)
            .build()
    }
}
```


## 同期コードで（スレッドをブロックして） DataStore を使用する

**注意**: 可能な限り、DataStore のデータ読み取りでスレッドがブロックされないようにしてください。UI スレッドをブロックすると、ANR や UI ジャンクが発生する可能性があります。また、他のスレッドをブロックすると、デッドロックが発生する可能性があります。

DataStore の主なメリットの 1 つは非同期 API ですが、コード全体を常に非同期に変更できるわけではありません。これは、同期ディスク I/O を使用する既存のコードベースを利用している場合や、非同期 API を提供しない依存関係がある場合などに問題になります。

Kotlin のコルーチンには、同期コードと非同期コードの間のギャップを埋めるための runBlocking() コルーチン ビルダーが用意されています。runBlocking() を使用すると、DataStore からデータを同期的に読み取ることができます。 RxJava では、Flowable でブロック メソッドが用意されています。次のコードは、DataStore がデータを返すまで呼び出し元のスレッドをブロックします。

```kotlin
val exampleData = runBlocking { context.dataStore.data.first() }
```

UI スレッドで同期 I/O オペレーションを実行すると、ANR や UI ジャンクが発生することがあります。この問題は、DataStore から非同期でデータをプリロードすることで軽減できます。

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    lifecycleScope.launch {
        context.dataStore.data.first()
        // IOExeption もここで処理する必要があります。
    }
}
```

このようにして、DataStore はデータを非同期的に読み取り、メモリ内にキャッシュします。最初に行われる読み取りがすでに完了している場合は、後で行われる runBlocking() を使用した同期読み取りがより高速になるか、ディスク I/O オペレーションを完全に回避することがあります。


## マルチプロセスコードで DataStore を使用する

注: DataStore マルチプロセスは現在、1.1.0 リリースで使用できます。

1 つのプロセス内の場合と同じデータの整合性を保証することで複数のプロセスから同じデータにアクセスできるよう DataStore を構成することができます。特に、DataStore は以下の点を保証します。

- 読み取りでは、ディスクに永続化されたデータのみを返す。
- 書き込み後の読み取りの整合性。
- 書き込みがシリアル化される。
- 読み取りが書き込みでブロックされない。

サービスとアクティビティを含むサンプルアプリがあるとします。

1. サービスは別のプロセスで実行され、DataStore を定期的に更新します。

```xml
<service
    android:name=".MyService"
    android:process=":my_process_id" />
```

重要: 別のプロセスでサービスを実行するには、android:process 属性を使用します。プロセス ID には接頭辞としてコロン（「:」）が付加されています。これにより、サービスは新しいプロセスで、アプリケーションに対して非公開で実行されます。

```kotlin
override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    scope.launch {
        while(isActive) {
            dataStore.updateData {
                Settings(lastUpdate = System.currentTimeMillis())
            }
            delay(1000)
        }
    }
}
```

2. 一方、アプリはその変更を収集して UI を更新します。

```kotlin
val settings: Settings by dataStore.data.collectAsState()
Text(
    text = "Last updated: $${settings.timestamp}",
)
```

複数のプロセスで DataStore を使用できるようにするには、MultiProcessDataStoreFactory を使用して DataStore オブジェクトを作成する必要があります。

```kotlin
val dataStore: DataStore<Settings> = MultiProcessDataStoreFactory.create(
   serializer = SettingsSerializer(),
   produceFile = {
       File("${context.cacheDir.path}/myapp.preferences_pb")
   }
)
```

serializer はデータ型の読み取り / 書き込みの方法を DataStore に指示します。まだファイルが作成されていない場合は、使用するシリアライザーのデフォルト値を必ず指定してください。 [kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization) を使用する実装例を以下に示します。

```kotlin
@Serializable
data class Settings(
   val lastUpdate: Long
)

@Singleton
class SettingsSerializer @Inject constructor() : Serializer<Settings> {

    override val defaultValue = Settings(lastUpdate = 0)

    override suspend fun readFrom(input: InputStream): Timer =
        try {
            // Json 形式の文字列をオブジェクトに変換する。
            Json.decodeFromString(
               Settings.serializer(), input.readBytes().decodeToString()
            )
        } catch (serialization: SerializationException) {
            throw CorruptionException("Unable to read Settings", serialization)
        }

    override suspend fun writeTo(t: Settings, output: OutputStream) {
        output.write(
            // オブジェクトを Json 形式の文字列に変換する。
            Json.encodeToString(Settings.serializer(), t)
               .encodeToByteArray()
        )
    }
}
```

Hilt 依存関係インジェクションを使用して、DataStore のインスタンスがプロセスごとに一意になるようにします。

```kotlin
@Provides
@Singleton
fun provideDataStore(@ApplicationContext context: Context): DataStore<Settings> = MultiProcessDataStoreFactory.create(...)
```

## 参考情報

Jetpack DataStore の詳細については、以下の参考情報をご覧ください。

### サンプル

[Now in Android App - Github](https://github.com/android/nowinandroid/tree/main)


### ブログ

- [Jetpack DataStore を使用してデータを保存する](https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html)


### Codelab

- [Preferences DataStore を使用する](https://codelabs.developers.google.com/codelabs/android-preferences-datastore?hl=ja)
- [Proto DataStore を使用する](https://codelabs.developers.google.com/codelabs/android-proto-datastore?hl=ja)



