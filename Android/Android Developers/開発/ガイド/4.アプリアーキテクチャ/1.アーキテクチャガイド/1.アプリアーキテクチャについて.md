- [アプリアーキテクチャについて](#アプリアーキテクチャについて)
  - [アプリの推奨アーキテクチャ](#アプリの推奨アーキテクチャ)
    - [UI レイヤ](#ui-レイヤ)
    - [データレイヤー](#データレイヤー)
    - [ドメインレイヤ](#ドメインレイヤ)
  - [コンポーネント間の依存関係を管理する](#コンポーネント間の依存関係を管理する)
  - [一般的なベスト プラクティス](#一般的なベスト-プラクティス)
    - [アプリのエントリポイントをデータソースにしないでください](#アプリのエントリポイントをデータソースにしないでください)
    - [Android クラスへの依存を減らします](#android-クラスへの依存を減らします)
    - [アプリの各種モジュール間の役割の境界を明確に定義します。](#アプリの各種モジュール間の役割の境界を明確に定義します)
    - [各モジュールからの公開はできるだけ行わないでください。](#各モジュールからの公開はできるだけ行わないでください)
    - [アプリの特別な部分に焦点を当てて、他のアプリとの差別化を図ります。](#アプリの特別な部分に焦点を当てて他のアプリとの差別化を図ります)
    - [アプリの各部分を個別にテストできるようにする方法を検討します。](#アプリの各部分を個別にテストできるようにする方法を検討します)
    - [型は同時実行ポリシーに関する責任を負います。](#型は同時実行ポリシーに関する責任を負います)
    - [データの関連性と新鮮さをできる限り維持します。](#データの関連性と新鮮さをできる限り維持します)


# アプリアーキテクチャについて

## アプリの推奨アーキテクチャ

アーキテクチャに関する一般的な原則を考慮すると、各アプリに少なくとも 2 つのレイヤが必要です。

画面にアプリデータを表示する UI レイヤ。
アプリのビジネス ロジックを含み、アプリデータを公開するデータレイヤ。

<img src="./画像/一般的なアーキテクチャの図.png" width="400">

ドメインレイヤというレイヤを追加することで、 UI レイヤとデータレイヤの間のやり取りを簡素化でき、再利用できます。

このガイドの図にある矢印は、クラス間の依存関係を表しています。たとえば、ドメインレイヤはデータレイヤクラスに依存しています。


### UI レイヤ

UI レイヤ (またはプレゼンテーションレイヤ) の役割は、アプリデータを画面に表示することです。ユーザー操作（ボタンの押下など）または外部入力 (ネットワークレスポンスなど) によってデータが変更されるたびに、変更を反映するように UI を更新する必要があります。

UI レイヤは次の 2 つのもので構成されています。

データを画面にレンダリングする UI 要素。これらの要素は、 View または Jetpack Compose 関数を使用して作成します。
データを保持して UI に公開し、ロジックを処理する状態ホルダー ( ViewModel クラスなど) 。

<img src="./画像/UIレイヤの役割.png" width="400">


### データレイヤー

アプリのデータレイヤには、ビジネスロジックが含まれています。 **ビジネスロジックはアプリに価値をもたらすものであり、アプリがデータを作成、保存、変更する方法を決定するルールで構成されています。**

データレイヤは、それぞれが 0 から多数のデータソースを含むことができるリポジトリで構成されています。アプリで処理するデータの種類ごとにリポジトリクラスを作成する必要があります。たとえば、映画に関するデータであれば MoviesRepository クラス、支払いに関するデータであれば PaymentsRepository クラスを作成します。

<img src="./画像/データレイヤの役割.png" width="400">

リポジトリクラスは、次のタスクを行います。

- アプリの他の部分にデータを公開する。
- データの変更を一元管理する。
- 複数のデータソース間の競合を解決する。
  - 例えば、リモートリポジトリとローカルリポジトリのデータを統合する役割があります。
- アプリの他の部分からデータソース (リモートリポジトリやろーかるリポジトリ) を抽象化する。
- ビジネスロジックを格納する。

各データソースクラスは、ファイル、ネットワークソース、ローカルデータベースなど、 1 つのデータソースのみを処理する役割を担う必要があります。データソースクラスは、データオペレーションのためにアプリとシステムの橋渡しをします。


### ドメインレイヤ

ドメインレイヤは、 UI レイヤとデータレイヤの間に位置するオプションのレイヤです。

ドメインレイヤは、複雑なビジネスロジック、または複数の ViewModel で再利用される単純なビジネスロジックをカプセル化します。すべてのアプリにこのような要件があるわけではないため、このレイヤはオプションです。複雑さに対処する場合や再利用性を優先する場合など、必要な場合にのみ使用してください。

<img src="./画像/ドメインレイヤの役割.png" width="400">

通常、このレイヤのクラスを「ユースケース」または「インタラクタ」と呼びます。各ユースケースは 1 つの機能を担うべきです。たとえば、複数の ViewModel (複数の画面) が、タイムゾーンに基づいて適切なメッセージを画面に表示する場合、アプリに GetTimeZoneUseCase クラスを持たせることができます。


## コンポーネント間の依存関係を管理する

アプリのクラスは、適切に機能するために他のクラスに依存しています。次のいずれかのデザイン パターンを使用して、特定のクラスの依存関係を収集できます。

- [依存関係の注入 ( DI )](https://developer.android.com/training/dependency-injection?hl=ja&_gl=1*1xgswjm*_up*MQ..*_ga*MTIyMDQ1Njk3OC4xNzIwMDc4MzAy*_ga_6HH9YJMN9M*MTcyMDA3ODMwMi4xLjAuMTcyMDA3ODMwMi4wLjAuMA..) : 依存関係の注入を利用すると、クラスの依存関係を構築することなく定義できます。ランタイムには、別のクラスがこの依存関係を提供します。
- [サービスロケータ](https://en.wikipedia.org/wiki/Service_locator_pattern) : サービスロケータパターンでは、クラスが依存関係を作成せずに取得できるレジストリが提供されます。

こうしたパターンでは、コードが重複して煩雑になることなく依存関係を明確に管理できるため、コードの拡張が可能になります。さらに、テスト版と製品版の実装を簡単に切り替えることができます。

依存関係の注入のパターンに沿って、 Android アプリで Hilt ライブラリを使用することをおすすめします。 Hilt では、依存関係ツリーをたどって自動的にオブジェクトが構築され、コンパイル時の依存関係が保証され、 Android フレームワーククラスの依存関係コンテナが作成されます。


## 一般的なベスト プラクティス

プログラミングは創造的な活動であり、Android アプリの作成も例外ではありません。問題の解決方法は数多くあります。複数のアクティビティやフラグメント間でデータをやり取りする、リモートデータを取得してオフライン モード用にローカルで永続化するなど、重要なアプリで対処する一般的なシナリオにはさまざまなものがあります。

以下の推奨事項は必須ではありませんが、ほとんどの場合これに沿うことで、コードベースの堅牢性を高め、テストとメンテナンスを長期にわたって容易に実施できるようになります。


### アプリのエントリポイントをデータソースにしないでください

アプリのエントリポイント (アクティビティ、サービス、ブロードキャストレシーバなど) をデータソースとして指定しないでください。その代わり、そのエントリポイントに関連するデータを取得する他のコンポーネントとの調整のみを行う必要があります。ユーザーによるデバイスの操作や、システムの現在の全体的な稼働状態によっては、各アプリコンポーネント (エントリポイント) の生存期間がかなり短くなります。


### Android クラスへの依存を減らします

？？？言っていることが理解できない...。

アプリ コンポーネントは、Context や Toast など、Android フレームワーク SDK API に依存する唯一のクラスにする必要があります。そこからアプリの他のクラスを抽象化すると、テストがしやすくなり、アプリ内の結合を軽減できます。


### アプリの各種モジュール間の役割の境界を明確に定義します。

たとえば、ネットワークからデータを読み込むコードを、コードベース内の複数のクラスやパッケージに散在させないでください。同様に、関連のない複数の処理（データ キャッシングとデータ バインディングなど）を同じクラスで定義しないでください。アプリの推奨アーキテクチャに沿うと便利です。


### 各モジュールからの公開はできるだけ行わないでください。

？？？言っていることが理解できない...。

たとえば、モジュールの内部実装の詳細を公開するショートカットを作成しようとしないでください。短期的には時間を少し節約できるかもしれませんが、コードベースが発展するにつれて何倍もの技術的負債を負うことになる可能性があります。


### アプリの特別な部分に焦点を当てて、他のアプリとの差別化を図ります。

同じボイラープレート コードを何度も書いてすでにあるものを作り直すのではなく、アプリを特別なものにすることに時間とエネルギーを集中させましょう。繰り返しのボイラープレート コードの記述には Jetpack ライブラリやその他の推奨ライブラリを利用してください。


### アプリの各部分を個別にテストできるようにする方法を検討します。

たとえば、ネットワークからデータを取得するための明確に定義された API を用意することで、そのデータをローカル データベースに永続化するモジュールを簡単にテストできるようになります。そうしないで、2 つのモジュールのロジックを 1 か所に混在させたり、ネットワーク用のコードをコードベース全体に分散させたりすると、テストが不可能にはならないにしても、非常に困難になります。


### 型は同時実行ポリシーに関する責任を負います。

ある型が時間のかかるブロック処理を実行している場合、その型は適切なスレッドに計算を移動する責任を負います。その特定の型は、実行している計算のタイプと、その計算をどのスレッドで実行する必要があるかを認識します。型はメインセーフである（つまり、ブロックせずにメインスレッドから安全に呼び出せる）ことが必要です。


### データの関連性と新鮮さをできる限り維持します。

こうすることで、デバイスがオフライン モードのときでも、ユーザーがアプリの機能を利用できるようになります。すべてのユーザーが常に高速な接続を利用できるわけではなく、たとえ利用できるとしても、混雑した場所では受信不良が起きる可能性があることに留意してください。





