- [UI 状態生成](#ui-状態生成)
  - [UI 状態生成パイプライン](#ui-状態生成パイプライン)
  - [状態生成の API](#状態生成の-api)
  - [状態生成パイプラインの組み立て](#状態生成パイプラインの組み立て)
  - [状態生成パイプラインにおける入力](#状態生成パイプラインにおける入力)
    - [ワンショット API を状態変更のソースとする場合](#ワンショット-api-を状態変更のソースとする場合)
      - [同期呼び出しから UI 状態を変更する](#同期呼び出しから-ui-状態を変更する)
      - [非同期呼び出しから UI 状態を変更する](#非同期呼び出しから-ui-状態を変更する)
      - [バックグラウンドスレッドから UI 状態を変更する](#バックグラウンドスレッドから-ui-状態を変更する)
    - [ストリーム API を状態変更のソースとする場合](#ストリーム-api-を状態変更のソースとする場合)
    - [ワンショット API とストリーム API の両方を状態変更のソースとする場合](#ワンショット-api-とストリーム-api-の両方を状態変更のソースとする場合)
  - [状態生成パイプラインの出力タイプ](#状態生成パイプラインの出力タイプ)
  - [状態生成パイプラインの初期化](#状態生成パイプラインの初期化)
    - [初期化時に非同期オペレーションを実行する際の注意点](#初期化時に非同期オペレーションを実行する際の注意点)
      - [安全に非同期オペレーションを実行する方法](#安全に非同期オペレーションを実行する方法)
        - [1. フィールドの定義と同時に初期化する](#1-フィールドの定義と同時に初期化する)
        - [2. 初期化処理の後ろに非同期処理を記述する](#2-初期化処理の後ろに非同期処理を記述する)
  - [引用元資料](#引用元資料)


# UI 状態生成

このドキュメントでは、UI 状態の生成と管理に関するガイドラインを示します。本ドキュメントの目的は、以下を理解していただくことです。

- どの API を使って UI 状態を生成するか。
  - これは、単方向データフローの原則に従い、状態ホルダーで利用可能な状態変化のソースが、どのような性質かによって異なります。
- システムリソースを意識して UI 状態生成のスコープを決定する方法。
- UI が使用する UI 状態の公開方法。

基本的に、状態生成とは、こうした変化の増分を UI 状態に適用することです。状態は常に存在し、イベントの結果として変化します。次の表にイベントと状態の違いをまとめます。

| イベント                               | 状態           |
| -------------------------------------- | -------------- |
| 一過性、予測不可能、有限の期間だけ存在 | 常に存在       |
| 状態生成の入力                         | 状態生成の出力 |
| UI またはその他のソースから生成される  | UI が使用する  |

状態は 「存在する」 、イベントは 「起きる」 と覚えてください。下図は、イベント発生で状態が変化する様子を時系列で視覚化したものです。各イベントは対応する状態ホルダーが処理し、そうすることで状態が変化します。

<img src="./画像/イベントと状態の関係.png" width="400">

イベントは以下から発生します。

- **ユーザー**: アプリの UI を操作したとき
- **その他の状態変化のソース**: UI（スナックバーのタイムアウト イベントなど）、ドメインレイヤ（ユースケースなど）、または、データレイヤ（リポジトリなど）からのアプリデータを表示する API


## UI 状態生成パイプライン

<img src="./画像/状態生成パイプライン.png" width="600">

- Local sources of state change
  - UI 要素状態の変化など
- External sources of state change
  - データソースのデータの変更など
- User Events
  - タップイベントなど


## 状態生成の API

状態生成に使用される主な API は、パイプラインのステージに応じて異なります。

**パイプラインの 「入力」 ステージ**

- おすすめの方法
  - UI スレッドをブロックしない仕組み
- 例
  - コルーチン
  - Kotlin の Flow
  - Rx Java
  - コールバック


**パイプラインの 「出力」 ステージ**

- おすすめの方法
  - 監視可能なデータホルダーの API
  - 状態が変化した際に UI を無効化して再レンダリングする
- 例
  - StateFlow
  - Compose State
  - LiveData

この 2 つの中で、入力の仕組みを選ぶことは、出力の仕組みを選ぶことよりも、状態生成パイプラインの性質に大きく影響します。これは、入力によって、パイプラインに適用できる処理の種類が決まるためです。


## 状態生成パイプラインの組み立て

各状態生成パイプラインは、次のようになっていることが推奨されます。

- ライフサイクル対応
  - UI が見えない状態にある場合や、UI がアクティブでない場合、状態生成パイプラインは、明示的に必要な場合を除き、リソースを消費すべきではありません。
- 状態を使用しやすい
  - UI は、生成された UI 状態を簡単にレンダリングできるべきです。状態生成パイプラインの出力に関して考慮すべき点は、 View システムや Jetpack Compose など、View の API によって異なります。


## 状態生成パイプラインにおける入力

状態生成パイプラインにおける入力は、以下のいずれかを通じて状態のソースを提供します。

- ワンショット オペレーション (同期、または、非同期（ suspend 関数の呼び出しなど）)
- ストリーム API（Flows など）
- 上記の複合

Flow のような連続的に値を返すものに対して、単発でしか値を返さないもののことを **ワンショット** と呼びます。

以降のセクションでは、上記の各入力に対して状態生成パイプラインを作成する方法を説明します。


### ワンショット API を状態変更のソースとする場合

[MutableStateFlow](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/) API を、状態のオブザーバブルで変更可能なコンテナとして使用します。 Jetpack Compose アプリの場合で、特に [Compose のテキスト API](https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5) を使用するときは、 [mutableStateOf](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja&_gl=1*13cd9sy*_up*MQ..*_ga*NTc1MDc4MDM2LjE3MjA1MDM5NTc.*_ga_6HH9YJMN9M*MTcyMTExODU5OS41LjAuMTcyMTExODU5OS4wLjAuMA..#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)) もおすすめします。どちらの API にも、更新が同期か非同期かにかかわらず、ホストする値の安全でアトミックな更新ができるメソッドが用意されています。


#### 同期呼び出しから UI 状態を変更する

たとえば、シンプルなサイコロ投げアプリで状態を更新する場合を考えてみましょう。ユーザーがサイコロを振るたびに、同期的な Random.nextInt() メソッドが呼び出され、その結果が UI 状態に書き込まれます。

```kotlin
//****************************
// StateFlow を使用した例
//****************************
data class DiceUiState(
    val firstDieValue: Int? = null,
    val secondDieValue: Int? = null,
    val numberOfRolls: Int = 0,
)

class DiceRollViewModel : ViewModel() {

    private val _uiState = MutableStateFlow(DiceUiState())
    val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()

    // Called from the UI
    fun rollDice() {
        _uiState.update { currentState ->
            currentState.copy(
            firstDieValue = Random.nextInt(from = 1, until = 7),
            secondDieValue = Random.nextInt(from = 1, until = 7),
            numberOfRolls = currentState.numberOfRolls + 1,
            )
        }
    }
}

//****************************
// State を使用した例
//****************************
@Stable
interface DiceUiState {
    val firstDieValue: Int?
    val secondDieValue: Int?
    val numberOfRolls: Int? // 試行回数(1回の試行でサイコロを2回投げます。)
}

private class MutableDiceUiState: DiceUiState {
    override var firstDieValue: Int? by mutableStateOf(null)
    override var secondDieValue: Int? by mutableStateOf(null)
    override var numberOfRolls: Int by mutableStateOf(0)
}

class DiceRollViewModel : ViewModel() {

    private val _uiState = MutableDiceUiState()
    val uiState: DiceUiState = _uiState

    // Called from the UI
    fun rollDice() {
        _uiState.firstDieValue = Random.nextInt(from = 1, until = 7)
        _uiState.secondDieValue = Random.nextInt(from = 1, until = 7)
        _uiState.numberOfRolls = _uiState.numberOfRolls + 1
    }
}
```


#### 非同期呼び出しから UI 状態を変更する

非同期な結果を必要とする状態変更の場合は、適切な CoroutineScope でコルーチンを起動します。 (コルーチンを起動することは、新しいスレッドを起動するようなものです。)

次の例は、 [アーキテクチャサンプル](https://github.com/android/architecture-samples) の AddEditTaskViewModel です。これは、タスク管理アプリのタスク編集画面の ViewModel です。

```kotlin
//****************************
// StateFlow を使用した例
//****************************
data class AddEditTaskUiState(
    val title: String = "",
    val description: String = "",
    val isTaskCompleted: Boolean = false,
    val isLoading: Boolean = false,
    val userMessage: String? = null,
    val isTaskSaved: Boolean = false
)

class AddEditTaskViewModel(...) : ViewModel() {

   private val _uiState = MutableStateFlow(AddEditTaskUiState())
   val uiState: StateFlow<AddEditTaskUiState> = _uiState.asStateFlow()

   private fun createNewTask() {
        viewModelScope.launch {
            val newTask = Task(uiState.value.title, uiState.value.description)
            try {
                tasksRepository.saveTask(newTask)
                // Write data into the UI state.
                _uiState.update {
                    it.copy(isTaskSaved = true)
                }
            }
            catch(cancellationException: CancellationException) {
                throw cancellationException
            }
            catch(exception: Exception) {
                _uiState.update {
                    it.copy(userMessage = getErrorMessage(exception))
                }
            }
        }
    }
}

//****************************
// State を使用した例
//****************************
@Stable
interface AddEditTaskUiState {
    val title: String
    val description: String
    val isTaskCompleted: Boolean
    val isLoading: Boolean
    val userMessage: String?
    val isTaskSaved: Boolean
}

private class MutableAddEditTaskUiState : AddEditTaskUiState() {
    override var title: String by mutableStateOf("")
    override var description: String by mutableStateOf("")
    override var isTaskCompleted: Boolean by mutableStateOf(false)
    override var isLoading: Boolean by mutableStateOf(false)
    override var userMessage: String? by mutableStateOf<String?>(null)
    override var isTaskSaved: Boolean by mutableStateOf(false)
}

class AddEditTaskViewModel(...) : ViewModel() {

    private val _uiState = MutableAddEditTaskUiState()
    val uiState: AddEditTaskUiState = _uiState

    private fun createNewTask() {
        // コルーチンを起動して非同期処理を開始します。
        viewModelScope.launch {
            val newTask = Task(uiState.value.title, uiState.value.description)
            try {
                tasksRepository.saveTask(newTask)
                // UI 状態を更新することで、画面を更新することが可能です。
                _uiState.isTaskSaved = true
            }
            catch(cancellationException: CancellationException) {
                throw cancellationException
            }
            catch(exception: Exception) {
                _uiState.userMessage = getErrorMessage(exception))
            }
        }
    }
}
```

ViewModel の viewModelScope で起動されたコルーチンは、コルーチンが明示的にキャンセルされるか、 ViewModel がクリアされない限り、継続します。たとえ、 UI が見えない状態になったとしても継続します。コルーチン内で実行される処理は、多くの場合はすぐに終了するリクエストであることが多いので、問題になることはありません。ただし、 5 秒以上継続する処理を実行する場合は、 viewModelScope でコルーチンを実行することは避けてください。代わりに、 WorkManager で遅延処理、または、長時間実行の処理としてキューに投入することをおすすめします。


#### バックグラウンドスレッドから UI 状態を変更する

UI 状態の生成には、メインディスパッチャ (メインスレッド) で、コルーチンを起動することをおすすめします。もし、バックグラウンドスレッドで、 UI 状態を更新する必要がある場合は、次の API の使用をおすすめします。

- [withContext](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html) メソッドを使い、 UI の更新だけはメインスレッドで実行する。
- MutableStateFlow を使用する場合は、 [update](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html) メソッド (※ 1 ) を通常どおりに使用する。
- Compose State を使用する場合は、 [Snapshot.withMutableSnapshot](https://developer.android.com/reference/kotlin/androidx/compose/runtime/snapshots/Snapshot.Companion?hl=ja&_gl=1*1lyospx*_up*MQ..*_ga*NjkzNDE1MTY2LjE3MzMyNzg4MTU.*_ga_6HH9YJMN9M*MTczMzI3ODgxNS4xLjAuMTczMzI3ODgxNS4wLjAuNTA3MjM2ODA0#withMutableSnapshot(kotlin.Function0)) を使って、並行するコンテキストで State がアトミックに更新されることを保証する。 (※ 2 )

(※ 1 ) MutableStateFlow の update 関数の使用方法は以下の通りです。 update 関数は、現在の値を使用して、更新後の値を生成し、値を更新します。

(※ 2 ) Snapshot.withMutableSnapshot 関数についての詳細は、 [【ブログ】Compose のスナップショットシステム](../../../../主要分野/UI/ガイド/2.UIアーキテクチャ/4.状態の管理/【ブログ】Compose%20のスナップショットシステム.md) の次の三つのセクションを参照してください。

- [「スナップショット」](../../../../主要分野/UI/ガイド/2.UIアーキテクチャ/4.状態の管理/【ブログ】Compose%20のスナップショットシステム.md/#スナップショット)
- [スナップショットの「復元」](../../../../主要分野/UI/ガイド/2.UIアーキテクチャ/4.状態の管理/【ブログ】Compose%20のスナップショットシステム.md/#スナップショットの復元)
- [Mutable スナップショット](../../../../主要分野/UI/ガイド/2.UIアーキテクチャ/4.状態の管理/【ブログ】Compose%20のスナップショットシステム.md/#mutable-スナップショット)

```kotlin
fun main() = runBlocking {
    // MutableStateFlow を作成し、初期値を設定する
    val stateFlow = MutableStateFlow(0)

    // update 関数を使用して値を更新する
    // 実際には、プリミティブ型ではなく、参照型のデータを更新することが多いです。
    // 参照型を更新する際は、 copy 関数なども使用するため、
    // そのような例は、次の DiceRollViewModel のサンプルを参照してください。
    stateFlow.update { currentValue ->
        currentValue + 1
    }

    // 現在の値を取得して表示する
    println(stateFlow.value) // 出力: 1
}
```

たとえば、以下の DiceRollViewModel のスニペットでは、SlowRandom.nextInt() が計算負荷の高い suspend 関数であり、CPU バウンドなコルーチンから呼び出す必要があると仮定しています。

```kotlin
//****************************
// StateFlow を使用した例
//****************************
class DiceRollViewModel(
    private val defaultDispatcher: CoroutineScope = Dispatchers.Default
) : ViewModel() {

    private val _uiState = MutableStateFlow(DiceUiState())
    val uiState: StateFlow<DiceUiState> = _uiState.asStateFlow()

  // UI から呼び出される処理
  fun rollDice() {
        viewModelScope.launch() {
            // バックグラウンドスレッドで処理を行う
            withContext(defaultDispatcher) {
                // MutableStateFlow の update 関数を使用して
                // 安全に UI 状態を変更する。
                _uiState.update { currentState ->
                    currentState.copy(
                        firstDieValue = SlowRandom.nextInt(from = 1, until = 7),
                        secondDieValue = SlowRandom.nextInt(from = 1, until = 7),
                        numberOfRolls = currentState.numberOfRolls + 1,
                    )
                }
            }
        }
    }
}

//****************************
// State を使用した例
//****************************
class DiceRollViewModel(
    private val defaultDispatcher: CoroutineScope = Dispatchers.Default
) : ViewModel() {

    private val _uiState = MutableDiceUiState()
    val uiState: DiceUiState = _uiState

  // Called from the UI
  fun rollDice() {
        viewModelScope.launch() {
            // バックグラウンドスレッドで処理を行う
            withContext(defaultDispatcher) {
                // バックグラウンドスレッド内から Compose の状態を更新する場合は、
                // 必ず withMutableSnapshot ブロック内で更新してください。
                Snapshot.withMutableSnapshot {
                    _uiState.firstDieValue = SlowRandom.nextInt(from = 1, until = 7)
                    _uiState.secondDieValue = SlowRandom.nextInt(from = 1, until = 7)
                    _uiState.numberOfRolls = _uiState.numberOfRolls + 1
                }
            }
        }
    }
}
```

注: 起動されたすべてのコルーチンが別のコンテキストから呼ばれている必要がある場合は、viewModelScope.launch(defaultDispatcher){ } を直接呼び出すことができます。
警告: Snapshot.withMutableSnapshot{ } を使用せずに非 UI スレッドから Compose の状態を更新すると、生成される状態に不整合が生じる可能性があります。


### ストリーム API を状態変更のソースとする場合

時間をかけて複数の値を生成する状態変化のソースの場合、状態生成を行うには、すべてのソースの出力を一つに集約するのが素直な方法です。

Kotlin の Flow を使用する場合、 [combine](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html) 関数 (※ 1 ) でこれを実現できます。この例としては、InterestsViewModel の「Now in Android」のサンプルに、以下のコードがあります。

(※ 1 )  
combine 関数は、複数の Flow を引数に受け取り、それらを統合した新しい Flow を返します。引数で渡した Flow のうちのどれか一つの Flow から値を収集するたびに、ラムダブロック ( transform 関数) を実行し、その結果を、生成した新しい Flow の要素として放出します。

```kotlin
class InterestsViewModel(
    authorsRepository: AuthorsRepository,
    topicsRepository: TopicsRepository
) : ViewModel() {

    val uiState = combine(
        authorsRepository.getAuthorsStream(),
        topicsRepository.getTopicsStream(),
    ) { availableAuthors, availableTopics ->
        InterestsUiState.Interests(
            authors = availableAuthors,
            topics = availableTopics
        )
    }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5_000),
            initialValue = InterestsUiState.Loading
    )
}
```

stateIn 演算子を使用すると、結合された Flow を、UI 状態のオブザーバブルな API として StateFlow に変換できます。

stateIn オペレータを使って StateFlows を作成すると、 UI が状態生成パイプラインの停止と再開をきめ細かく制御できます。

**SharingStarted.WhileSubscribed()**

UI が見える状態にある間のみ、パイプラインをアクティブにし、ライフサイクルを意識した方法で、フローを収集する必要がある場合に使用します。

**SharingStarted.Lazily**

ユーザーが UI に戻る可能性がある限り、 (つまり UI がバックスタックにあるか、画面上にないタブにある限り、) パイプラインをアクティブにする必要がある場合に使用します。

ストリームベースの状態ソースを集約することが当てはまらない場合には、 Kotlin Flow のようなストリーム API に、マージやフラット化など、ストリームを処理して UI 状態を生成するため変換が豊富に用意されています。ただし、ほとんどの場合、ストリーム API から状態を生成するには combine が推奨されます。


### ワンショット API とストリーム API の両方を状態変更のソースとする場合

状態生成パイプラインに、状態変化のソースとして、 「ワンショットの呼び出し」 と 「ストリーム」 の両方が使われている場合、ストリームが制約条件となります。したがって、ワンショット呼び出しをストリーム API に変換するか、ワンショット呼び出しの出力をストリームに変換します。

出力 ( State ) を ストリーム ( Flow ) に変換するには、 [snapshotFlow](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?_gl=1*1iibms1*_up*MQ..*_ga*NjkzNDE1MTY2LjE3MzMyNzg4MTU.*_ga_6HH9YJMN9M*MTczMzI3ODgxNS4xLjAuMTczMzI3ODgxNS4wLjAuNTA3MjM2ODA0#snapshotFlow(kotlin.Function0)) 関数が使用できます。 snapshotFlow については、 [副作用 - snapshotFlow](../../../../主要分野/UI/ガイド/2.UIアーキテクチャ/2.副作用.md/#snapshotflow--compose-の-state-を-flow-に変換する) セクションも参照してみてください。

```kotlin
//****************************
// StateFlow を使用した例
//****************************
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _isTaskDeleted = MutableStateFlow(false)
    private val _task = tasksRepository.getTaskStream(taskId)

    val uiState: StateFlow<TaskDetailUiState> = combine(
        _isTaskDeleted,
        _task
    ) { isTaskDeleted, task ->
        TaskDetailUiState(
            task = taskAsync.data,
            isTaskDeleted = isTaskDeleted
        )
    }
        // Convert the result to the appropriate observable API for the UI
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5_000),
            initialValue = TaskDetailUiState()
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted.update { true }
    }
}

//****************************
// State を使用した例
//****************************
class TaskDetailViewModel @Inject constructor(
    private val tasksRepository: TasksRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private var _isTaskDeleted by mutableStateOf(false)
    private val _task = tasksRepository.getTaskStream(taskId)

    val uiState: StateFlow<TaskDetailUiState> = combine(
        // State を Flow に変換
        snapshotFlow { _isTaskDeleted },
        _task
    ) { isTaskDeleted, task ->
        TaskDetailUiState(
            task = taskAsync.data,
            isTaskDeleted = isTaskDeleted
        )
    }
        // Flow を StateFlow に変換
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5_000),
            initialValue = TaskDetailUiState()
        )

    fun deleteTask() = viewModelScope.launch {
        tasksRepository.deleteTask(taskId)
        _isTaskDeleted = true
    }
}
```


## 状態生成パイプラインの出力タイプ

UI 状態に対する出力 API の選択と、その表示の性質は、アプリで UI のレンダリングに使用する API に大きく左右されます。Android アプリでは、 View と Jetpack Compose から選択できます。その際には次の点を考慮します。

- [ライフサイクルを意識した方法で状態を読み取る。](./Jetpack%20Compose%20から安全に%20flow%20を収集する.md) ( [引用元はこちら](https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3) )
- 状態ホルダーの [1 つまたは複数のフィールドで状態を公開](./1.UI%20レイヤについて.md/#その他の考慮事項) すべきかどうか。

次の表は、入力とコンシューマーの組み合わせに対して、どの API を状態生成パイプラインに使うべきかをまとめたものです。

| 入力                              | コンシューマー | 出力                           |
| --------------------------------- | -------------- | ------------------------------ |
| ワンショット API                  | Compose        | StateFlow または Compose State |
| ストリーム API                    | Compose        | StateFlow                      |
| ワンショット API とストリーム API | Compose        | StateFlow                      |
| ワンショット API                  | View システム  | StateFlow または LiveData      |
| ストリーム API                    | View システム  | StateFlow または LiveData      |
| ワンショット API とストリーム API | View システム  | StateFlow または LiveData      |


## 状態生成パイプラインの初期化

状態生成パイプラインの初期化では、パイプラインを実行するための初期条件を設定します。これには、パイプライン（例: ニュース記事の詳細を表示する id）の開始、または、非同期の読み込みの開始に不可欠な、初期入力値の提供が含まれることがあります。

可能であれば、システム リソースを節約するために、状態生成パイプラインを初期化することをおすすめします。実際には多くの場合、出力のコンシューマが、サブスクライブを開始するまで、待機することになります。 Flow API では、 stateIn メソッドの [started](./Jetpack%20Compose%20から安全に%20flow%20を収集する.md/#sharein-の-started-パラメータの種類) 引数を使用して、アップストリームからのデータの収集の開始タイミングを制御することができます。この方法が適切ではない場合は、状態生成パイプラインを明示的に開始するように、冪等 (べきとう) の initialize() 関数を定義することができます。

```kotlin
class MyViewModel : ViewModel() {

    private var initializeCalled = false

    // この関数は UI スレッドでのみ呼び出されるようにすれば、冪等となります。
    @MainThread
    fun initialize() {
        if(initializeCalled) return
        initializeCalled = true

        viewModelScope.launch {
            // ここで、状態生成パイプラインに初期値を設定しつつ、
            // パイプラインを開始できます。
        }
    }
}
```

### 初期化時に非同期オペレーションを実行する際の注意点

ViewModel の init ブロック、または、コンストラクタで非同期オペレーションを起動しないでください。非同期オペレーションの場合、オブジェクトの生成という副作用が生じてはなりません。完全に初期化される前に、そのオブジェクトに対して非同期コードによる読み取り、または、書き込みが行われる可能性があるためです。例えば、次のような場合が考えられます。

```kotlin
class MyViewModel: ViewModel {

    // オブジェクトの生成
    var obj by mutableStateOf(SomeObject())

    init {
        viewModelScope.launch {
            // 【NG】まだ obj インスタンスが生成されていない可能性がある。
            obj.xxxFunc()
        }
    }
}
```

これはオブジェクトのリークとも呼ばれ、捉えにくく判断しづらいエラーの原因となる可能性があります。これは Compose State を扱う際に特に重要です。

ViewModel が Compose State フィールドを保持している場合は、 Compose State フィールドを更新するコルーチンを ViewModel の init ブロックで起動しないでください。起動すると IllegalStateException が発生する可能性があります。


#### 安全に非同期オペレーションを実行する方法

##### 1. フィールドの定義と同時に初期化する

フィールドを直接初期化することで、 init ブロック内で参照する際に、未初期化のリスクを排除します。

```kotlin
class MyViewModel : ViewModel() {
    // フィールドを明示的に初期化
    private val _dataFlow = MutableStateFlow<String>("Initial Value")
    val dataFlow: StateFlow<String> get() = _dataFlow

    init {
        // この時点で _dataFlow は初期化済み
        viewModelScope.launch {
            collectDataStream()
        }
    }

    private suspend fun collectDataStream() {
        someDataStream().collect { data ->
            _dataFlow.value = data
        }
    }

    private fun someDataStream(): Flow<String> {
        return flow {
            emit("Data 1")
            delay(1000)
            emit("Data 2")
        }
    }
}
```


##### 2. 初期化処理の後ろに非同期処理を記述する

フィールドを init ブロックの中で初期化する場合、初期化実施後に launch を呼び出します。この順番を守ることで、未初期化のリスクを排除します。

```kotlin
class MyViewModel : ViewModel() {
    private val _dataFlow: MutableStateFlow<String>
    val dataFlow: StateFlow<String>

    init {
        // 先に初期化を完了
        _dataFlow = MutableStateFlow("Initial Value")
        dataFlow = _dataFlow

        // 初期化完了後にコルーチンを開始
        viewModelScope.launch {
            collectDataStream()
        }
    }

    private suspend fun collectDataStream() {
        someDataStream().collect { data ->
            _dataFlow.value = data
        }
    }

    private fun someDataStream(): Flow<String> {
        return flow {
            emit("Data 1")
            delay(1000)
            emit("Data 2")
        }
    }
}
```


## 引用元資料

- [UI 状態生成](https://developer.android.com/topic/architecture/ui-layer/state-production?hl=ja&_gl=1*1geh1mv*_up*MQ..*_ga*NjkzNDE1MTY2LjE3MzMyNzg4MTU.*_ga_6HH9YJMN9M*MTczMzI3ODgxNS4xLjAuMTczMzI3ODgxNS4wLjAuNTA3MjM2ODA0)

