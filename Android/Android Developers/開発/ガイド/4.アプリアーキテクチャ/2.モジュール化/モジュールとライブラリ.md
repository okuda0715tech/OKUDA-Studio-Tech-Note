- [モジュールとライブラリ](#モジュールとライブラリ)
  - [モジュールとは](#モジュールとは)
  - [モジュールとアーティファクトとライブラリの違い](#モジュールとアーティファクトとライブラリの違い)
  - [モジュールの種類](#モジュールの種類)
    - [Android アプリモジュール](#android-アプリモジュール)
    - [機能モジュール](#機能モジュール)
    - [ライブラリモジュール](#ライブラリモジュール)
  - [ライブラリモジュールの種類](#ライブラリモジュールの種類)
    - [Android ライブラリ](#android-ライブラリ)
    - [Android ネイティブライブラリ](#android-ネイティブライブラリ)
    - [Java または Kotlin ライブラリ](#java-または-kotlin-ライブラリ)
  - [なぜコンパイル済みの .class ファイルのクラス名やメソッド名がわかるのか？](#なぜコンパイル済みの-class-ファイルのクラス名やメソッド名がわかるのか)
  - [引用元資料](#引用元資料)


# モジュールとライブラリ

## モジュールとは

モジュールとは、ソースファイル、リソース、ビルド設定を集めたものです。

- 機能ごとにプロジェクトを分割できます。
- プロジェクトには 1 つ、または、多数のモジュールを含めることができます。
- モジュールは、別のモジュールを依存関係として使用できます。
- 各モジュールは、個別にビルド、テスト、デバッグできます。


## モジュールとアーティファクトとライブラリの違い

モジュールとアーティファクトは対照的なもので、コンパイルされているかどうかによって、いずれかに分類されます。

- モジュール
  - コンパイルされていないソースコードやリソースのパッケージのこと。
  - まだコンパイルが実施されていないため、コードを修正することが可能です。
- アーティファクト
  - モジュールをコンパイルして、 JAR ファイルや AAR ファイルや APK ファイルにしたもののこと。
  - コンパイル済み (完成した部品) であるため、コードを修正することはできません。
- ライブラリ
  - コンパイルされているか、されていないかに関わらず、アプリに組み込みこんで使用する部品をライブラリと呼びます。
  - つまり、ライブラリは、モジュールやアーティファクトのことを示していることが多いです。


## モジュールの種類

### Android アプリモジュール

Android アプリモジュールには、以下のものがあります。

- Phone & Tablet モジュール
- Automotive モジュール
- Wear OS モジュール
- Android TV モジュール
- Benchmark モジュール

### 機能モジュール

機能モジュールを使用すると、アプリの一部の機能をオンデマンドで、ユーザーに提供できます。


### ライブラリモジュール

他のアプリモジュールで依存関係として使用したり、他のプロジェクトにインポートしたりできる  
再利用可能なコードのコンテナをライブラリモジュールと呼びます。

構造上は、ライブラリモジュールはアプリモジュールと同じですが、  
ビルドすると APK ではなくコード アーカイブ ファイル ( .aar or .jar ) が作成され、  
デバイスにインストールすることはできません。


## ライブラリモジュールの種類

### Android ライブラリ

この種類のライブラリには、Java や Kotlin のソースコード、リソース、マニフェスト ファイルなど、  
ネイティブ C++ コード以外の Android プロジェクトでサポートされるすべてのファイル形式を  
含めることができます。

ビルドの結果、Android アプリ モジュールの依存関係として追加できる  
Android Archive（AAR）ファイルが作成されます。


### Android ネイティブライブラリ

基本的には Android ライブラリと同じですが、Android ネイティブライブラリには  
ネイティブ C++ ソースコードも含めることができます。

ビルドの結果、Android アプリ モジュールの依存関係として追加できる Android Archive（AAR）ファイルが作成されます。


### Java または Kotlin ライブラリ

このタイプのライブラリには、Kotlin または Java のソースファイルのみが格納されます。  
ビルドの結果、Android アプリ モジュールやその他の Kotlin プロジェクトや  
Java プロジェクトの依存関係として追加できる Java アーカイブ（JAR）ファイルが作成されます。


## なぜコンパイル済みの .class ファイルのクラス名やメソッド名がわかるのか？

.java や .kt ファイルは、コンパイルされると .class ファイルになります。 JAR や AAR ファイルをアプリに組み込んだ場合、そのライブラリに定義されているクラス名やメソッド名を使用して、ライブラリを利用できます。

これは、 .class ファイルに、クラス名やメソッド名が定義されているためです。

.class ファイルには、次のような情報が含まれています：

- クラス名（完全修飾名）
- メソッド名と引数・戻り値の型（メソッドシグネチャ）
- フィールド（変数）名と型
- アクセス修飾子（public、private など）
- アノテーション情報（@Deprecated など）
- 実装しているインターフェース、継承元クラスの情報
- 一部のデバッグ用情報（オプションでソースファイル名、行番号など）

難読化されている場合は、難読化後のクラス名やメソッド名でしか参照ができません。そのため、ライブラリの提供者は、 keep ルールを設定して、公開しているクラスやメソッドは、難読化の対象から除外するのが一般的です。これにより、元のクラス名やメソッド名で参照可能となります。

以下の設定は、 public なクラスやメソッドやフィールドを難読化しないようにするものです。

```proguard
# 公開 API を保護（難読化しない）
-keep public class com.example.mylibrary.** {
    public *;
}
```

ライブラリ提供者が ProGuard マッピングファイル（mapping.txt）を提供している場合は、難読化前のクラス名やメソッド名等がわかりますが、これは、基本的に  **デバッグやクラッシュ解析用** であって、実装時に使用するものではありません。


## 引用元資料

- ChatGPT


