- [Kotlin DSL と Navigation Compose における型安全性](#kotlin-dsl-と-navigation-compose-における型安全性)
  - [ルートを定義する](#ルートを定義する)
    - [グラフを作成する](#グラフを作成する)
    - [タイプセーフなルートに移動する](#タイプセーフなルートに移動する)
    - [ルートクラスに参照型のプロパティを設定する](#ルートクラスに参照型のプロパティを設定する)
  - [引用元資料](#引用元資料)


# Kotlin DSL と Navigation Compose における型安全性

組み込みの型安全性 API を使用すると、コンパイル時の型安全性をナビゲーション グラフに提供できます。これらの API は、アプリで Navigation Compose または Navigation Kotlin DSL を使用している場合に利用できます。Navigation 2.8.0 からご利用いただけます。

これらの API は、XML を使用してビルドされたナビゲーション グラフに [Safe Args](https://developer.android.com/guide/navigation/navigation-pass-data?hl=ja&_gl=1*1xvwbwj*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz#Safe-args) が提供するものと同等です。


## ルートを定義する

Compose でタイプセーフなルートを使用するには、まず、ルートを表すシリアル化可能なクラス、または、オブジェクトを定義する必要があります。

シリアル化可能なオブジェクトを定義するには、 [Kotlin シリアル化プラグイン](https://kotlinlang.org/docs/serialization.html) で提供される @Serializable アノテーションを使用します。このプラグインをプロジェクトに追加するには、 [これらの依存関係](https://developer.android.com/guide/navigation?hl=ja&_gl=1*enwqxs*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz#set-up) を追加します。

ルートに使用するタイプを決定するには、次のルールを使用します。

- **object / data object** : 引数のないルートには、 object 、または、 data object を使用します。
  - おすすめは、 data object です。
  - object と data object の違いについては、 [こちら](../../../../../../../../Kotlin/クラスとオブジェクト/data%20object.md) を参照してください。
- **class / data class** : 引数を持つルートには、 class 、または、 data class を使用します。
- **`KClass<T>`** : パラメータのないクラスや、すべてのパラメータがデフォルト値を持つクラスなど、引数を渡す必要がない場合に使用します。
  - 例: `Profile::class`

いずれの場合も、オブジェクト、または、クラスはシリアル化可能である必要があります。

つまり、ルートクラス内に参照型のプロパティを持っている場合は、そのままではシリアル化ができないため、工夫が必要になります。ただし、その工夫が複雑そうなので、参照型のプロパティを保持することは、あまりおすすめしません。詳しくは [ルートクラスに参照型のプロパティを設定する](#ルートクラスに参照型のプロパティを設定する) セクションを参照してください。

次に例を示します。

```kotlin
// Define a home route that doesn't take any arguments
@Serializable
object Home

// Define a profile route that takes an ID
@Serializable
data class Profile(val id: String)
```


### グラフを作成する

次に、ナビゲーション グラフを定義する必要があります。 [composable()](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?hl=ja&_gl=1*j4xt6a*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz#(androidx.navigation.NavGraphBuilder).composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2)) 関数を使用して、コンポーザブルをナビゲーション グラフ内のデスティネーションとして定義します。

```kotlin
NavHost(navController, startDestination = Home) {
    composable<Home> {
        HomeScreen(onNavigateToProfile = { id ->
            navController.navigate(Profile(id))
        })
    }
    composable<Profile> { backStackEntry ->
        val profile: Profile = backStackEntry.toRoute()
        ProfileScreen(profile.id)
    }
}
```

この例では、次のことを確認します。

- composable() は、型パラメータを受け取ります。つまり、 `composable<Profile>` です。
- デスティネーションタイプを定義することは、 composable("profile") のように、 [route 文字列を渡す composable() 関数](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?hl=ja&_gl=1*112ldp0*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz#(androidx.navigation.NavGraphBuilder).composable(kotlin.String,kotlin.collections.List,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2)) よりも堅牢なアプローチです。
- ルートクラスは、画面遷移時に渡すデータを `val id: String` のように、プロパティとして定義するため、 [NavArgument](https://developer.android.com/reference/kotlin/androidx/navigation/NavArgument?hl=ja&_gl=1*1rl84dj*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz) は必要ありません。
- toRoute() 拡張関数は、 [NavBackStackEntry](https://developer.android.com/reference/androidx/navigation/NavBackStackEntry?hl=ja&_gl=1*wgptjh*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz) と、遷移元で設定したルートクラスのプロパティを使用して、 ルートクラスのインスタンスを再作成します。
  - 上記の例では、 Home ルートで設定した Profile のプロパティを使用して、 Profile ルートクラスを再作成します。

グラフの一般的な設計方法についての詳細は、 [ナビゲーション グラフを設計する](./1.概要.md) [引用元はこちら](https://developer.android.com/guide/navigation/design?hl=ja&_gl=1*1r6uwdf*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz) をご覧ください。


### タイプセーフなルートに移動する

他のデスティネーションに移動するには、 [navigate()](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?hl=ja&_gl=1*ifcb06*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz#(androidx.navigation.NavGraphBuilder).composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2)) 関数の引数に、ルートのインスタンスを渡します。

```kotlin
navController.navigate(Profile(id = 123))
```

これにより、ユーザーはナビゲーション グラフ内の composable<Profile> デスティネーションに移動します。id などのナビゲーション引数は、NavBackStackEntry.toRoute を使用して Profile を再構築し、そのプロパティを読み取ることで取得できます。

重要: データクラスのパラメータは型指定されているため、そのクラスのインスタンスを navigate() に渡すと、引数は必然的に型セーフになります。


### ルートクラスに参照型のプロパティを設定する

ルートクラスに参照型のプロパティを設定する方法については、こちらのブログ ( [Type Safe な API を利用した Navigation Compose での DeepLink の実装](https://tkhs0604.hatenablog.com/entry/type-safe-navigation-compose-with-deeplink) ) を参照してください。ただし、複雑さが増加するわりには、それほどメリットが感じられないため、使用することは、あまりおすすめしません。

上記のドキュメントで出てくる reified 修飾子については、 [具体化型パラメータ (reified type parameters)](https://maku77.github.io/kotlin/generics/reified.html) を参照してください。


## 引用元資料

- [Kotlin DSL と Navigation Compose における型安全性](https://developer.android.com/guide/navigation/design/type-safety?hl=ja&_gl=1*1bq9xmz*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz)

