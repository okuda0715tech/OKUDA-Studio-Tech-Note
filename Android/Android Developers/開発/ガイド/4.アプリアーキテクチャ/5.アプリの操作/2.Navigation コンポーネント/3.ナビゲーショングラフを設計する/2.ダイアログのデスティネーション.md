- [ダイアログのデスティネーション](#ダイアログのデスティネーション)
  - [Dialog コンポーザブル](#dialog-コンポーザブル)
    - [ダイアログをデスティネーションとして定義するかどうか](#ダイアログをデスティネーションとして定義するかどうか)
  - [Kotlin SDL](#kotlin-sdl)
  - [XML](#xml)
  - [ダイアログのデスティネーションが有効な場合の例](#ダイアログのデスティネーションが有効な場合の例)


# ダイアログのデスティネーション

Android のナビゲーションでは、「ダイアログのデスティネーション」という用語は、アプリの UI 要素とコンテンツをオーバーレイする、ナビゲーション グラフ内のダイアログ形式のデスティネーションを指します。

ダイアログデスティネーションは、ナビゲーションホスト全体に表示される [ホストされているデスティネーション](./1.概要.md/#ホストされているデスティネーション) の上に表示されるため、ダイアログデスティネーションが NavController の [バックスタックとどのように相互作用するか](../5.バックスタック/2.ダイアログとバックスタック.md) に関して、いくつかの重要な考慮事項があります。

注: ダイアログのデスティネーションは [FloatingWindow](https://developer.android.com/reference/androidx/navigation/FloatingWindow?hl=ja&_gl=1*178ta87*_up*MQ..*_ga*MTkzNTkwOTM2MS4xNzIzNjQxNDQ0*_ga_6HH9YJMN9M*MTcyMzY0MTQ0NC4xLjAuMTcyMzY0MTQ0NC4wLjAuMA..) インターフェースを実装します。アプリは、このインターフェースを実装するデスティネーションを [ダイアログのデスティネーション](./1.概要.md/#ダイアログのデスティネーション) として扱います。


## Dialog コンポーザブル

Compose でダイアログのデスティネーションを作成するには、 [dialog()](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?_gl=1*1pe738b*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzc5NDczMy4yLjAuMTczMzc5NDczMy4wLjAuNTg5MDkxMTY3#(androidx.navigation.NavGraphBuilder).dialog(kotlin.collections.Map,kotlin.Function1)) 関数を使用して NavHost にデスティネーションを追加します。この関数は基本的に [composable()](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?_gl=1*resmyh*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzgzNDM3NS4zLjAuMTczMzgzNDM3NS4wLjAuMjAxODA3ODkyMQ..#(androidx.navigation.NavGraphBuilder).composable(kotlin.String,kotlin.collections.List,kotlin.collections.List,kotlin.Function1)) 関数と同じように動作しますが、ホストされているデスティネーションではなく、ダイアログのデスティネーションを作成します。

次の例を考えてみましょう。

```kotlin
@Serializable
object Home
@Serializable
object Settings
@Composable
fun HomeScreen(onNavigateToSettings: () -> Unit){
    Column {
        Text("Home")
        Button(onClick = onNavigateToSettings){
            Text("Open settings")
        }
    }
}

// この画面はダイアログとして表示されます。
@Composable
fun SettingsScreen(){
    // ここで AlertDialog() コンポーザブルを呼び出すことも可能です。
    // そうすると、通常の画面上に AlertDialog() を表示するのと同じように
    // ダイアログが表示されます。

    // AlertDialog() を使用しない場合、 Dialog() コンポーザブルと同様に動作します。
    Text("Settings")
    // ...
}

@Composable
fun MyApp() {
    val navController = rememberNavController()
    NavHost(navController, startDestination = Home) {
        composable<Home> { HomeScreen(onNavigateToSettings = { navController.navigate(route = Settings) }) }
        dialog<Settings> {
            // ここに記述したコンポーザブルは、
            // 通常の Dialog() コンポーザブルのコンテンツになるイメージです。
            SettingsScreen()
        }
    }
}
```

1. 開始デスティネーションは Home ルートを使用します。composable() によってグラフに追加されるため、これはホスト型デスティネーションになります。
2. もう一つのデスティネーションには、 Settings ルートを使用します。
   - dialog() によってグラフに追加されるため、ダイアログ デスティネーションになります。
   - ユーザーが HomeScreen から SettingsScreen に移動すると、 SettingsScreen は HomeScreen の上に表示されます。
3. SettingsScreen はダイアログのデスティネーションであるため、 [Dialog コンポーザブル](../../../../../主要分野/UI/ガイド/4.マテリアルコンポーネント/7.ダイアログ.md/#dialog-コンポーザブル) や [AlertDialog コンポーザブル](../../../../../主要分野/UI/ガイド/4.マテリアルコンポーネント/7.ダイアログ.md/#alertdialog-コンポーザブル) 自体は含まれていませんが、 NavHost によって Dialog 内に表示されます。

注: Compose のボトムシートは Dialog 上に構築されていないため、独自のデスティネーション タイプが必要です。実装例については、 [Accompanist ナビゲーションマテリアルのドキュメント](https://google.github.io/accompanist/navigation-material/) をご覧ください。


### ダイアログをデスティネーションとして定義するかどうか

ダイアログをデスティネーションとして定義するのか、しないのか、について、公式ドキュメントと私の見解を示します。

公式ドキュメントでは、以下のような指針が示されています。

```
ダイアログのデスティネーションは、 NavHost の前のデスティネーションの上に表示されます。
ダイアログが、ナビゲーショングラフ内の他のデスティネーションとは独立して、
独自のライフサイクルと保存された状態を必要とするアプリ内の別の画面を表す場合に使用します。
確認などのあまり複雑でないプロンプトのダイアログが必要な場合は、
AlertDialog 、または、関連するコンポーザブルを使用することをお勧めします。
```

私の見解としては、ダイアログを閉じる際に、ダイアログの後ろに表示されている全画面表示の画面が遷移するか、しないかが判断基準です。

- 遷移する場合
  - ダイアログはデスティネーションとして定義した方が良いです。
  - デスティネーションとして定義しなかった場合、以下のデメリットが存在します。
  - ダイアログの後ろにある画面が遷移した後に、ダイアログが閉じるという処理順序になってしまい、違和感のあるユーザーインターフェースになってしまいます。
    - その動画につていは、 [ダイアログのデスティネーションが有効な場合の例](#ダイアログのデスティネーションが有効な場合の例) を参照してください。
- 遷移しない場合
  - ダイアログはデスティネーションとして定義しない方が良いです。
  - デスティネーションとして定義してしまった場合、以下のデメリットが存在します。
  - 型安全なデスティネーションで、パラメータを渡しながら画面遷移する際に、上手くパラメータが渡せない場合があります。
  - 具体的には、ダイアログを閉じた際に、ダイアログの後ろにある画面にパラメータを渡すことができませんでした。

では、ダイアログを閉じる際に **ダイアログの後ろの画面が遷移する場合もあり、また、ダイアログの後ろの画面にパラメータを渡す場合もある場合** は、どうすれば良いのでしょうか？

その場合は、 **ダイアログをデスティネーションとして定義しない** ことを推奨します。なぜなら、デスティネーションとして定義しなかった場合のデメリット ( [ダイアログのデスティネーションが有効な場合の例](#ダイアログのデスティネーションが有効な場合の例) ) は、実装次第で解消できる方法があるためです。

このデメリットを解消するには、ダイアログから後ろの画面の遷移を呼び出すのではなく、いったんダイアログを閉じてから、後ろの画面から画面遷移の処理を呼び出してください。つまり、ダイアログで発生したイベントを後ろの画面の状態に変換し、後ろの画面は、その状態の変更を検出したら、イベントに再変換し、画面遷移処理を開始します。これにより、ダイアログが消える前に、後ろの画面が遷移するのを防ぐことが可能です。

**ということは、つまるところ、ダイアログデスティネーションは、あまり使わないほうが良いみたいです。**


## Kotlin SDL

フラグメントを使用していて、Kotlin DSL を使ってグラフを作成する場合、ダイアログのデスティネーションを追加する方法は Compose を使用する場合とよく似ています。

次のスニペットでも、dialog() 関数を使用して、フラグメントを使用するダイアログのデスティネーションを追加しています。

```kotlin
// Define destinations with serializable classes or objects
@Serializable
object Home
@Serializable
object Settings

// Add the graph to the NavController with `createGraph()`.
navController.graph = navController.createGraph(
    startDestination = Home
) {
    // Associate the home route with the HomeFragment.
    fragment<HomeFragment, Home> {
        label = "Home"
    }

    // Define the settings destination as a dialog using DialogFragment.
    dialog<SettingsFragment, Settings> {
        label = "Settings"
    }
}
```


## XML

既存の DialogFragment がある場合は、 `<dialog>` 要素を使用して、ナビゲーション グラフにダイアログを追加します。次の例をご覧ください。

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
            xmlns:app="http://schemas.android.com/apk/res-auto"
            android:id="@+id/nav_graph">

    <dialog
        android:id="@+id/my_dialog_fragment"
        android:name="androidx.navigation.myapp.MyDialogFragment">
        <argument android:name="myarg" android:defaultValue="@null" />
            <action
                android:id="@+id/myaction"
                app:destination="@+id/another_destination"/>
    </dialog>

</navigation>
```


## ダイアログのデスティネーションが有効な場合の例

以下の動画では、

- 「口座振替 / 一覧」 画面
- 「口座振替 / 変更」 画面

については、ホストされているデスティネーションを使用し、

- 「削除確認」 ダイアログ
- 「削除完了」 ダイアログ

については、ダイアログのデスティネーションを使用していません。

https://youtube.com/shorts/M3izVSYlNoU?feature=share

上記の動画をよく見ると、 「削除完了」 画面の 「閉じる」 をタップした直後に、背後で、 「変更」 画面から 「一覧」 画面に遷移し、その後、 「削除完了」 ダイアログが閉じられていることがわかると思います。

これでは動作が不自然であるため、このような場合には、 「削除完了」 ダイアログを 「ダイアログのデスティネーション」 として定義することが有効です。

こうすることで、 「削除完了」 ダイアログの削除と 「変更」 画面のポップアップを完全に同期することが可能になります。






