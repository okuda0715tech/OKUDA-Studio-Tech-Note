- [アプリ固有のファイルにアクセスする](#アプリ固有のファイルにアクセスする)
  - [内部ストレージにアクセスする](#内部ストレージにアクセスする)
    - [永続ファイルにアクセスする](#永続ファイルにアクセスする)
      - [File API を使用してファイルを保存する](#file-api-を使用してファイルを保存する)
      - [ストリームを使用してファイルを保存する](#ストリームを使用してファイルを保存する)
      - [File API を使用するかストリーム API を使用するか](#file-api-を使用するかストリーム-api-を使用するか)
      - [他のアプリからアクセスする方法](#他のアプリからアクセスする方法)
      - [ストリームを使用してファイルを参照する](#ストリームを使用してファイルを参照する)
      - [ファイルのリストを表示する](#ファイルのリストを表示する)
      - [ネストディレクトリを作成する](#ネストディレクトリを作成する)
        - [files ディレクトリの外にネストディレクトリを作成する](#files-ディレクトリの外にネストディレクトリを作成する)
        - [files ディレクトリの配下にネストディレクトリを作成する](#files-ディレクトリの配下にネストディレクトリを作成する)
    - [キャッシュファイルを作成する](#キャッシュファイルを作成する)
      - [方法１ : File.createTempFile() を呼び出す方法](#方法１--filecreatetempfile-を呼び出す方法)
      - [方法２ : Context オブジェクトの cacheDir プロパティと File API を使用する方法](#方法２--context-オブジェクトの-cachedir-プロパティと-file-api-を使用する方法)
      - [方法１と方法２の違い](#方法１と方法２の違い)
      - [作成したファイルに対して読み書きを行う](#作成したファイルに対して読み書きを行う)
    - [キャッシュファイルを削除する](#キャッシュファイルを削除する)
  - [外部ストレージにアクセスする](#外部ストレージにアクセスする)
    - [ストレージを使用できるか（マウントされており、読み書き可能かを）確認する](#ストレージを使用できるかマウントされており読み書き可能かを確認する)
    - [物理ストレージの場所を選択する（複数ある場合）](#物理ストレージの場所を選択する複数ある場合)
    - [永続ファイルにアクセスする](#永続ファイルにアクセスする-1)
    - [キャッシュファイルを作成する](#キャッシュファイルを作成する-1)
    - [キャッシュファイルを削除する](#キャッシュファイルを削除する-1)
    - [メディアコンテンツ](#メディアコンテンツ)
  - [空き領域を問い合わせる](#空き領域を問い合わせる)
    - [ストレージ管理アクティビティを作成する](#ストレージ管理アクティビティを作成する)
    - [一部のデバイスファイルを削除するようユーザーに依頼する](#一部のデバイスファイルを削除するようユーザーに依頼する)
    - [すべてのキャッシュファイルを削除するようユーザーに依頼する](#すべてのキャッシュファイルを削除するようユーザーに依頼する)


# アプリ固有のファイルにアクセスする

多くの場合、アプリが作成するファイルは、他のアプリがアクセスする必要のないファイル、または、アクセスすべきでないファイルです。このようなアプリ固有のファイルには、以下の保存場所が用意されています。

- **内部ストレージディレクトリ**
  - このディレクトリには、永続ファイルを保存するための専用の場所と、キャッシュデータを保存するための別の場所があります。
  - 他のアプリはこれらの場所にアクセスできません。
  - Android 10（API レベル 29）以上では、これらの場所は暗号化されます。
  - こうした特性により、これらの場所は、特定のアプリだけがアクセスできる機密データを保存するのに適しています。

- **外部ストレージディレクトリ**
  - このディレクトリには、永続ファイルを保存するための専用の場所と、キャッシュデータを保存するための別の場所があります。
  - **他のアプリも適切な権限を持っていればこれらのディレクトリにアクセスできます**
  - これらのディレクトリには **特定のアプリのみが使用することを目的とするファイルが保存されます。**
  - **他のアプリがアクセスできるファイルを作成する場合は、それらのファイルを外部ストレージの [共有ストレージ領域](https://developer.android.com/training/data-storage/shared?hl=ja&_gl=1*rnloia*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjU3NTIyNi4yLjAuMTcyMjU3NTIyNi4wLjAuMA..) に保存する必要があります。**

**ユーザーがアプリをアンインストールすると、アプリ固有のストレージに保存されているファイルは削除されます。** そのため、 **アプリから独立して保持されることをユーザーが期待するファイルは、このストレージに保存すべきではありません。** たとえば、ユーザーがアプリで写真を撮影した場合、通常はアプリをアンインストールした後でも写真にアクセスすることを望みます。その種のファイルは、共有ストレージを使用して適切な [メディアコレクション](https://developer.android.com/training/data-storage/shared/media?hl=ja&_gl=1*ttgza1*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjU3NTIyNi4yLjAuMTcyMjU3NTIyNi4wLjAuMA..) に保存する必要があります。

以下のセクションでは、アプリ固有のディレクトリにファイルを保存してアクセスする方法を説明します。


## 内部ストレージにアクセスする

内部ストレージ内には、アプリごとにディレクトリが用意されており、アプリはそこでアプリ固有のファイルを整理できます。1 つのディレクトリは、アプリの **永続ファイル用** に設計されています。もう 1 つのディレクトリは、アプリの **キャッシュファイル** 用です。 **これらのディレクトリ内のファイルを読み書きするのに、システム権限は必要ありません。**

**他のアプリは、内部ストレージ内に保存されているファイルにアクセスできません。** したがって、内部ストレージは他のアプリがアクセスすべきでないアプリデータを保存する場所に適しています。

ただし、これらのディレクトリは容量が小さいことが多いため、注意が必要です。アプリ固有のファイルを内部ストレージに **書き込む前に、デバイスの [空き領域を問い合わせる](#空き領域を問い合わせる) 必要があります。**


### 永続ファイルにアクセスする

アプリの通常の永続ファイルは、 Context オブジェクトの [filesDir](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1ki16ce*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getFilesDir()) プロパティを使用してアクセスできるディレクトリにあります。 filesDir プロパティは、 `/data/data/<app-package-name>/files/` ディレクトリを示します。フレームワークには、このディレクトリ内のファイルにアクセスして保存する方法がいくつか用意されています。


#### File API を使用してファイルを保存する

[File](https://developer.android.com/reference/java/io/File?hl=ja&_gl=1*1v1kh7z*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..) API を使用すると、ファイルにアクセスして保存できます。

アプリのパフォーマンスを落とさないために、同じファイルを何度も開いたり閉じたりしないでください。

次のコードスニペットは、 File API の使用方法を示しています。

```kotlin
val file = File(context.filesDir, filename)
// 書き込み
file.writeText("Hello, World!")
// 読み込み
val text = file.readText()   
```

#### ストリームを使用してファイルを保存する

File API を使用する代わりに、 [openFileOutput()](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*17i5vo0*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#openFileOutput(java.lang.String,%20int)) を呼び出して、 [filesDir](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1ki16ce*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getFilesDir()) ディレクトリ ( `/data/data/<app-package-name>/files/` ) 内のファイルへの書き込みを行う [FileOutputStream](https://developer.android.com/reference/java/io/FileOutputStream?hl=ja&_gl=1*1w8ucu8*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..) を取得することもできます。

次のコードスニペットは、ファイルにテキストを書き込む方法を示しています。

```kotlin
val filename = "myfile"
val fileContents = "Hello world!"
context.openFileOutput(filename, Context.MODE_PRIVATE).use {
        it.write(fileContents.toByteArray())
}
```

**注意**: Android 7.0（API レベル 24）以降を搭載したデバイスでは、 openFileOutput() に Context.MODE_PRIVATE ファイルモードを渡さないと、SecurityException が発生します。


#### File API を使用するかストリーム API を使用するか

File API を使用するかストリーム API を使用するかは、ユースケースにより異なります。 File API には、様々な機能が備わっていますが、コードが複雑になりがちです。一方で、ストリーム API は、できないこともありますが、コードがシンプルに記述できる傾向があります。


#### 他のアプリからアクセスする方法

内部ストレージ内のこのディレクトリに保存されている [ファイルに他のアプリがアクセスできるようにする](https://developer.android.com/training/secure-file-sharing?hl=ja&_gl=1*152zkgr*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..) には、 [ContentProvider](https://developer.android.com/reference/android/content/ContentProvider?_gl=1*1ceaoxg*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#query(android.net.Uri,%20java.lang.String%5B%5D,%20android.os.Bundle,%20android.os.CancellationSignal)) 、または、 [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider?hl=ja&_gl=1*17i5vo0*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..) を使用して、内部ストレージのデータを公開した上で、 [FLAG_GRANT_READ_URI_PERMISSION](https://developer.android.com/reference/android/content/Intent?hl=ja&_gl=1*152zkgr*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#FLAG_GRANT_READ_URI_PERMISSION) パーミッションを許可する必要があります。 FLAG_GRANT_READ_URI_PERMISSION の使用方法は、 [ファイルの権限を付与する](./10.ファイルの共有/3.ファイルの共有.md/#ファイルの権限を付与する) セクションを参照してください。


#### ストリームを使用してファイルを参照する

ファイルをストリームとして読み取るには、 [openFileInput()](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1y8xpvv*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#openFileInput(java.lang.String)) を使用します。

```kotlin
context.openFileInput(filename).bufferedReader().useLines { lines ->
    lines.reduce { accumulation, line ->
        "$accumulation\n$line"
    }
}
```

上記のコードは、読み取ったファイルの内容を一つの String 変数に格納する処理です。

- `context.openFileInput(filename)`
  - ファイルを開く処理です。
  - Android の内部ストレージに保存されたファイルを開きます。
  - filename には読み込むファイル名を指定します。
  - 返り値は FileInputStream です。
- `.bufferedReader()`
  - FileInputStream のラップとして bufferedReader() を使い、バッファ付きの BufferedReader を作成します。
  - BufferedReader を使うことで、データを効率的に読み取ることができます。
- `.useLines { lines -> ... }`
  - useLines { lines -> ... } を使うことで、ファイルの内容を1行ずつ処理することができます。
  - lines は `Sequence<String>` 型で、ファイルの各行が String として取得できます。
    - Sequence については、 [こちら](../../../../../../Kotlin/型_変数_値/コレクション/Sequence.md) を参照してください。
  - useLines は use {} と同様に、処理後に BufferedReader を自動的に閉じる役割もあります。
- reduce { accumulation, line -> "$accumulation\n$line" }
  - 改行コード ( `\n` ) で各行を連結して、一つの String 型の変数 accumulation に蓄積していきます。
  - 元資料では、 fold を使用していますが、これだと先頭行に余分な改行コードが入ってしまうため、 reduce に変更しています。
  - fold と reduce については、 [こちら](https://github.com/okuda0715tech/Knowledge_Stock/blob/1acfb08de57f1e89e459ff8f60594dc3a12a83aa/manual/Kotlin/%E5%9E%8B_%E5%A4%89%E6%95%B0_%E5%80%A4/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3/%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%93%8D%E4%BD%9C/%E9%9B%86%E8%A8%88%E3%81%A8%E8%93%84%E7%A9%8D.md#fold-and-reduce) を参照してください。

ChatGPT によると上記のコードよりも、下記のコードの方が直観的で良いようです。

```kotlin
context.openFileInput(filename).bufferedReader().use { it.readText() }
```

- `it.readText()`
  - ファイルの全内容を String として読み込むメソッドです。
  - ファイルの内容が複数行に渡る場合でも、改行コードを保持したまま String として読み込んでくれます。
    - つまり、元のファイルの改行が消えることはありません。

`readText()` は、ファイル全体を一括で読み込むため、大きなファイルには向いていません。大きなファイルを少しずつ処理したい場合は、 `readLines()` や `forEachLine {}` を使うのが良いです。

```kotlin
// readLines() を使用した例

val lines = context.openFileInput("example.txt").bufferedReader().use { it.readLines() }
```

上記の例では、 lines は、 `List<String>` となり、行ごとに List の各要素に格納されます。

```kotlin
// forEachLine {} を使用した例

context.openFileInput("example.txt").bufferedReader().use { reader ->
    reader.forEachLine { line ->
        println("Line: $line")
    }
}
```


**注**: アプリのインストール時にストリームとしてファイルにアクセスする必要がある場合は、ファイルをプロジェクトの `/res/raw` ディレクトリに保存します。それらのファイルを開くには、 [openRawResource()](https://developer.android.com/reference/android/content/res/Resources?hl=ja&_gl=1*1tncwkd*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#openRawResource(int)) を使用し、 `R.raw` プレフィックスを付けたファイル名をリソース ID として渡します。このメソッドから返される [InputStream](https://developer.android.com/reference/java/io/InputStream?hl=ja&_gl=1*1tncwkd*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..) を使用して、ファイルを読み取ることができます。元のファイルに書き込むことはできません。


#### ファイルのリストを表示する

次のコードスニペットに示すように、 [fileList()](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1tncwkd*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#fileList()) を呼び出すことで、 [filesDir](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1ki16ce*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getFilesDir()) ディレクトリ ( `/data/data/<app-package-name>/files/` ) 内のすべてのファイル名を含む配列を取得できます。

```kotlin
var files: Array<String> = context.fileList()
```

context.fileList() は、 getFilesDir() 直下のファイル名の一覧を取得するメソッドであり、サブディレクトリ内のファイルは取得できません。

サブディレクトリ内のファイルを取得するには、例えば、以下のように実装することができます。

```kotlin
import java.io.File

fun listAllFiles(dir: File): List<File> {
    val files = mutableListOf<File>()
    dir.listFiles()?.forEach { file ->
        if (file.isDirectory) {
            files.addAll(listAllFiles(file)) // 再帰的に取得
        } else {
            files.add(file)
        }
    }
    return files
}

// 使用例
val rootDir = File(context.filesDir, "your_subdirectory") // ルートディレクトリを指定
val allFiles = listAllFiles(rootDir)

allFiles.forEach { file ->
    println(file.absolutePath) // ファイルのパスを表示
}
```


#### ネストディレクトリを作成する

##### files ディレクトリの外にネストディレクトリを作成する

また、 Kotlin ベースのコードで [getDir()](https://developer.android.com/reference/kotlin/android/content/Context?hl=ja&_gl=1*1j9kwu2*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getdir) を呼び出すと、ネストディレクトリを作成したり、内部ディレクトリを開いたりできます。

```kotlin
context.getDir(dirName, Context.MODE_PRIVATE)
```

- `context.getDir(name, mode)` は、アプリの内部ストレージ ( `/data/data/<package>/app_<name>/` ) に指定した name のディレクトリを作成、または、開きます。
- `MODE_PRIVATE` を指定すると、そのディレクトリはアプリ専用になります。

```kotlin
import android.content.Context
import android.os.Bundle
import android.widget.TextView
import androidx.activity.ComponentActivity
import java.io.File

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // ネストされたディレクトリを作成
        val rootDir = getDir("myRootDir", Context.MODE_PRIVATE)  // /data/data/<package>/app_myRootDir/
        val nestedDir = File(rootDir, "subDir1/subDir2/subDir3")

        if (!nestedDir.exists()) {
            val created = nestedDir.mkdirs()  // 複数階層のディレクトリを作成
            if (created) {
                println("Nested directories created: ${nestedDir.absolutePath}")
            } else {
                println("Failed to create directories")
            }
        } else {
            println("Directories already exist: ${nestedDir.absolutePath}")
        }

        // 確認のため、作成したディレクトリのパスを表示
        val textView = TextView(this).apply {
            text = "Directory path: ${nestedDir.absolutePath}"
        }
        setContentView(textView)
    }
}
```

以下のようなネストディレクトリが作成されます。

```
/data/data/<package>/app_myRootDir/subDir1/subDir2/subDir3/
```


##### files ディレクトリの配下にネストディレクトリを作成する

`/data/data/<package>/files/` 配下にディレクトリを作成したい場合は、 `getFilesDir()` を使い、 `mkdirs()` を使用します。

```kotlin
import android.content.Context
import android.os.Bundle
import android.widget.TextView
import androidx.activity.ComponentActivity
import java.io.File

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // /data/data/<package>/files/ 配下のディレクトリを取得
        val filesDir = getFilesDir()  // /data/data/<package>/files/
        val nestedDir = File(filesDir, "myNestedDir/subDir1/subDir2")

        if (!nestedDir.exists()) {
            val created = nestedDir.mkdirs()  // ネストディレクトリを作成
            if (created) {
                println("Nested directories created: ${nestedDir.absolutePath}")
            } else {
                println("Failed to create directories")
            }
        } else {
            println("Directories already exist: ${nestedDir.absolutePath}")
        }

        // 確認のため、作成したディレクトリのパスを表示
        val textView = TextView(this).apply {
            text = "Directory path: ${nestedDir.absolutePath}"
        }
        setContentView(textView)
    }
}
```

以下のようなネストディレクトリが作成されます。

```
/data/data/<package>/files/myNestedDir/subDir1/subDir2/
```


### キャッシュファイルを作成する

機密データを一時的に保存する必要がある場合は、内部ストレージ内のアプリが指定したキャッシュディレクトリ ( `/data/data/<package_name>/cache/` ) を使用してデータを保存します。すべてのアプリ固有のストレージと同様に、このディレクトリに保存されているファイルは、ユーザーがアプリをアンインストールすると削除されますが、それよりも早いタイミングで削除される場合もあります。

**注意** : デバイスの内部ストレージの空き領域が少なくなると、空き領域を回復するため **Android が、キャッシュファイルを削除することがあります。** したがって、 **キャッシュファイルを読み取る前に、キャッシュファイルが存在しているかどうかを確認する必要があります。**

**注** : このキャッシュディレクトリに保存できるアプリの機密データは少量です。現在アプリで使用できるキャッシュ容量を確認するには、 [getCacheQuotaBytes()](https://developer.android.com/reference/android/os/storage/StorageManager?hl=ja&_gl=1*1x61dgt*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getCacheQuotaBytes(java.util.UUID)) を呼び出します。キャッシュファイルが保存できる上限容量や、キャッシュファイルの具体的な削除基準は公開されていません。そのため、デバイスのストレージに空き容量があるからといって、ファイルが保持されるとは限りません。キャッシュの容量は、デバイス上のストレージの空き容量と、アプリの使用頻度によって、変動します。

キャッシュファイルを作成する方法は 2 つあります。

#### 方法１ : [File.createTempFile()](https://developer.android.com/reference/java/io/File?hl=ja&_gl=1*1v10td2*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#createTempFile(java.lang.String,%20java.lang.String)) を呼び出す方法

```kotlin
val cacheFile = File.createTempFile(prefix = filename, suffix = null, directory = context.cacheDir)
```

- prefix
  - ファイル名の一部
  - 「prefix + ランダムな文字列」がファイル名として使用されます。
- suffinx
  - 拡張子
  - null の場合は、 `.tmp` となる。
- ディレクトリ
  - ファイルが作成されるディレクトリ
  - null の場合は、デフォルト値が使用される。

#### 方法２ : Context オブジェクトの [cacheDir](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1v10td2*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getCacheDir()) プロパティと [File](https://developer.android.com/reference/java/io/File?hl=ja&_gl=1*1v10td2*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..) API を使用する方法

```kotlin
val cacheFile = File(context.cacheDir, filename)
```


#### 方法１と方法２の違い

- createTempFile()
  - 即座に空の実ファイルを作成します。
- File API
  - File オブジェクトを作成するだけで、すぐに実際のファイルが作成されるわけではありません。
  - `writeText()` や `createNewFile()` が実行されると実際のファイルが作成されます。


#### 作成したファイルに対して読み書きを行う

方法１でファイルを作成した場合も、方法２でファイルを作成した場合も、以下の方法で、ファイルのコンテンツを読み書きできます。

```kotlin
// 書き込み
cacheFile.writeText("This is a temporary file")

// 読み取り
val content = cacheFile.readText()
```


### キャッシュファイルを削除する

**キャッシュファイルは随時 Android によって自動的に削除されますが、** だからといって **キャッシュファイルのクリーンアップをシステムにまかせるべきではありません。** 内部ストレージ内のアプリのキャッシュファイルを常にメンテナンスする必要があります。

内部ストレージ内のキャッシュディレクトリからファイルを削除するには、次のいずれかのメソッドを使用します。

ファイルを表す File オブジェクトの [delete()](https://developer.android.com/reference/java/io/File?hl=ja&_gl=1*1q6wdgw*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#delete()) メソッドを使用する方法

```kotlin
cacheFile.delete()
```

アプリの Context の [deleteFile()](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1oj35tt*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#deleteFile(java.lang.String)) メソッドにファイル名を渡して使用します。

```kotlin
context.deleteFile(cacheFileName)
```


## 外部ストレージにアクセスする

- 外部ストレージとは
  - `/storage/emulated/0/` 配下のこと
  - 特に `/storage/emulated/0/Android/data/<my-package-name>/` 配下は、アプリ固有のディレクトリです。
    - ただし、 PC からは閲覧できるため、機密情報は保存しないでください。
  - ファイルの種類ごとに分類された共有ディレクトリが存在します。
    - 例えば、 `/storage/emulated/0/Documents/` など。
- 外部ストレージの目的
  - 共有したいデータが存在する場合に使用する。 (主な目的)
  - 内部ストレージに十分な空きがなく、データが保存できない場合に使用する。 (近年はこれを目的とする場合は少ない)
- アプリ固有のディレクトリには、以下の 2 種類のディレクトリが存在する。
  - 永続ファイル用
  - キャッシュファイル用
- 外部ストレージ上にある自分のアプリのアプリ固有のディレクトリへのアクセスに必要な権限
  - Android 4.4（API レベル 19）以上では、権限をリクエストする必要はありません。
- 外部ストレージ上にある他のアプリのアプリ固有のディレクトリへのアクセスに必要な権限
  - Android 9（API レベル 28）以前を搭載したデバイスでは、適切なストレージ権限が必要
  - Android 10（API レベル 29）以降をターゲットとするアプリには、デフォルトで限定的なアクセス権が付与される。 **(対象範囲別ストレージ)**
- ファイルの削除タイミング
  - アプリ固有のディレクトリのデータは、アプリをアンインストールすると削除されます。
  - 共有ファイルのデータは、アプリをアンインストールしても削除されません。

**注意**: リムーバブル SD カードをデバイスから取り出したときなどは、これらのディレクトリ内のファイルにアクセスできない可能性があります。アプリに必須の機能がこれらのファイルに依存している場合は、内部ストレージにファイルを保存する必要があります。

ユーザーがファイルをきめ細かく管理して整理できるように、Android 10（API レベル 29）以降をターゲットとするアプリには、外部ストレージに対する限定的なアクセス権がデフォルトで付与されます（そのようなストレージを対象範囲別ストレージと呼びます）。対象範囲別ストレージを有効にすると、アプリは他のアプリに属するアプリ固有のディレクトリにアクセスできなくなります。


### ストレージを使用できるか（マウントされており、読み書き可能かを）確認する

外部ストレージはユーザーが取り外しできる物理ボリューム上にあるため、外部ストレージとの間でアプリ固有のデータの読み取りまたは書き込みを行う前に、ボリュームにアクセスできることを確認する必要があります。

ボリュームの状態を問い合わせるには、 [Environment.getExternalStorageState()](https://developer.android.com/reference/android/os/Environment?hl=ja&_gl=1*1d16xeq*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getExternalStorageState()) を呼び出します。返された状態が [MEDIA_MOUNTED](https://developer.android.com/reference/android/os/Environment?hl=ja&_gl=1*12hi09f*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#MEDIA_MOUNTED) の場合は、外部ストレージ内のアプリ固有のファイルの読み取りと書き込みを行うことができます。 [MEDIA_MOUNTED_READ_ONLY](https://developer.android.com/reference/android/os/Environment?hl=ja&_gl=1*12hi09f*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#MEDIA_MOUNTED_READ_ONLY) の場合は、それらのファイルの読み取りのみを行うことができます。

たとえば、以下のメソッドはストレージが使用可能かどうかを判断するのに役立ちます。

```kotlin
// 書き込み可能かどうかを返す
fun isExternalStorageWritable(): Boolean {
    return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED
}

// 読み取り可能かどうかを返す
fun isExternalStorageReadable(): Boolean {
     return Environment.getExternalStorageState() in
        setOf(Environment.MEDIA_MOUNTED, Environment.MEDIA_MOUNTED_READ_ONLY)
}
```

外部ストレージのスロットルを持っていないデバイスでは、次のコマンドで仮想ボリュームを有効にすることで、外部ストレージの可用性を確認するロジックをテストできます。

```
adb shell sm set-virtual-disk true
```


### 物理ストレージの場所を選択する（複数ある場合）

デバイスによっては、外部ストレージを複数搭載しているものがあります。 (例えば、 SD カードスロットルが一つしかないデバイスでも、内部メモリのパーティションを外部ストレージとして割り当てている可能性もあります。) そのような場合は、アプリ固有の外部ストレージに使用する物理ボリュームを選択する必要があります。

複数の場所にアクセスするには、 [ContextCompat.getExternalFilesDirs()](https://developer.android.com/reference/androidx/core/content/ContextCompat?hl=ja&_gl=1*1c7hhax*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getExternalFilesDirs(android.content.Context,%20java.lang.String)) を呼び出します。次のコードスニペットに示すように、返された配列の **最初の要素がプライマリ外部ストレージボリューム** と見なされます。基本的には、プライマリボリュームを使用してください。 **空き領域がない場合、または、ボリュームを使用できない場合** は、他のボリュームを使用します。

```kotlin
val externalStorageVolumes: Array<out File> =
        ContextCompat.getExternalFilesDirs(applicationContext, null)
val primaryExternalStorage = externalStorageVolumes[0]
```


### 永続ファイルにアクセスする

外部ストレージからアプリ固有のファイルにアクセスするには、 [getExternalFilesDir()](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*1r6rqyy*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getExternalFilesDir(java.lang.String)) を呼び出します。 (基本的には、複数の外部ストレージが存在することを考慮して、上記の [ContextCompat.getExternalFilesDirs()](https://developer.android.com/reference/androidx/core/content/ContextCompat?hl=ja&_gl=1*1c7hhax*_up*MQ..*_ga*NzYxMjYyODQ5LjE3MjI1ODM3Njk.*_ga_6HH9YJMN9M*MTcyMjU4Mzc2OC4xLjAuMTcyMjU4Mzc2OC4wLjAuMA..#getExternalFilesDirs(android.content.Context,%20java.lang.String)) を使用したほうが良い？)

アプリのパフォーマンスを落とさないために、同じファイルを何度も開いたり閉じたりしないでください。

次のコード スニペットは、getExternalFilesDir() を呼び出す方法を示しています。

```kotlin
val appSpecificExternalDir = File(context.getExternalFilesDir(null), filename)
```

**Android 11 以降、上記以外の方法で、外部ストレージ ( `/storage/emulated/0/` ) 内の任意の場所に、アプリ固有のディレクトリを作成することはできません。外部ストレージ内のアプリ固有のディレクトリは、既定された場所 ( `/storage/emulated/0/Android/data/<my-package-name>/` ) にのみ存在できます。**


### キャッシュファイルを作成する

外部ストレージ上のアプリ固有のディレクトリ内に、キャッシュファイルを追加するには、 [externalCacheDir](https://developer.android.com/reference/android/content/Context?hl=ja&_gl=1*2ru269*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#getExternalCacheDir()) への参照を取得します。

```kotlin
val externalCacheFile = File(context.externalCacheDir, filename)
```


### キャッシュファイルを削除する

外部キャッシュディレクトリからファイルを削除するには、ファイルを表す File オブジェクトで [delete()](https://developer.android.com/reference/java/io/File?hl=ja&_gl=1*2ru269*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#delete()) メソッドを使用します。

```kotlin
externalCacheFile.delete()
```


### メディアコンテンツ

アプリ固有の外部ストレージも、ファイルの種類ごとに、ディレクトリを分けることが可能です。ディレクトリをわけるには、 getExternalFilesDir() の引数に、ファイルの種類を指定する定数を与えます。ただし、 **Android 10 以降は、 MediaStore API を使用して、 `/storage/emulated/0/Pictures/` などに保存することが推奨** されています。

```kotlin
fun getAppSpecificAlbumStorageDir(context: Context, albumName: String): File? {
    val file = File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName)
    if (!file?.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created")
    }
    return file
}
```

[DIRECTORY_PICTURES](https://developer.android.com/reference/android/os/Environment?hl=ja#DIRECTORY_PICTURES) 定数などの既定のディレクトリ名を使用することが重要です。デフォルトでは、そこに格納されたファイルは、自動的に MediaScannerConnection.scanFile でスキャンされることはありませんが、明示的にスキャンする処理を記述することで、スキャンを実施することが可能になります。スキャンされると、写真アプリなどで、その写真が表示されるようになるそうです。

事前定義済みのサブディレクトリ名のいずれもファイルに適合しない場合は、代わりに null を getExternalFilesDir() に渡すことができます。そうすると、外部ストレージ内のアプリ固有のルートディレクトリが返されます。

その他の既定のディレクトリは、 [こちら](https://developer.android.com/reference/android/os/Environment?hl=ja#fields) を参照してください。


## 空き領域を問い合わせる

多くのユーザーのデバイスでは、空き領域があまり残っていない場合が多く、アプリでは慎重にストレージ領域を使用する必要があります。

保存するデータの量が事前にわかっている場合は、 [getAllocatableBytes()](https://developer.android.com/reference/android/os/storage/StorageManager?hl=ja&_gl=1*hl2bdf*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#getAllocatableBytes(java.util.UUID)) を呼び出して、アプリが使用できるデバイスの空き容量を確認できます。getAllocatableBytes() の戻り値は、デバイスの現在の空き容量よりも大きくなることがあります。これは、システムが他のアプリのキャッシュ ディレクトリから削除できるファイルを発見したためです。

アプリのデータを保存するのに十分な空き領域がある場合は、 [allocateBytes()](https://developer.android.com/reference/android/os/storage/StorageManager?hl=ja&_gl=1*ak2hji*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#allocateBytes(java.io.FileDescriptor,%20long)) を呼び出して、領域を確保します。それ以外の場合は、デバイスから [一部のファイルを削除](#一部のデバイスファイルを削除するようユーザーに依頼する) するか、デバイスから [すべてのキャッシュファイルを削除](#すべてのキャッシュファイルを削除するようユーザーに依頼する) するようユーザーに求めることができます。

アプリがデバイスの空き容量を問い合わせる方法の例を次のコードスニペットに示します。

```kotlin
// アプリは内部ストレージに 10 MB 必要だとします。
const val NUM_BYTES_NEEDED_FOR_MY_APP = 1024 * 1024 * 10L;

val storageManager = applicationContext.getSystemService<StorageManager>()!!
// filesDir は、空きがあるか確認したいディレクトリ
val appSpecificInternalDirUuid: UUID = storageManager.getUuidForPath(filesDir)
val availableBytes: Long =
        storageManager.getAllocatableBytes(appSpecificInternalDirUuid)
if (availableBytes >= NUM_BYTES_NEEDED_FOR_MY_APP) {
    storageManager.allocateBytes(
        appSpecificInternalDirUuid, NUM_BYTES_NEEDED_FOR_MY_APP)
} else {
    val storageIntent = Intent().apply {
        // ユーザーに全てのキャッシュファイルの削除を求める代わりに、
        // ACTION_CLEAR_APP_CACHE アクションを Intent にセットします。
        action = ACTION_MANAGE_STORAGE
    }
}
```

**注**: ファイルを保存する前に、空き容量をチェックすることは必須ではありません。チェックしないでファイルの書き込みを試み、 IOException が発生したらキャッチする方法もあります。 **必要な容量が正確にわからない場合** は、この方法が必要になります。たとえば、PNG 画像を JPEG 画像に変換するときなど、ファイルのエンコードを変更した後で保存する場合、ファイルのサイズは事前にわかりません。


### ストレージ管理アクティビティを作成する

ユーザは、アプリがデバイスに保存したデータを管理することができます。管理するためには、アプリでカスタムアクティビティを作成します。マニフェストファイルの `<application>` タグに [android:manageSpaceActivity](https://developer.android.com/guide/topics/manifest/application-element?hl=ja&_gl=1*1j50c3n*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#space) 属性を追加して、カスタム容量管理アクティビティを宣言します。ファイルマネージャーアプリは、アプリのアクティビティが android:exported = false になっていても、このアクティビティを呼び出すことができます。


### 一部のデバイスファイルを削除するようユーザーに依頼する

デバイス上の空き容量を確保するために、ファイルを選択して、削除するようユーザーに求めることができます。これをするには、 [ACTION_MANAGE_STORAGE](https://developer.android.com/reference/android/os/storage/StorageManager?hl=ja&_gl=1*1tru6qs*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#ACTION_MANAGE_STORAGE) アクションを含むインテントを呼び出します。このインテントによって、ユーザーにプロンプトが表示されます。デバイスの使用可能な空き容量をこのプロンプトに表示することもできます。このユーザーフレンドリーな情報を表示するには、次の計算の結果を使用します。

```
StorageStatsManager.getFreeBytes() / StorageStatsManager.getTotalBytes()
```


### すべてのキャッシュファイルを削除するようユーザーに依頼する

デバイス上のすべてのアプリから、キャッシュファイルを削除するようユーザーに求めることもできます。そのためには、 [ACTION_CLEAR_APP_CACHE](https://developer.android.com/reference/android/os/storage/StorageManager?hl=ja&_gl=1*1rrspyn*_up*MQ..*_ga*MjI0NTM2NDk1LjE3MjI3NDg4Mzc.*_ga_6HH9YJMN9M*MTcyMjc0ODgzNy4xLjAuMTcyMjc0ODgzNy4wLjAuMA..#ACTION_CLEAR_APP_CACHE) インテントアクションを含むインテントを呼び出します。

**注意**: ACTION_CLEAR_APP_CACHE インテントのアクションは、デバイスのバッテリー駆動時間に大きく影響する可能性があり、デバイスから多数のファイルを削除する可能性があります。

