- [コンテンツプロバイダの作成](#コンテンツプロバイダの作成)
  - [作成を始める前に](#作成を始める前に)
  - [データストレージを設計する](#データストレージを設計する)
    - [データ設計上の考慮事項](#データ設計上の考慮事項)
  - [コンテンツ URI を設計する](#コンテンツ-uri-を設計する)
    - [オーソリティを設計する](#オーソリティを設計する)
    - [パス構造を設計する](#パス構造を設計する)
    - [コンテンツ URI ID を処理する](#コンテンツ-uri-id-を処理する)
    - [コンテンツ URI パターン](#コンテンツ-uri-パターン)
  - [ContentProvider クラスを実装する](#contentprovider-クラスを実装する)
    - [必須メソッド](#必須メソッド)
    - [query() メソッドを実装する](#query-メソッドを実装する)
    - [Insert() メソッドを実装する](#insert-メソッドを実装する)
    - [delete() メソッドを実装する](#delete-メソッドを実装する)
    - [update() メソッドを実装する](#update-メソッドを実装する)
    - [onCreate() メソッドを実装する](#oncreate-メソッドを実装する)
  - [ContentProvider MIME タイプを実装する](#contentprovider-mime-タイプを実装する)
    - [テーブルの MIME タイプ](#テーブルの-mime-タイプ)
    - [ファイルの MIME タイプ](#ファイルの-mime-タイプ)
  - [コントラクトクラスを実装する](#コントラクトクラスを実装する)
  - [コンテンツプロバイダの権限を実装する](#コンテンツプロバイダの権限を実装する)
    - [権限はなぜ必要か](#権限はなぜ必要か)
    - [権限を実装する](#権限を実装する)
      - [プロバイダレベルの「読み取り + 書き込み」権限を設定する](#プロバイダレベルの読み取り--書き込み権限を設定する)
      - [プロバイダレベルの「読み取り」権限と「書き込み」権限を個別に設定する](#プロバイダレベルの読み取り権限と書き込み権限を個別に設定する)
      - [パスレベルの権限](#パスレベルの権限)
      - [一時的な権限](#一時的な権限)
  - [\<provider\> 要素](#provider-要素)
    - [オーソリティ ( android:authorities )](#オーソリティ--androidauthorities-)
    - [プロバイダのクラス名 ( android:name )](#プロバイダのクラス名--androidname-)
    - [権限](#権限)
    - [起動と制御の属性](#起動と制御の属性)
    - [情報属性](#情報属性)
  - [インテントとデータアクセス](#インテントとデータアクセス)


# コンテンツプロバイダの作成

コンテンツ プロバイダは、データのセントラルリポジトリへのアクセスを管理します。プロバイダは、マニフェストファイル内の要素とともに、 Android アプリの 1 つ以上のクラスとして実装します。このクラスのうちの 1 つが [ContentProvider](https://developer.android.com/reference/android/content/ContentProvider?hl=ja&_gl=1*1smnrxw*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) のサブクラスを実装している必要があります。このサブクラスは、プロバイダと他のアプリとの間のインターフェースとなります。、

コンテンツプロバイダは、他のアプリがデータを利用できるようにするためのものですが、プロバイダが管理するデータをユーザーがクエリしたり、変更したりできるアクティビティをアプリ内に置くことができます。

このページでは、コンテンツプロバイダを作成する際の基本的なプロセスと、使用する API のリストについて説明します。


## 作成を始める前に

プロバイダの構築を開始する前に、次の点を考慮してください。

- **コンテンツプロバイダが必要かどうかを判断する。** 次の機能の 1 つ以上を提供する場合は、コンテンツプロバイダを構築する必要があります。
  - 複雑なデータやファイルを他のアプリケーションに提供したい場合。
  - ユーザーが複雑なデータを自分のアプリから他のアプリにコピーできるようにしたい場合。
  - 検索フレームワークを使用してカスタム検索候補を提供したい場合。
  - アプリケーションデータをウィジェットに公開する必要がある場合。
  - [AbstractThreadedSyncAdapter](https://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter?hl=ja&_gl=1*1nj1rab*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) クラス、 [CursorAdapter](https://developer.android.com/reference/android/widget/CursorAdapter?hl=ja&_gl=1*1nj1rab*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) クラス、または [CursorLoader](https://developer.android.com/reference/android/content/CursorLoader?hl=ja&_gl=1*1nj1rab*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) クラスを実装する場合。

完全に独自のアプリケーション内で使用し、上記の機能が必要ない場合は、プロバイダでデータベースやその他のタイプの永続ストレージを使用する必要はありません。代わりに、 [データとファイルストレージの概要](../2.ストレージについて.md) で説明されているストレージシステムを使用できます。

- まだ読んでいない場合は、 [コンテンツプロバイダの基本](./2.コンテンツプロバイダの基本.md) を読み、プロバイダとその仕組みの詳細を確認してください。

次に、以下の手順に沿ってプロバイダをビルドします。

１. データを実際に格納するストレージを設計します。他のアプリは、コンテンツプロバイダを通じて、このストレージにアクセスします。

コンテンツプロバイダは、次の 2 つの方法でデータを提供します。
 
- **ファイルデータ**
  - ファイルに含まれるデータ（写真、音声、動画など）。通常、ファイルは、アプリのプライベートスペースに保存します。別のアプリケーションからのファイルのリクエストに応じて、プロバイダからファイルへのハンドルを提供できます。
- **「構造化」 データ**
  - データベース、配列、または同様の構造に入るデータ。通常、行と列のテーブルと互換性のある形式でデータを保存します。行は、人物や在庫のアイテムなどのエンティティを表します。列は、個人の名前やアイテムの価格など、エンティティのデータを表します。このタイプのデータを保存する一般的な方法は SQLite データベースですが、どのタイプの永続ストレージでも使用できます。Android システムで利用可能なストレージ タイプについて詳しくは、 [データストレージを設計する](https://developer.android.com/guide/topics/providers/content-provider-creating?hl=ja&_gl=1*107gkyj*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#DataStorage) のセクションをご覧ください。

２. ContentProvider クラスの具体的な実装と必要なメソッドを定義します。このクラスは、データと Android システムの他の部分との間のインターフェースとなります。このクラスの詳細については、 [ContentProvider クラスを実装する](#contentprovider-クラスを実装する) のセクションをご覧ください。

３. プロバイダのオーソリティ文字列、コンテンツ URI 、列名を定義します。

- プロバイダのアプリでインテントを処理する場合は、インテントのアクション、エクストラデータ、フラグも定義します。
- データにアクセスするアプリケーションに必要な権限も定義します。
- これらの値は、すべて定数として定義します。これらの定義は、別のコントラクトクラスに定義することを検討してください。
- コントラクトクラスは、後で他のデベロッパーに公開できます。
- コンテンツ URI について詳しくは、 [コンテンツ URI を設計する](#コンテンツ-uri-を設計する) をご覧ください。
- インテントの詳細については、 [インテントとデータアクセス](#インテントとデータアクセス) をご覧ください。

４. サンプルデータや、プロバイダとクラウドベースのデータの間でデータを同期できる [AbstractThreadedSyncAdapter](https://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter?hl=ja&_gl=1*1khgnfj*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) の実装など、その他のオプション要素を追加します。


## データストレージを設計する

コンテンツプロバイダは、構造化された形式で保存されたデータへのインターフェースです。インターフェースを作成する前に、データの保存方法を決定します。任意の形式でデータを保存でき、必要に応じてデータを読み書きするようにインターフェースを設計できます。

Android で使用できるデータストレージ技術には、次のようなものがあります。

- 構造化データを扱う場合は、 SQLite などのリレーショナルデータベースまたは [LevelDB](https://github.com/google/leveldb) などの非リレーショナル Key-Value データストアの使用を検討してください。音声、画像、動画メディアなどの非構造化データを扱う場合は、データをファイルとして保存することを検討してください。 **複数の異なるタイプのストレージを組み合わせ、必要に応じて単一のコンテンツプロバイダを使用して公開できます。**
- Android システムは Room 永続ライブラリとやり取りできます。このライブラリは、Android 独自のプロバイダがテーブル指向のデータを保存するために使用する SQLite データベース API へのアクセスを提供します。このライブラリを使用してデータベースを作成するには、 [Room を使用してローカルデータベースにデータを保存する](https://developer.android.com/training/data-storage/room?hl=ja&_gl=1*1q713zs*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) で説明しているように、 [RoomDatabase](https://developer.android.com/reference/androidx/room/RoomDatabase?hl=ja&_gl=1*1q713zs*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) のサブクラスをインスタンス化します。

ストレージの実装に、必ずしもデータベースを選択する必要はありません。プロバイダは、リレーショナルデータベースと同様に一連のテーブルとして外部から見えますが、プロバイダの内部実装では必須ではありません。

- Android には、ファイルデータを保存するためにさまざまなファイル指向 API が用意されています。ファイルストレージの詳細については、 [データとファイルストレージの概要](https://developer.android.com/guide/topics/data/data-storage?hl=ja&_gl=1*137fzrb*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) をご覧ください。 **音楽や動画などのメディア関連データを提供するプロバイダを設計する場合は、テーブルデータとファイルを組み合わせるプロバイダを使用できます。**
- まれに、 1 つのアプリに **複数のコンテンツプロバイダを実装すると便利な場合があります。** たとえば、あるコンテンツプロバイダを使用して一部のデータをウィジェットと共有し、別のデータセットを公開して他のアプリと共有したい場合があります。
- ネットワークベースのデータを操作するには、 [java.net](https://developer.android.com/reference/java/net/package-summary?hl=ja&_gl=1*1j9jcky*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) と [android.net](https://developer.android.com/reference/android/net/package-summary?hl=ja&_gl=1*1lpa6yh*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) のクラスを使用します。ネットワークベースのデータをデータベースなどのローカルータストアに同期し、データをテーブルやファイルとして提供することもできます。

**注**: 下位互換性のない変更をリポジトリに加えた場合は、リポジトリを新しいバージョン番号でマークする必要があります。また、新しいコンテンツプロバイダを実装するアプリのバージョン番号を増やす必要があります。この変更を行うと、互換性のない古いコンテンツプロバイダを持つアプリを再インストールしようとしたときに、システムのダウングレードによってシステムがクラッシュするのを防ぐことができます。


### データ設計上の考慮事項

プロバイダのデータ構造を設計する際のヒントは次のとおりです。

- **テーブルデータ**
  - プロバイダが **各行の一意の数値として保持する「主キー」列が常に必要** です。この値を使用すると、行を他のテーブルの関連する行にリンクできます（「外部キー」として使用）。この列には任意の名前を使用できますが、プロバイダクエリの結果を ListView にリンクするには、取得した列のいずれかの名前を _ID にする必要があります。そのため、 [BaseColumns._ID](https://developer.android.com/reference/android/provider/BaseColumns?hl=ja&_gl=1*1rc1ila*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#_ID) **を使用することをおすすめします。**
- **ファイル指向データ**
  - **ビットマップ画像や、その他の非常に大きなファイル指向データを提供する場合は、データをファイルに格納し、テーブルに直接保存するのではなく、間接的にそのデータを提供します。** これを行う場合は、 [ContentResolver](https://developer.android.com/reference/android/content/ContentResolver) の **ファイル関連メソッド** を使用してデータにアクセスする必要があることをプロバイダのユーザーに伝える必要があります。
- **バイナリラージオブジェクト ( BLOB ) データ型**
  - BLOB は、さまざまなサイズや構造を持つデータを格納するために使用します。たとえば、BLOB 列を使用して、 [プロトコルバッファ](http://code.google.com/p/protobuf?hl=ja) や [JSON 構造](http://www.json.org/) を格納できます。

BLOB を使用して、スキーマに依存しないテーブルを実装することもできます。このタイプのテーブルでは、主キー列、MIME タイプの列、1 つ以上の汎用列を BLOB として定義します。BLOB 列内のデータの意味は、MIME タイプ列の値によって示されます。これにより、同じテーブルに異なるタイプの行を格納できます。連絡先プロバイダの [ContactsContract.Data](https://developer.android.com/reference/android/provider/ContactsContract.Data?hl=ja&_gl=1*1x7xoz0*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) テーブルは、スキーマに依存しないテーブルの例です。


## コンテンツ URI を設計する

コンテンツ URI は、プロバイダのデータを特定する URI です。コンテンツ URI は、以下のパーツで構成されます。

- プロバイダを示す名前（オーソリティ）
- テーブル、または、ファイルを指す名前（パス）
- オプションの ID は、テーブル内の個々の行を参照します。
  
ContentProvider のすべてのデータアクセスメソッドには、引数としてコンテンツ URI があります。これにより、アクセスするテーブル、行、ファイルを決定できます。


### オーソリティを設計する

プロバイダには通常、Android 内部の名前として機能する 1 つのオーソリティがあります。他のプロバイダとの競合を回避するには、インターネットドメインの所有権を（逆方向に）プロバイダオーソリティの基礎として使用します。この推奨事項は Android パッケージ名にも当てはまるため、プロバイダオーソリティを、プロバイダを含むパッケージの名前の拡張として定義できます。

たとえば、 Android パッケージ名が com.example.appname の場合、プロバイダに com.example.appname.provider というオーソリティを付与します。

たいていの場合は、

```
パッケージ名 + プロバイダ名
```

とすれば問題ないと思われます。


### パス構造を設計する

デベロッパーは通常、オーソリティ (プロバイダ名) に、パス (テーブル名・ファイル名) を付加して、コンテンツ URI を作成します。たとえば、 table1 と table2 という 2 つのテーブルがある場合、これらを前の例の権限と組み合わせると、コンテンツ URI `com.example.appname.provider/table1` と `com.example.appname.provider/table2` を生成できます。

パスは 1 つのセグメントに制限されるわけではなく、スラッシュで区切って、複数のセグメントを定義することが可能です。複数のセグメントに区切ることで、グループを定義して、整理することが可能です。以下は、複数のセグメントの例です。

```
// 複数のセグメントを持つ URI の例
content://com.example.appname.provider/group1/table1/
```

パスの各レベルにテーブルを作成する必要もありません。つまり、上記の例の場合、 group1 はテーブルではなく、単にグループわけや名前空間のように使用されます。


### コンテンツ URI ID を処理する

慣例として、プロバイダは、URI の末尾に ID 値を持つ URI を使用することで、テーブル内の特定の 1 つの行へのアクセスを提供します。また、慣例により、 **プロバイダは ID 値とテーブルの _ID 列を照合し、一致する行に対してアクセスします。**

この規則により、プロバイダにアクセスするアプリの一般的な設計パターンが容易になります。アプリはプロバイダに対してクエリを実行し、CursorAdapter を使用して結果の Cursor を ListView に表示します。CursorAdapter の定義では、Cursor の列のいずれかを _ID にする必要があります。

_ID 値をコンテンツ URI に追加して、アクセスリクエストをプロバイダに送信します。プロバイダは、 _ID で指定した行に対してクエリや変更を実行できます。


### コンテンツ URI パターン

[UriMatcher.addURI()](https://developer.android.com/reference/android/content/UriMatcher#addURI(java.lang.String,%20java.lang.String,%20int)) メソッドは、オーソリティとパスを整数値にマッピングします。

```kotlin
private val sUriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply {
    /*
     * Matcher.match(uri) の uri が、
     * com.example.app.provider/table3 の場合に
     * 1 を返すように URI と整数値をマッピングします。 
     */
    addURI("com.example.app.provider", "table3", 1)

    /*
     * Matcher.match(uri) の uri が、
     * com.example.app.provider/table3/数字 の場合に
     * 2 を返すように URI と整数値をマッピングします。 
     * 例えば、
     * content://com.example.app.provider/table3/3 は 2 を返しますが、
     * content://com.example.app.provider/table3 は 2 を返しません
     */
    addURI("com.example.app.provider", "table3/#", 2)
}
```

`addURI()` では、以下のワイルドカードが使用できます。

- `#` は、任意の数値を意味します。
  - ID を識別するのに使用します。
  - つまり、 URI が 1 件のレコードであることを識別します。
- `*` は、任意の文字を意味します。
  - ID であれ、テーブル名であれ、どちらの場合も含まれます。
  - つまり、 1 件のレコードでも、テーブルでも、どちらの場合も含まれます。

[UriMatcher.match()](https://developer.android.com/reference/android/content/UriMatcher#match(android.net.Uri)) メソッドは URI の整数値を返します。 when ステートメントは、テーブル全体に対してクエリを実行するか、単一レコードに対してクエリを実行するかを選択します。

```kotlin
class ExampleProvider : ContentProvider() {

    override fun query(
            uri: Uri?,
            projection: Array<out String>?,
            selection: String?,
            selectionArgs: Array<out String>?,
            sortOrder: String?
    ): Cursor? {
        var localSortOrder: String = sortOrder ?: ""
        var localSelection: String = selection ?: ""
        when (sUriMatcher.match(uri)) {
            1 -> { // 受信 URI が table3 全体を示している場合
                if (localSortOrder.isEmpty()) {
                    localSortOrder = "_ID ASC"
                }
            }
            2 -> {  // 受信した URI が table3 の単一行を示している場合
                /*
                 * この URI は単一行用であるため、_ID 値部分が存在します。
                 * URI から最後のパスセグメントを取得します。
                 * これが _ID 値です。
                 * 次に、その値をクエリの WHERE 句に追加します。
                 */
                localSelection += "_ID ${uri?.lastPathSegment}"
            }
            else -> { // URI が認識されなかった場合
                // エラーハンドリングをここで実施
            }
        }

        // SQL の SELECT 文のような、実際にデータの取得を実行するコードをここに記述します。
    }
}
```

もう 1 つのクラス [ContentUris](https://developer.android.com/reference/android/content/ContentUris?hl=ja&_gl=1*1x4cgji*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) は、コンテンツ URI の id 部分を操作するための便利なメソッドを提供します。 [Uri](https://developer.android.com/reference/android/net/Uri?hl=ja&_gl=1*1x4cgji*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) クラスと [Uri.Builder](https://developer.android.com/reference/android/net/Uri.Builder?hl=ja&_gl=1*1x4cgji*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) クラスには、既存の Uri オブジェクトを解析し、新しいオブジェクトを作成するための便利なメソッドが含まれています。


## ContentProvider クラスを実装する

ContentProvider インスタンスは、他のアプリからのリクエストを処理することで、構造化されたデータセットへのアクセスを管理します。どの形式のアクセスでも、最終的に ContentResolver が呼び出されます。その後、 ContentProvider の具体的なメソッドが呼び出され、アクセス権を取得します。


### 必須メソッド

抽象クラス [ContentProvider](https://developer.android.com/reference/android/content/ContentProvider?_gl=1*10990le*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjQ5NzU3OC4yLjAuMTcyMjQ5NzU3OC4wLjAuMA..) は、具象サブクラスの一部として実装する 6 つの抽象メソッドを定義します。 onCreate() を除くすべてのメソッドは、コンテンツ プロバイダにアクセスしようとしているクライアント アプリケーションによって呼び出されます。

- [query()](https://developer.android.com/reference/android/content/ContentProvider#query(android.net.Uri,%20java.lang.String[],%20java.lang.String,%20java.lang.String[],%20java.lang.String))
  - プロバイダからデータを取得します。引数を使用して、クエリを実行するテーブル、返される行と列、結果の並べ替え順序を選択します。データを Cursor オブジェクトとして返します。
  - データソースがファイルシステムの場合は、通常、 query() メソッドでは、ファイルのメタデータの一覧を取得します。
  - ファイルを実際に開く処理は、 [openFile()](https://developer.android.com/reference/android/content/ContentProvider?_gl=1*10990le*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjQ5NzU3OC4yLjAuMTcyMjQ5NzU3OC4wLjAuMA..#openFile(android.net.Uri,%20java.lang.String,%20android.os.CancellationSignal)) メソッドをオーバーライドします。
- [insert()](https://developer.android.com/reference/android/content/ContentProvider#insert(android.net.Uri,%20android.content.ContentValues))
  - プロバイダに新しい行を挿入します。引数を使用して宛先テーブルを選択し、データを挿入する列の名前と値を指定します。新しく挿入された行のコンテンツ URI を返します。
- [update()](https://developer.android.com/reference/android/content/ContentProvider#update(android.net.Uri,%20android.content.ContentValues,%20java.lang.String,%20java.lang.String[]))
  - プロバイダの既存の行を更新します。引数を使用して、更新するテーブルと行を選択し、更新する列の名前と値を指定します。更新された行数を返します。
- [delete()](https://developer.android.com/reference/android/content/ContentProvider#delete(android.net.Uri,%20java.lang.String,%20java.lang.String[]))
  - プロバイダから行を削除します。引数を使用して、削除するテーブルと行を選択します。削除された行数を返します。
- [getType()](https://developer.android.com/reference/android/content/ContentProvider#getType(android.net.Uri))
  - コンテンツ URI に対応する MIME タイプを返します。この方法について詳しくは、 [コンテンツプロバイダの MIME タイプを実装する](#contentprovider-mime-タイプを実装する) のセクションをご覧ください。
- [onCreate()](https://developer.android.com/reference/android/content/ContentProvider#onCreate())
  - プロバイダを初期化します。Android システムは、プロバイダを作成した直後にこのメソッドを呼び出します。プロバイダは、ContentResolver オブジェクトがアクセスを試みるまで作成されません。

これらのメソッドは、同じ名前の ContentResolver メソッドと同じシグネチャを持ちます。

これらのメソッドの実装では、次の点を考慮する必要があります。

- onCreate() を除くすべてのメソッドは、複数のスレッドから一度に呼び出される可能性があるため、スレッドセーフである必要があります。複数のスレッドの詳細については、 プロセスとスレッドの概要をご覧ください。
- onCreate() では長時間のオペレーションを行わないでください。実際に必要になるまで初期化タスクを延期します。詳しくは、 [onCreate() メソッドの実装](#oncreate-メソッドを実装する) に関するセクションをご覧ください。
- これらのメソッドは実装する必要がありますが、他のアプリに提供したくない機能がある場合もあります。たとえば、他のアプリが一部のテーブルにデータを挿入できないようにするには、 insert() の呼び出しを無視して 0 を返します。


### query() メソッドを実装する

[ContentProvider.query()](https://developer.android.com/reference/android/content/ContentProvider?hl=ja&_gl=1*g1b7fi*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#query(android.net.Uri,%20java.lang.String%5B%5D,%20java.lang.String,%20java.lang.String%5B%5D,%20java.lang.String)) メソッドは Cursor オブジェクトを返す必要があります。失敗した場合は Exception をスローします。SQLite データベースをデータ ストレージとして使用する場合は、SQLiteDatabase クラスの query() メソッドのいずれかによって返される Cursor を返すことができます。

クエリがどの行とも一致しない場合は、 [getCount()](https://developer.android.com/reference/android/database/Cursor?hl=ja&_gl=1*g1b7fi*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#getCount()) メソッドが 0 を返す Cursor インスタンスを返します。クエリプロセス中に内部エラーが発生した場合にのみ、null を返します。

SQLite データベースをデータ ストレージとして使用していない場合は、 Cursor の具体的なサブクラスのいずれかを使用します。たとえば、 [MatrixCursor](https://developer.android.com/reference/android/database/MatrixCursor?hl=ja&_gl=1*926hoj*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) クラスは、各行が Object インスタンスの配列であるカーソルを実装します。このクラスでは、 [addRow()](https://developer.android.com/reference/android/database/MatrixCursor?hl=ja&_gl=1*926hoj*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#addRow(java.lang.Object%5B%5D)) を使用して新しい行を追加します。

Android システムは、プロセスの境界を越えて Exception を通信できる必要があります。Android では、クエリエラーの処理に役立つ次の例外に対してこの処理を実行できます。

- IllegalArgumentException
  - プロバイダが無効なコンテンツ URI を受け取った場合にスローできます。
- NullPointerException


### Insert() メソッドを実装する

insert() メソッドは、 [ContentValues](https://developer.android.com/reference/android/content/ContentValues?hl=ja&_gl=1*926hoj*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) 引数の値を使用して、適切なテーブルに新しい行を追加します。列名が ContentValues 引数にない場合は、プロバイダ コードまたはデータベース スキーマでデフォルト値を指定できます。

このメソッドは、新しい行のコンテンツ URI を返します。これを作成するには、 [withAppendedId()](https://developer.android.com/reference/android/content/ContentUris?hl=ja&_gl=1*dm2npx*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#withAppendedId(android.net.Uri,%20long)) を使用して、新しい行の主キー（通常は _ID 値）をテーブルのコンテンツ URI に追加します。


### delete() メソッドを実装する

delete() メソッドを使用して、データ ストレージから行を削除する必要はありません。プロバイダで **同期アダプターを使用している場合は、行を完全に削除するのではなく、削除された行を 「 delete 」 フラグでマークすることを検討してください。** 同期アダプターは削除された行をチェックし、プロバイダから削除する前にサーバーから削除できます。


### update() メソッドを実装する

update() メソッドは、insert() で使用されるものと同じ [ContentValues](https://developer.android.com/reference/android/content/ContentValues?hl=ja&_gl=1*c973af*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..) 引数と、delete() と ContentProvider.query() で使用される同じ selection 引数と selectionArgs 引数を取ります。これにより、これらのメソッド間でコードを再利用できる場合があります。


### onCreate() メソッドを実装する

Android システムは、プロバイダの起動時に onCreate() を呼び出します。 **このメソッドで高速に実行される初期化タスクのみを実行し、プロバイダがデータのリクエストを実際に受け取るまで、データベースの作成とデータの読み込みを延期します。** onCreate() で長時間のタスクを実行すると、プロバイダの起動が遅くなります。その結果、プロバイダから他のアプリへのレスポンスが遅くなります。

次の 2 つのスニペットは、ContentProvider.onCreate() と Room.databaseBuilder() の間のやり取りを示しています。最初のスニペットは、データベース オブジェクトが構築され、データアクセス オブジェクトに対するハンドルが作成される ContentProvider.onCreate() の実装を示しています。

```kotlin
// データベース名を定義する
private const val DBNAME = "mydb"

class ExampleProvider : ContentProvider() {

    // Room データベースを扱うインスタンスを定義する
    private lateinit var appDatabase: AppDatabase

    // データベース操作を行うデータアクセスオブジェクトを定義する。
    private var userDao: UserDao? = null

    override fun onCreate(): Boolean {

        // 新しいデータベースオブジェクトを生成する
        appDatabase = Room.databaseBuilder(context, AppDatabase::class.java, DBNAME).build()

        // データベース操作を行うデータアクセスオブジェクトを取得する。
        userDao = appDatabase.userDao

        return true
    }

    // プロバイダーの insert 関数を実装する
    override fun insert(uri: Uri, values: ContentValues?): Uri? {
        // データ挿入時にどの DAO を使用するかを定義するコードをここに記述したり、エラー状態を処理したり、など...。
    }
}
```


## ContentProvider MIME タイプを実装する

ContentProvider クラスには、MIME タイプを返すための 2 つのメソッドがあります。

- [getType()](https://developer.android.com/reference/android/content/ContentProvider?hl=ja&_gl=1*toe7un*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#getType(android.net.Uri))
  - 任意のプロバイダに実装する必須メソッドの 1 つ。
- [getStreamTypes()](https://developer.android.com/reference/android/content/ContentProvider?hl=ja&_gl=1*toe7un*_up*MQ..*_ga*MTY3MzE5ODE3My4xNzIyMzUyNjI3*_ga_6HH9YJMN9M*MTcyMjM1MjYyNi4xLjAuMTcyMjM1MjYyNi4wLjAuMA..#getStreamTypes(android.net.Uri,%20java.lang.String))
  - プロバイダがファイルを提供する場合に実装が期待されるメソッド。


### テーブルの MIME タイプ

getType() メソッドは、クエリによって返されるデータの MIME タイプを返します。 MIME タイプは String 型のデータで返されます。 Uri 引数には、特定の URI ではなくパターンを指定できます。この場合、パターンに一致するコンテンツ URI に関連付けられているデータタイプを返します。

テキスト、HTML、JPEG などの一般的なタイプのデータの場合、 getType() は、一般的な既定の MIME タイプを返します。一般的な定義済みの MIME タイプの完全なリストは、 [IANA MIME メディアタイプ](http://www.iana.org/assignments/media-types/index.htm) のウェブサイトで確認できます。 (例えば、 「 text/html 」 で検索してみると、表をどのように見れば良いのかわかると思います。)

テーブルデータの 1 行、または、複数行を参照するコンテンツ URI の場合、 getType() は Android 固有の形式の MIME タイプを返します。 Android 固有の MIME タイプは、以下のフォーマットになります。

```
<Type>.<SubType>/<Provider-Spescific>
```

- タイプ部分: `vnd`
- サブタイプの部分:
  - URI パターンが 1 行の場合: `android.cursor.item/`
  - URI パターンが複数の行の場合: `android.cursor.dir/`
- プロバイダ固有の部分: `vnd.<name>.<type>`

開発者が自由に設定できるのは、プロバイダ固有部分の `<name>` と `<type>` です。 `<name>` 値はグローバルに一意であり、 `<type>` 値は対応する URI パターンに対して一意です。 `<name>` には、会社名またはアプリの Android パッケージ名の一部を使用することをおすすめします。 `<type>` には、URI に関連付けられたテーブルを識別する文字列を使用することをおすすめします。

たとえば、プロバイダのオーソリティが com.example.app.provider で、table1 という名前のテーブルを公開する場合、table1 の複数の行の MIME タイプは次のようになります。

```
vnd.android.cursor.dir/vnd.com.example.provider.table1
```

table1 の 1 行の場合、MIME タイプは次のようになります。

```
// 上記では、 dir だった部分が item に変更されています。
vnd.android.cursor.item/vnd.com.example.provider.table1
```


### ファイルの MIME タイプ

プロバイダがファイルを提供している場合は、getStreamTypes() を実装します。このメソッドは、プロバイダが特定のコンテンツ URI に対して返すことができるファイルの MIME タイプの String 配列を返します。MIME タイプのフィルタ引数で提供する MIME タイプをフィルタし、クライアントが処理する必要のある MIME タイプのみを返すようにします。

たとえば、写真画像を JPG、PNG、GIF 形式のファイルとして提供するプロバイダについて考えてみましょう。アプリがフィルタ文字列 `image/*` を指定して ContentResolver.getStreamTypes() を呼び出した場合、それが 「画像」 の場合、 ContentProvider.getStreamTypes() メソッドは配列を返します。

```
{ "image/jpeg", "image/png", "image/gif"}
```

アプリが JPG ファイルのみを必要とする場合、 ContentResolver.getStreamTypes() を呼び出す際に、第二引数にフィルタ文字列 `image/jpeg` を指定して、 getStreamTypes() が次を返します。

```
{"image/jpeg"}
```

プロバイダがフィルタ文字列でリクエストされた MIME タイプを提供していない場合、getStreamTypes() は null を返します。

以下は実際の使用例です。

```java
public class Example {
    private static final String TAG = "Example";

    public static void checkStreamTypes(Context context, Uri uri) {
        // ContentResolver インスタンスを取得
        ContentResolver contentResolver = context.getContentResolver();

        // URI で利用可能なストリームタイプを取得
        String[] streamTypes = contentResolver.getStreamTypes(uri, "*/*");

        if (streamTypes != null) {
            for (String streamType : streamTypes) {
                Log.d(TAG, "Available Stream Type: " + streamType);
            }
        } else {
            Log.d(TAG, "No stream types available for this URI.");
        }
    }
}
```


## コントラクトクラスを実装する

コントラクトクラスは、 URI 、列名、 MIME タイプ、プロバイダに関連するその他のメタデータの定数定義を含む public final クラスです。このクラスは、 URI や列名などの実際の値が変更された場合でも、プロバイダに正しくアクセスできるようにすることで、プロバイダと他のアプリ間のコントラクトを確立します。

コントラクトクラスは通常、定数にわかりやすい名前 (ニーモニック名) を付けられるため、デベロッパーが列名や URI に誤った値を使用する可能性が低くなるため、デベロッパーにも役立ちます。クラスであるため、 Javadoc ドキュメントを含めることができます。 Android Studio などの統合開発環境では、コントラクトクラスから定数名を予測入力し、定数の Javadoc を表示できます。

デベロッパーは、アプリケーションから、コントラクトクラスのクラスファイルにアクセスすることはできませんが、指定した JAR ファイルを使用してアプリケーションに静的にコンパイルできます。

[ContactsContract](https://developer.android.com/reference/android/provider/ContactsContract?hl=ja&_gl=1*ajzoxv*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..) クラスとそのネストされたクラスは、コントラクトクラスの例です。


## コンテンツプロバイダの権限を実装する

Android システムのあらゆる側面における権限とアクセスについては、 [セキュリティに関するヒント](https://developer.android.com/guide/topics/security/security) に詳しく記載されています。 [データとファイルストレージの概要](../2.ストレージについて.md) でも、さまざまな種類のストレージで有効になっているセキュリティと権限について説明しています。簡単に言うと、重要なポイントは次のとおりです。

- デフォルトでは、デバイスの内部ストレージに保存されたデータファイルへのアクセスは、そのアプリとプロバイダに限定されます。
- 作成した SQLiteDatabase データベースは、作成したアプリケーションとプロバイダだけが使用できます。
- デフォルトでは、外部ストレージに保存するデータファイルは「一般公開」され、誰でも読み取り可能になります。他のアプリが他の API 呼び出しを使用してファイルを読み書きできるため、コンテンツプロバイダを使用して外部ストレージ内のファイルへのアクセスを制限することはできません。
- デバイスの内部ストレージでファイルや SQLite データベースを開いたり、作成したりするメソッド呼び出しを行うと、他のすべてのアプリに読み取りと書き込みの両方のアクセス権が付与される可能性があります。プロバイダのリポジトリとして内部ファイル、または、データベースを使用していて、「誰でも読み取り可能」または「書き込み可能」のアクセス権を付与しても、マニフェストでプロバイダに設定した権限ではデータは保護されません。内部ストレージ内のファイルとデータベースに対するデフォルトのアクセスは「限定公開」です。プロバイダのリポジトリでは変更しないでください。

コンテンツプロバイダの権限を使用してデータへのアクセスを制御する場合は、内部ファイル、 SQLite データベース、または、クラウド（リモートサーバーなど）にデータを保存し、ファイルやデータベースをアプリ以外に公開しないようにします。


### 権限はなぜ必要か

そもそも、権限はなぜ必要なのでしょうか？自分で作成したコンテンツプロバイダにセンシティブなデータが登録されるとします。その場合、第三者が作成したアプリから自由にアクセスできてしまっては情報漏洩の事故につながる可能性があります。コンテンツプロバイダへのアクセスを信頼できるアプリからのみに制限することによって、ユーザーは安心してアプリにセンシティブなデータを登録することができるようになります。


### 権限を実装する

デフォルトでは、プロバイダに権限が設定されていないため、基盤となるデータが非公開であっても、すべてのアプリは、プロバイダを通して、無制限に読み書きを行うことができます。これを変更するには、 `<provider>` 要素の属性、または、子要素を使用して、マニフェストファイルでプロバイダの権限を設定します。プロバイダ全体、特定のテーブル、特定のレコード、または、 3 つすべてに適用される権限を設定できます。

プロバイダの権限を定義するには、マニフェストファイルの 1 つ以上の `<permission>` 要素を使用します。権限をプロバイダに固有のものにするには、 android:name 属性に Java スタイルのスコープを使用します。たとえば、読み取り権限に com.example.app.provider.permission.READ_PROVIDER という名前を付けます。

次のリストは、プロバイダの権限の範囲を示しています。プロバイダ全体に適用される権限から始まり、よりきめ細かい権限になっています。スコープの広い権限よりも、きめ細かい権限が優先されます。


#### プロバイダレベルの「読み取り + 書き込み」権限を設定する

プロバイダ全体に対する読み取りと書き込みの両方を制御する 1 つの権限。 [`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element) 要素の [android:permission](https://developer.android.com/guide/topics/manifest/provider-element#prmsn) 属性で指定します。

`android:permission` 属性には、パーミッションの文字列が設定されます。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.app">

    <!-- 独自パーミッションの定義 -->
    <permission android:name="com.example.app.MY_PERMISSION"
        android:protectionLevel="dangerous"/>

    <application>
        <provider
            android:name=".MyContentProvider"
            android:authorities="com.example.app.provider"
            android:permission="com.example.app.MY_PERMISSION"
            android:exported="true"/>
    </application>
</manifest>
```

上記のコンテンツプロバイダ ( MyContentProvider ) は、 `"com.example.app.MY_PERMISSION"` パーミッションを持ったアプリのみが、読み書きを行うことができます。


#### プロバイダレベルの「読み取り」権限と「書き込み」権限を個別に設定する

プロバイダ全体に対する読み取り権限と書き込み権限。これは、 [`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element) 要素の [android:readPermission](https://developer.android.com/guide/topics/manifest/provider-element#rprmsn) 属性と [android:writePermission](https://developer.android.com/guide/topics/manifest/provider-element#wprmsn) 属性で指定します。これらの権限は、 [android:permission](https://developer.android.com/guide/topics/manifest/provider-element#prmsn) で必要な権限よりも優先されます。


#### パスレベルの権限

プロバイダのコンテンツ URI に対する「読み取り」、「書き込み」、「読み取り + 書き込み」権限。制御する URI は、 [`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element) 要素の [`<path-permission>`](https://developer.android.com/guide/topics/manifest/path-permission-element) 子要素で指定します。指定するコンテンツ URI ごとに、「読み取り + 書き込み権限」、「読み取り権限」、「書き込み権限」、または、この 3 つすべてを指定できます。読み取り + 書き込み権限は、個別の読み取り権限、書き込み権限よりも優先されます。また、パスレベルの権限はプロバイダレベルの権限よりも優先されます。


#### 一時的な権限

アプリに通常必要な権限がない場合でも、アプリに一時的なアクセス権を付与する権限レベル。 **一時アクセス機能を使用すると、アプリがマニフェストでリクエストする必要がある権限の数が減ります。** 一時的な権限をオンにすると、プロバイダの永続的な権限を必要とするアプリが、すべてのデータに継続的にアクセスします。たとえば、メールアプリを開発しているとします。他のアプリは、メールアプリのプロバイダを通じて、メールの添付ファイルにアクセスできます。画像ビューアアプリで、メールの添付ファイルを表示する場合に必要な権限について考えてみましょう。権限を要求せずに画像ビューアに必要なアクセス権を付与するには、写真のコンテンツ URI に一時的な権限を設定します。

ユーザーが写真を表示しようとしたときに、写真のコンテンツ URI と権限フラグを含むインテントを画像ビューアに送信するように、メールアプリを設計します。この場合、画像ビューアは、プロバイダに対する通常の読み取り権限を持っていなくても、メールプロバイダにクエリを実行して写真を取得できます。

一時的な権限を有効にするには、 [`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element) 要素の [android:grantUriPermissions](https://developer.android.com/guide/topics/manifest/provider-element#gprmsn) 属性を設定するか、1 つ以上の [`<grant-uri-permission>`](https://developer.android.com/guide/topics/manifest/grant-uri-permission-element) 子要素を `<provider>` 要素に追加します。一時的な権限に関連付けられたコンテンツ URI のサポートをプロバイダから削除する際は、必ず [Context.revokeUriPermission()](https://developer.android.com/reference/android/content/Context#revokeUriPermission(android.net.Uri,%20int)) を呼び出します。

`android:grantUriPermissions` 属性の値により、プロバイダのどの程度をアクセス可能にするかが決まります。この属性を "true" に設定した場合、システムはプロバイダ全体に、一時的な読み書きの権限を付与します。この権限は、プロバイダレベル、または、パスレベルの権限よりも優先されます。

プロバイダ全体へのアクセス権を付与するのではなく、特定のコンテンツ (特定のパス、特定の接頭辞、正規表現を使用したパスパターン) にのみ、アクセス権を付与することも可能です。その場合は、 `android:grantUriPermissions` を "false" に設定し、 `<provider>` 要素の子要素として、 `<grant-uri-permission>` 要素を追加します。各 `<grant-uri-permission>` 要素には、一時的なアクセスを許可したいコンテンツ URI を指定します。

`<grant-uri-permission>` 要素の `android:pathPattern` には、ある程度の正規表現が使用できます。例えば、以下のように指定できます。

| 指定方法                                | 許可されるパスの例                     |
| --------------------------------------- | -------------------------------------- |
| `android:pathPattern=".*\\.jpg"`        | `file.jpg`, `photo.jpg`                |
| `android:pathPattern="/data/.*"`        | `/data/image.png`, `/data/test.txt`    |
| `android:pathPattern=".*/[0-9]+\\.png"` | `/images/1234.png`, `/photos/5678.png` |

一時的なアクセス権をアプリに委任するには、 Intent に [FLAG_GRANT_READ_URI_PERMISSION](https://developer.android.com/reference/android/content/Intent#FLAG_GRANT_READ_URI_PERMISSION) フラグ、 [FLAG_GRANT_WRITE_URI_PERMISSION](https://developer.android.com/reference/android/content/Intent#FLAG_GRANT_WRITE_URI_PERMISSION) フラグ、または、その両方を含める必要があります。これらは [setFlags()](https://developer.android.com/reference/android/content/Intent#setFlags(int)) メソッドで設定します。詳しくは、 [ファイルの共有](../10.ファイルの共有/) の各ドキュメントを参照してください。

android:grantUriPermissions 属性が存在しない場合は、 "false" であるとみなされます。


## \<provider\> 要素

ContentProvider のサブクラスは、Activity コンポーネントや Service コンポーネントと同様に、アプリケーションのマニフェストファイルで [\<provider\>](https://developer.android.com/guide/topics/manifest/provider-element?hl=ja&_gl=1*ophlp*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..) 要素を使用して定義されます。 Android システムは要素から次の情報を取得します。

### オーソリティ ( [android:authorities](https://developer.android.com/guide/topics/manifest/provider-element?hl=ja&_gl=1*dhrq3r*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..#auth) ) 

プロバイダを識別する名前です。この属性について詳しくは、 [コンテンツ URI を設計する](#コンテンツ-uri-を設計する) のセクションをご覧ください。


### プロバイダのクラス名 ( [android:name](https://developer.android.com/guide/topics/manifest/provider-element?hl=ja&_gl=1*dhrq3r*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..#nm) )

ContentProvider を実装するクラス。このクラスについて詳しくは、 [ContentProvider クラスを実装する](#contentprovider-クラスを実装する) のセクションをご覧ください。


### 権限

他のアプリがプロバイダのデータにアクセスするために必要な権限を指定する属性。

- android:grantUriPermissions: 一時的な権限フラグ
- android:permission: プロバイダ全体の読み取り + 書き込み権限
- android:readPermission: プロバイダ全体の読み取り権限
- android:writePermission: プロバイダ全体の書き込み権限

権限とそれに対応する属性について詳しくは、 [コンテンツプロバイダの権限を実装する](#コンテンツプロバイダの権限を実装する) のセクションをご覧ください。


### 起動と制御の属性

これらの属性により、Android システムがプロバイダを起動する方法とタイミング、プロバイダのプロセスの特性、その他の実行時の設定が決まります。

- [android:enabled](https://developer.android.com/guide/topics/manifest/provider-element#enabled)
  - システムにプロバイダの起動を許可するフラグ
- [android:exported](https://developer.android.com/guide/topics/manifest/provider-element#exported)
  - 他のアプリがこのプロバイダを使用することを許可するフラグ
- [android:initOrder](https://developer.android.com/guide/topics/manifest/provider-element#init)
  - このプロバイダが起動される順序（同じプロセス内の他のプロバイダとの比較）
- [android:multiProcess](https://developer.android.com/guide/topics/manifest/provider-element#multi)
  - システムが呼び出し元のクライアントと同じプロセスでプロバイダを開始することを許可するフラグ
- [android:process](https://developer.android.com/guide/topics/manifest/provider-element#proc)
  - プロバイダが実行されるプロセスの名前
- [android:syncable](https://developer.android.com/guide/topics/manifest/provider-element#sync)
  - プロバイダのデータをサーバー上のデータと同期させることを示すフラグ

これらの属性の詳細については、 [`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element?hl=ja&_gl=1*blkcze*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..) 要素のガイドに記載されています。


### 情報属性

プロバイダのアイコンとラベル（省略可）:

- [android:icon](https://developer.android.com/guide/topics/manifest/provider-element#icon)
  - プロバイダのアイコンを含むドローアブルリソース。このアイコンは、 [設定] > [アプリ] > [すべて] のアプリリストでプロバイダのラベルの横に表示されます。
- [android:label](https://developer.android.com/guide/topics/manifest/provider-element#label)
  - プロバイダとそのデータ、または、その両方を説明する情報ラベル。このラベルは、 [設定] > [アプリ] > [すべて] のアプリのリストに表示されます。

これらの属性の詳細については、 [\<provider\>](https://developer.android.com/guide/topics/manifest/provider-element?hl=ja&_gl=1*blkcze*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..) 要素のガイドに記載されています。

**注**: Android 11 以降をターゲットとしている場合は、 [パッケージの公開設定に関するドキュメント](https://developer.android.com/training/package-visibility/declaring?hl=ja&_gl=1*blkcze*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..#provider-authority) で詳細な構成要件をご確認ください。


## インテントとデータアクセス

アプリは、 Intent で間接的にコンテンツプロバイダにアクセスできます。アプリは、 ContentResolver 、または、 ContentProvider のメソッドを呼び出しません。代わりに、アクティビティ（通常はプロバイダ独自のアプリの一部）を開始するインテントを送信します。デスティネーションアクティビティは、 UI でのデータの取得と表示を担当します。

インテントのアクションに応じて、デスティネーションアクティビティは、プロバイダのデータを変更するようユーザーに促すこともできます。インテントには、デスティネーションアクティビティが UI に表示する「エクストラ」データが含まれる場合もあります。ユーザーは、このデータ (エクストラ) を使用して、プロバイダのデータを変更する前に、このデータ (エクストラ) を変更してから、プロバイダのデータを変更することができます。

**インテントアクセスを使用すると、データの整合性を確保できます。** つまり、 **他のアプリがデータを直接変更できるようにすると、データのバリデーションチェックが不足している場合に、無効なデータが発生する可能性があります。**

開発者にインテントアクセスを使用してもらいたい場合は、その内容を徹底的に文書化してください。コードを使ってデータを変更するよりも、別アプリの UI を使用したインテントアクセスの方が優れている理由を説明します。

プロバイダアプリが受信したインテントをを使用して、プロバイダのデータを変更する方法は、他のインテントの処理と同じです。インテントの使用方法について詳しくは、 [インテントとインテントフィルタ](https://developer.android.com/guide/components/intents-filters?hl=ja&_gl=1*ae37mf*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..) をご覧ください。

その他の関連情報については、 [カレンダープロバイダの概要](https://developer.android.com/guide/topics/providers/calendar-provider?hl=ja&_gl=1*co2nbw*_up*MQ..*_ga*MTE2NzQ4NjMzNC4xNzIyNTE5MzA5*_ga_6HH9YJMN9M*MTcyMjUxOTMwOC4xLjAuMTcyMjUxOTMwOC4wLjAuMA..) をご覧ください。




