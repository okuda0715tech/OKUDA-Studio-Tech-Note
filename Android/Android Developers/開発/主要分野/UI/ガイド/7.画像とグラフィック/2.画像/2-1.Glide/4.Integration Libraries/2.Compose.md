- [Compose](#compose)
  - [概要](#概要)
  - [ステータス](#ステータス)
  - [Compose 統合ライブラリを組み込むにはどうすればよいですか?](#compose-統合ライブラリを組み込むにはどうすればよいですか)
  - [使用方法](#使用方法)
    - [GlideImage](#glideimage)
      - [Placeholders](#placeholders)
      - [Sizing（サイズ指定）](#sizingサイズ指定)
      - [Transitions（ロードが完了した際のクロスフェードアニメーション）](#transitionsロードが完了した際のクロスフェードアニメーション)
      - [Glide の状態変換に基づいて再コンポーズを行う](#glide-の状態変換に基づいて再コンポーズを行う)
      - [GlideLazyListPreloader](#glidelazylistpreloader)
      - [キャッシュをスキップする](#キャッシュをスキップする)


# Compose

## 概要

Jetpack Compose は、ネイティブ UI を構築するための Android の最新ツールキットです。このライブラリは Compose と統合されており、Glide を使用して Compose アプリに画像を効率的に読み込むことができます。


## ステータス

Glide の Compose 統合はベータ版です。バグが発生した場合は、 [Glide の Github Issues](https://github.com/bumptech/glide/issues/new) にバグや機能リクエストを送信してください。 API は最終版に近づいています。

サブコンポジションをプレースホルダーとして使用する機能は削除されます。 `GlideSubcomposition` をカスタム Modifier に置き換える可能性があります。その場合は、移行する時間を確保するために、まず `GlideSubcomposition` を廃止します。


## Compose 統合ライブラリを組み込むにはどうすればよいですか?

Compose 統合にはコンポーネントが含まれていないため、使用するために AppGlideModule を変更する必要はありません。

代わりに、Compose 統合ライブラリに Gradle 依存関係を追加するだけです:

```
implementation "com.github.bumptech.glide:compose:1.0.0-beta01"
```


## 使用方法

Compose と Glide の Compose 統合を使用する小さなアプリケーションについては、Glide の [Gallery サンプル アプリ](https://github.com/bumptech/glide/tree/master/samples/gallery) を参照してください。詳細な API ドキュメントについては、 [Dokka ページ](https://bumptech.github.io/glide/javadocs/4140/integration/compose/com.bumptech.glide.integration.compose/index.html) を参照してください。


### GlideImage

Compose と Glide の主な統合ポイントは `GlideImage` です。GlideImage は、Glide を使用して画像を非同期に読み込む点を除けば、Compose の Image 関数に似ています。

GlideImage のシンプルな使用方法は以下の通りです。モデルとコンテンツの説明のみを含めることができます。

```kotlin
GlideImage(model = myUrl, contentDescription = getString(R.id.picture_of_cat))
```

GlideImage のレンダリング方法をカスタマイズするために、カスタム Modifier を指定できます。

```kotlin
GlideImage(
    model = myUrl,
    contentDescription = getString(R.id.picture_of_cat),
    modifier = Modifier.padding(padding).clickable(onClick = onClick).fillParentMaxSize(),
)
```

また、Compose の Image と同じパラメータと同じデフォルト値を持ち、同じように機能する alignment , contentScale , colorFilter , alpha パラメータも指定可能です。

Glide のロードを構成するには、 GlideImage 関数の最後の引数に `RequestBuilderTransformation` 関数を渡します。この関数には、指定されたモデルで `load()` がすでに呼び出されている `RequestBuilder` が渡されます。その後、Transitions を除く通常の Glide オプションを使用してリクエストをカスタマイズできます (詳細については以下を参照)。

```kotlin
GlideImage(
    model = myUrl,
    contentDescription = getString(R.id.picture_of_cat),
    modifier = Modifier.padding(padding).clickable(onClick = onClick).fillParentMaxSize(),
) {
    it
        .thumbnail(
            requestManager
            .asDrawable()
            .load(item.uri)
            .signature(signature)
            .override(THUMBNAIL_DIMENSION)
        )
        .signature(signature)
}
```


#### Placeholders

Glide には、プレースホルダー機能があります。ここでのプレースホルダとは、画像がロードされるまでの間や、画像のロードに失敗した場合に、デフォルト画像を表示する機能のことを示します。

プレースホルダ機能で表示するデフォルト画像は、 3 つの形式のリソースに対応しています。

1. Drawables
2. Android リソース ID
3. Painters

プレースホルダーを指定するには、 GlideImage の `loading` パラメータと `failure` パラメータを使用します。プレースホルダーは、Glide の Placeholder クラスのいずれかである必要があります:

```kotlin
import com.bumptech.glide.integration.compose.GlideImage
import com.bumptech.glide.integration.compose.placeholder

// Drawable リソースを使用する場合
GlideImage(model = myUrl, loading = placeholder(myDrawable))

// Resource ID を使用する場合
GlideImage(model = myUrl, failure = placeholder(R.drawable.my_drawable))

// Painter リソースを使用する場合
GlideImage(model = myUrl, loading = placeholder(ColorPainter(Color.Red)))
```

GlideImage に直接プレースホルダーを設定し、 requestBuilderTransform 経由で RequestBuilder にプレースホルダーを設定すると、GlideImage に直接設定されたプレースホルダーが優先されます。


#### Sizing（サイズ指定）

Glide の View 統合と同様に、 Glide の Compose 統合は Composable のサイズを決定し、それを使用して適切なサイズの画像をロードしようとします。これは、 Composable のサイズを制限する Modifier を提供する場合にのみ効率的に実行できます。 Glide が Composable の幅または高さが無制限であると判断した場合、 `Target.SIZE_ORIGINAL` が使用され、メモリの過剰使用につながる可能性があります。

可能な限り、制限されたサイズの Modifier を設定するか、Glide リクエストに [override(size: Int)](https://bumptech.github.io/glide/javadocs/430/com/bumptech/glide/request/RequestOptions.html#override-int-int-) 関数でサイズを指定するようにしてください。メモリを節約できるだけでなく、サイズが小さいほどディスク キャッシュからのロードも高速になります。


#### Transitions（ロードが完了した際のクロスフェードアニメーション）

バージョン alpha5 以降の GlideImage は、Compose 固有の Transition API をサポートしています。遷移は、Compose API を使用して GlideImage で指定する必要があります。 RequestBuilder で指定されたトランジションは無視されます。

ロードが完了したときに、設定したプレースホルダー (ある場合) から画像にクロスフェードするには、組み込みの `CrossFade` トランジションを使用します。

```kotlin
import com.bumptech.glide.integration.compose.CrossFade

GlideImage(uri, contentDescription, transition = CrossFade)
```

独自のカスタム トランジションを作成することもできます。その場合は、問題を報告してお知らせください。これを簡単にするためにできることは他にもたくさんあります。

現時点では、既存の CrossFade を見て、同様のパターンに従うのが最善策です: https://github.com/bumptech/glide/blob/2ae4effcf7bad2131a54423d203c2d124257fc04/integration/compose/src/main/java/com/bumptech/glide/integration/compose/Transition.kt#L99


#### Glide の状態変換に基づいて再コンポーズを行う

まれに、 Glide の読み込みの状態に基づいて構成を変更したい場合があります。スクロール リストでこれを行うことは、ほとんど望ましくありません。これを行うと、画像の読み込みごとに複数の再構成が発生し、かなりのジャンクが発生します。原則として、この API の使用を回避できる場合は、使用しないでください。

ただし、状態の変化に応じて再コンポーズする必要がある場合は、GlideSubcomposition を使用できます。

```kotlin
import com.bumptech.glide.integration.compose.GlideSubcomposition

GlideSubcomposition(item.uri, modifier, requestBuilderTransform = {
    it.thumbnail(preloadRequestBuilder)
}) {
    // state comes from GlideSubcompositionScope
    when (state) {
        RequestState.Failure -> TODO()
        RequestState.Loading -> TODO()
        // painter also comes from GlideSubcompositionScope
        is RequestState.Success -> Image(painter, contentDescription = null)
    }
}
```

この API が必須となるユースケースがある場合は、 [問題を報告する](https://github.com/bumptech/glide/issues/new) から、お知らせください。ここでのもう 1 つの可能性の高いオプションは、Modifier ベースの API を公開することです。この API では、Glide でカスタム Modifier を作成し、そのカスタム Modifier を介して Glide の状態変更を監視できます。これはまだ実装されていません。


#### GlideLazyListPreloader

GlideLazyListPreloader は、Compose の LazyListState を使用して、ユーザーがスクロールしている方向を判別し、スクロール方向に画像をプリロードします。プリロードは、特に比較的小さい画像サイズで [Glide のサムネイル API](https://bumptech.github.io/glide/doc/options.html#thumbnail-requests) と組み合わせて使用​​すると、水平方向または垂直方向にスクロールする UI の UX を大幅に向上させることができます。

プリローダーの使用法は次のようになります。

```kotlin
@Composable
fun DeviceMedia(mediaStoreData: List<MediaStoreData>) {
    val state = rememberLazyListState()
    LazyRow(state = state) {
        items(mediaStoreData) { mediaStoreItem ->
            // Uses GlideImage to display a MediaStoreData object
            MediaStoreView(mediaStoreItem, requestManager, Modifier.fillParentMaxSize())
        }
    }

    GlideLazyListPreloader(
        state = state,
        data = mediaStoreData,
        size = THUMBNAIL_SIZE,
        numberOfItemsToPreload = 15,
        fixedVisibleItemCount = 2,
    ) { item, requestBuilder ->
        requestBuilder
            .load(item.uri)
            .signature(item.signature())
    }
}

@Composable
fun MediaStoreView(item: MediaStoreData, requestManager: RequestManager, modifier: Modifier) {
    val signature = item.signature()

    GlideImage(
        model = item.uri,
        contentDescription = item.displayName,
        modifier = modifier,
    ) {
        it
            // This thumbnail request exactly matches the request in GlideLazyListPreloader
            // so that the preloaded image can be used here and display more quickly than
            // the primary request.
            .thumbnail(
                requestManager
                    .asDrawable()
                    .load(item.uri)
                    .signature(signature)
                    .override(THUMBNAIL_DIMENSION)
            )
            .signature(signature)
    }
}
```

state は、標準の Compose API を使用して取得できる LazyListState です。data は、表示するモデル オブジェクトのリストです。size は、プリロードする画像のサイズです。これは、GlideImage がアイテムを表示するために使用するリクエストまたはサムネイル リクエストに提供されるサイズと少なくとも 1 つ正確に一致する必要があります。numberOfItemsToPreload は、ユーザーがスクロールするときに、ユーザーの位置より先にメモリ内に保持しようとするアイテムの合計数です。適切なバランスを見つけるには、パフォーマンス テストが必要になる場合があります。数が多すぎると、メモリ キャッシュ サイズを超える可能性があります。数が少なすぎると、スクロールに追いつくことができません。fixedVisibleItemCount は、通常、一度に画面に表示されるアイテムの数を推測したものです。

最後に、PreloadRequestBuilderTransform を提供できます。これにより、一度に 1 つのオブジェクトがデータ リストから提供され、Glide リクエストが作成されます。size は、Glide のオーバーライド API によって自動的に適用されます。したがって、リクエストを対応する GlideImage のロード (または少なくとも 1 つのサムネイル ロード) と正確に一致させるために必要なロードの追加コンポーネントのみを指定する必要があります。

Glide の Compose API の多くと同様に、このクラスにも API の変更がいくつかある可能性があります。特に、リクエストの指定プロセスを簡素化して、リクエスト オプションが GlideLazyListPreloader と GlideImage で重複しないようにしたいと考えています。


#### キャッシュをスキップする

```kotlin
GlideImage(
    model = userIconUrl,
    contentDescription = "user icon",
) {
    it.skipMemoryCache(true) // メモリキャッシュをスキップ
        .diskCacheStrategy(DiskCacheStrategy.NONE) // ディスクキャッシュを無効化
}
```




