- [Compose の ConstraintLayout](#compose-の-constraintlayout)
  - [Compose における ConstraintLayout の使い時](#compose-における-constraintlayout-の使い時)
  - [ConstraintLayout をはじめよう](#constraintlayout-をはじめよう)
    - [依存関係の追加](#依存関係の追加)
    - [使用方法](#使用方法)
  - [制約をインラインではなく、分離して設定する](#制約をインラインではなく分離して設定する)
  - [ConstraintLayout のコンセプト](#constraintlayout-のコンセプト)
    - [ガイドライン](#ガイドライン)
    - [バリア](#バリア)
    - [チェーン](#チェーン)


# Compose の ConstraintLayout

ConstraintLayout は画面上の他のコンポーザブルを基準にコンポーザブルを配置できるレイアウトです。複数のネストされた Row、Column、Box 要素や他のカスタムのレイアウト要素を使用する代わりの手段です。ConstraintLayout は、配置要件がより複雑な、大規模なレイアウトを実装する場合に便利です。


## Compose における ConstraintLayout の使い時

View システムでは、大規模で複雑なレイアウトを作成する場合、ConstraintLayout を使用することが推奨されていました。これは、 **ネストされたビューよりもフラットなビュー階層の方がパフォーマンスに優れているため** です。 **しかし、深いレイアウト階層を効率的に扱える Compose では、このような懸念はありません。** つまり、 Jetpack Compose では、 ConstraintLayout を必ずしも使用する必要はありませんが、場合によっては使用すると便利な場合があります。

以下のシナリオでは ConstraintLayout の使用を検討することも可能です。

- 画面上の要素を配置するために複数の Column、Row をネストすることを回避し、コードを読みやすくする。
- 他のコンポーザブルを基準にコンポーザブルを配置する
- ガイドライン、バリア、チェーンに基づいてコンポーザブルを配置する。


## ConstraintLayout をはじめよう

### 依存関係の追加

Compose で ConstraintLayout を使用するには、 Compose の依存関係に加えて build.gradle に次の依存関係を追加する必要があります。

```
implementation "androidx.constraintlayout:constraintlayout-compose:1.0.1"
```

注: constraintLayout-compose アーティファクトのバージョニングは、 Jetpack Compose [ConstraintLayout のリリースページ](https://developer.android.com/jetpack/androidx/releases/constraintlayout?hl=ja&_gl=1*brkgf8*_up*MQ..*_ga*NTY3MDY5MDA1LjE3MjQ2NTg1MjY.*_ga_6HH9YJMN9M*MTcyNDkzODE5MS4zLjAuMTcyNDkzODE5MS4wLjAuMA..) をご覧ください。


### 使用方法

ConstraintLayout を使用したコンポーザブルの例を次に示します。

```kotlin
@Composable
fun ConstraintLayoutContent() {
    ConstraintLayout {
        // 分解宣言で各プロパティに各コンポーザブルへの参照を割り当てる。
        val (button, text) = createRefs()

        Button(
            onClick = { /* Do something */ },
            // Assign reference "button" to the Button composable
            // and constrain it to the top of the ConstraintLayout
            modifier = Modifier.constrainAs(button) {
                top.linkTo(parent.top, margin = 16.dp)
            }
        ) {
            Text("Button")
        }

        // Assign reference "text" to the Text composable
        // and constrain it to the bottom of the Button composable
        Text(
            "Text",
            Modifier.constrainAs(text) {
                top.linkTo(button.bottom, margin = 16.dp)
            }
        )
    }
}
```

上記のコードを実行すると以下の画面表示になります。

<img src="./画像/ConstraintLayout の簡単な例.png" width="200">

このコードは、 Button の頂部を親に対しマージン 16.dp に制約し、Text も Button の底部に対しマージン 16.dp に制約します。

上記のコードについて解説していきます。

コンパイラは次の手順でコードを解析します。

1. ConstraintLayout コンポーザブルは、その子要素をスキャンし、 `Modifier.constrainAs(name)` 修飾子を探します。
2. 該当の修飾子を見つけたら、その name とコンポーザブルのインスタンスをマッピングします。
3. `createRefs()` 関数で生成した ConstrainedLayoutReferences には、 constrainAs 関数でマッピングされたコンポーザブルへの参照を持っているため、これらを分解宣言で各プロパティに割り当てます。
4. 各コンポーザブルの Modifier.constrainAs 関数のラムダブロックで制約を設定します。

[createRefs() 関数の公式ドキュメントはこちら](https://developer.android.com/reference/kotlin/androidx/constraintlayout/compose/ConstraintLayoutScope?hl=ja&_gl=1*ctdgnf*_up*MQ..*_ga*NTY3MDY5MDA1LjE3MjQ2NTg1MjY.*_ga_6HH9YJMN9M*MTcyNDkzODE5MS4zLjAuMTcyNDkzODE5MS4wLjAuMA..#createrefs)


## 制約をインラインではなく、分離して設定する

ConstraintLayout の例では、制約はインラインで指定され、適用対象のコンポーザブルで修飾子が付けられていました。しかし、適用対象のレイアウトから **制約を分離した方がよい場合もあります。** たとえば、次の場合です。

- **画面回転に基づいて制約を変更する場合**
- **2 つの制約セットの間でアニメーション化を行う場合**

このような場合は、別の方法で ConstraintLayout を使用できます。

1. ConstraintSet を、 ConstraintLayout のパラメータとして渡します。
2. ConstraintSet で作成した参照を、 layoutId 修飾子を使用してコンポーザブルに割り当てます。

```kotlin
@Composable
fun DecoupledConstraintLayout() {
    BoxWithConstraints {
        val constraints = if (minWidth < 600.dp) {
            // 画面の向きが縦方向の場合
            decoupledConstraints(margin = 16.dp)
        } else {
            // 画面の向きが横方向の場合
            decoupledConstraints(margin = 32.dp)
        }

        // ConstraintSet を引数で渡す。
        ConstraintLayout(constraints) {
            Button(
                onClick = { /* Do something */ },
                // このコンポーザブルに対して、レイアウト ID を付与します。
                modifier = Modifier.layoutId("button")
            ) {
                Text("Button")
            }

            Text("Text", Modifier.layoutId("text"))
        }
    }
}

private fun decoupledConstraints(margin: Dp): ConstraintSet {
    return ConstraintSet {
        // レイアウト ID をキーにして、コンポーザブルのインスタンスを取得します。
        val button = createRefFor("button")
        val text = createRefFor("text")

        // 引数で制約を付与したいコンポーザブルを渡します。
        constrain(button) {
            // 制約を設定します。
            // レシーバーの top は、 button の Top を示します。
            top.linkTo(parent.top, margin = margin)
        }
        constrain(text) {
            top.linkTo(button.bottom, margin)
        }
    }
}
```

<img src="./画像/ConstraintLayout の例2.png" width="600">

[createRefFor() 関数の公式ドキュメントはこちら](https://developer.android.com/reference/kotlin/androidx/constraintlayout/compose/ConstraintSetScope?hl=ja&_gl=1*ctdgnf*_up*MQ..*_ga*NTY3MDY5MDA1LjE3MjQ2NTg1MjY.*_ga_6HH9YJMN9M*MTcyNDkzODE5MS4zLjAuMTcyNDkzODE5MS4wLjAuMA..#createreffor)


## ConstraintLayout のコンセプト

ConstraintLayout には、コンポーザブル内での要素の配置に役立つ、ガイドライン、バリア、チェーンなどのコンセプトがあります。


### ガイドライン

ガイドラインは、レイアウトの設計に使用する小さいビジュアル ヘルパーです。コンポーザブルは、ガイドラインに制約することができます。ガイドラインは、親コンポーザブル内に特定の dp や percentage で要素を配置する場合に便利です。

ガイドラインには、垂直方向と水平方向の 2 つの種類があります。水平方向は top と bottom、垂直方向は start と end です。

```kotlin
ConstraintLayout {
    // 親コンポーザブルの Start から、親の幅の 10 % の地点にガイドラインを生成
    val startGuideline = createGuidelineFromStart(0.1f)
    // 親コンポーザブルの End から、親の幅の 10 % の地点にガイドラインを生成
    val endGuideline = createGuidelineFromEnd(0.1f)
    //  Create guideline from 16 dp from the top of the parent
    // 親コンポーザブルの Top から、 16 dp の地点にガイドラインを生成
    val topGuideline = createGuidelineFromTop(16.dp)
    // 親コンポーザブルの Bottom から、 16 dp の地点にガイドラインを生成
    val bottomGuideline = createGuidelineFromBottom(16.dp)
}
```

ガイドラインを作成するには、必要なガイドラインの種類で createGuidelineFrom* を使用します。これにより、Modifier.constrainAs() ブロックで使用できる参照が作成されます。

**注: Rows と Columns で同様の効果を実現するには、Spacer の使用をご検討ください。**


### バリア

バリアは、複数のコンポーザブルを参照し、指定された側の最も遠いウィジェットに基づく仮想ガイドラインを作成します。

バリアを作成するには、createTopBarrier() , createBottomBarrier() , createEndBarrier() , createStartBarrier() のいずれかを使用します。

```kotlin

```

作成したバリアは、Modifier.constrainAs() ブロックで使用できます。

**注: Rows と Columns で同様の効果を実現するには、 Intrinsic な測定値の使用をご検討ください。**


### チェーン

チェーンは、1 つの軸（水平または垂直）でグループのような動作を提供します。もう 1 つの軸は別個に制約できます。

チェーンを作成するには、createVerticalChain または createHorizontalChain を使用します。

```kotlin
ConstraintLayout {
    val constraintSet = ConstraintSet {
        val button = createRefFor("button")
        val text = createRefFor("text")

        val verticalChain = createVerticalChain(button, text, chainStyle = ChainStyle.Spread)
        val horizontalChain = createHorizontalChain(button, text)
    }
}
```

作成したチェーンは Modifier.constrainAs() ブロックで使用できます。

チェーンは、コンポーザブルの周囲のスペースを処理する方法を決める、以下のようなさまざまな ChainStyles で構成できます。

- ChainStyle.Spread: スペースは、最初のコンポーザブルの前と最後のコンポーザブルの後の空きスペースを含め、すべてのコンポーザブル間で均等に配分されます。
- ChainStyle.SpreadInside: スペースは、最初のコンポーザブルの前と最後のコンポーザブルの後に空きスペースを入れずに、すべてのコンポーザブル間で均等に配分されます。
- ChainStyle.Packed: スペースは最初のコンポーザブルの前と最後のコンポーザブルの後に配分され、コンポーザブルは、相互の間にスペースを入れずにまとめてパックされます。

注: Rows と Columns で、 ConstraintLayout のチェーンと同様の効果を実現するには、 [Arrangement の使用](./よく使用するコンポーザブル関数のパラメータ.md/#2-arrangement) をご検討ください。


