- [カスタム修飾子を作成する](#カスタム修飾子を作成する)
  - [既存の修飾子のパラメータを一部固定する](#既存の修飾子のパラメータを一部固定する)
  - [既存の修飾子を連結する](#既存の修飾子を連結する)
  - [既存の修飾子を使用せず独自の修飾子を作成する](#既存の修飾子を使用せず独自の修飾子を作成する)
    - [CompositionLocal と組み合わせる](#compositionlocal-と組み合わせる)
      - [注意点１： CompositionLocal の値は、 current プロパティを参照した時点のスコープで設定されている値を保持する](#注意点１-compositionlocal-の値は-current-プロパティを参照した時点のスコープで設定されている値を保持する)
      - [注意点２：戻り値を持つコンポーズ可能な関数で使用する場合のパフォーマンス低下](#注意点２戻り値を持つコンポーズ可能な関数で使用する場合のパフォーマンス低下)
      - [注意点３：コンポーザブルな関数内からしか呼び出せない](#注意点３コンポーザブルな関数内からしか呼び出せない)
  - [Modifier.Node を使用してカスタムの修飾子の動作を実装する](#modifiernode-を使用してカスタムの修飾子の動作を実装する)
    - [Modifier.Node クラスの実装](#modifiernode-クラスの実装)
    - [ModifierNodeElement クラスの実装](#modifiernodeelement-クラスの実装)
    - [修飾子ファクトリの定義](#修飾子ファクトリの定義)
  - [Modifier.Node を使用する一般的な状況](#modifiernode-を使用する一般的な状況)


# カスタム修飾子を作成する

Compose には、一般的な動作のための多くの修飾子が最初から用意されていますが、独自の修飾子を作成することもできます。

修飾子は複数の要素で構成されます。

- 修飾子ファクトリ
  - これは Modifier の拡張関数です。
  - Modifier に汎用的な API を提供し、 Modifier を簡単に連結できます。
  - 修飾子ファクトリは、 Modifier の要素を生成します。
- 修飾子要素
  - 修飾子要素の動作を実装します。

カスタム修飾子を実装する方法は、二種類あります。実装が簡単なのは、すでに定義されている他の修飾子ファクトリを組み合わせるカスタム修飾子ファクトリを実装することです。もう一つは、さらにカスタム動作が必要な場合に、 Modifier.Node API を使用して修飾子要素を実装する方法です。


## 既存の修飾子のパラメータを一部固定する

複数のパラメータを持つ修飾子の関数がある場合は、そのうちのいくつかの値を固定値にして、残りを可変にする修飾子を定義することが可能です。

```kotlin
// clip は常に true で、
// shape だけを変更できる修飾子を定義
fun Modifier.clip(shape: Shape) = graphicsLayer(shape = shape, clip = true)
```


## 既存の修飾子を連結する

既存の修飾子を連結して独自の修飾子を生成するには、以下のようにします。

```kotlin
fun Modifier.myBackground(color: Color) = padding(16.dp)
    .clip(RoundedCornerShape(8.dp))
    .background(color)

// 上記 (公式ドキュメントどおり) だとエラーになるので、
// 以下のいずれかのパターンで、エラーを消すことができます。
// このエラーは何のためにあるのか全く理解できず、
// Google がよく考えずに作ったもののような気がするので、
// あまり気にしなくてよいと思いまう。

// パターン１ (おすすめ)
fun Modifier.myBackground2(color: Color) = this.padding(16.dp)
    .clip(RoundedCornerShape(8.dp))
    .background(color)

// パターン２ (then を使用する方法１)
fun Modifier.myBackground3(color: Color) = padding(16.dp)
    .clip(RoundedCornerShape(8.dp))
    .background(color)
    .then(this)

// パターン３ (then を使用する方法２)
fun Modifier.myBackground(color: Color) = Modifier
    .padding(16.dp)
    .clip(RoundedCornerShape(8.dp))
    .background(color)
    .then(this)

// パターン４ (アノテーションでワーニングを消す)
@SuppressLint("ModifierFactoryUnreferencedReceiver")
fun Modifier.myBackground(color: Color) = padding(16.dp)
    .clip(RoundedCornerShape(8.dp))
    .background(color)
```


## 既存の修飾子を使用せず独自の修飾子を作成する

既存の修飾子を使用せず独自の修飾子を作成する方法は、修飾子ファクトリと呼ばれます。

次のスニペットは、有効または無効になっているときに透明度の変化をアニメーション化する修飾子を示しています。

```kotlin
@Composable
fun Modifier.fade(enable: Boolean): Modifier {
    val alpha by animateFloatAsState(if (enable) 0.5f else 1.0f)
    return this then Modifier.graphicsLayer { this.alpha = alpha }
}
```

修飾子ファクトリを使用して修飾子を作成すると、 [animateXxxAsState](https://developer.android.com/develop/ui/compose/animation/value-based?hl=ja&_gl=1*685l9f*_up*MQ..*_ga*NDcyNDYxNjY1LjE3MjAyMjI0Mjk.*_ga_6HH9YJMN9M*MTcyMDIyMjQyOS4xLjAuMTcyMDIyMjQyOS4wLjAuMA..#animate-as-state) やその他の [Compose の状態に基づくアニメーション API](https://developer.android.com/develop/ui/compose/animation/choose-api?hl=ja&_gl=1*685l9f*_up*MQ..*_ga*NDcyNDYxNjY1LjE3MjAyMjI0Mjk.*_ga_6HH9YJMN9M*MTcyMDIyMjQyOS4xLjAuMTcyMDIyMjQyOS4wLjAuMA..) など、上位レベルの Compose API を使用することもできます。


**＜警告＞**  
**カスタムの修飾子を作成する場合は、修飾子チェーンを中断しないでください。常に this を参照する必要があります。参照しないと、以前に追加した修飾子が削除されます。上記の例のように this then Modifier を使用することも、return this.graphicsLayer { this.alpha = alpha } を使用することもできます。**


### CompositionLocal と組み合わせる

CompositionLocal と組み合わせることで、より柔軟なアプリが作成できます。 CompositionLocal については、 [こちら](../2.UIアーキテクチャ/7.CompositionLocal.md) を参照してください。

```kotlin
@Composable
fun Modifier.fadedBackground(): Modifier {
    val color = LocalContentColor.current
    return this then Modifier.background(color.copy(alpha = 0.5f))
}
```

この方法には、注意点があります。

#### 注意点１： CompositionLocal の値は、 current プロパティを参照した時点のスコープで設定されている値を保持する

```kotlin
@Composable
fun Modifier.myBackground(): Modifier {
    val color = LocalContentColor.current
    return this then Modifier.background(color.copy(alpha = 0.5f))
}

@Composable
fun MyScreen() {
    // LocalContentColor を緑色に更新
    CompositionLocalProvider(LocalContentColor provides Color.Green) {
        // 背景を半透明にする
        val backgroundModifier = Modifier.myBackground()

        // LocalContentColor を赤色に更新
        CompositionLocalProvider(LocalContentColor provides Color.Red) {

            // Box の背景は緑色になります。
            Box(modifier = backgroundModifier)
        }
    }
}
```

上記のコードでは、 Box は LocalContentColor が赤色のスコープ内で生成されますが、修飾子 ( backgroundModifier ) は、緑色のスコープで生成された修飾子であるため、緑色の背景になります。

背景色を赤色にしたい場合は、 Modifier.Node を使用してください。コンポジションローカルが使用サイトで正しく解決され、安全にホイスティングできます。


#### 注意点２：戻り値を持つコンポーズ可能な関数で使用する場合のパフォーマンス低下

戻り値を持つコンポーズ可能な関数は、再コンポーズをスキップできないため、修飾子関数は再コンポーズのたびに呼び出されます。そのため、頻繁に再コンポーズするとコストが高くなる可能性があります。


#### 注意点３：コンポーザブルな関数内からしか呼び出せない

CompositionLocal にアクセスできるのは、コンポーザブルな関数内からのみとなります。そのため、ホイスティングできる場所が制限されます。

```kotlin
// CompositionLocal にアクセスしないカスタム修飾子は、
// コンポーザブルな関数以外の場所からアクセス可能です。
val extractedModifier = Modifier.background(Color.Red)

// CompositionLocal にアクセスするカスタム修飾子は、
// コンポーザブルな関数内からのみアクセス可能です。
@Composable
fun Modifier.composableModifier(): Modifier {
    val color = LocalContentColor.current.copy(alpha = 0.5f)
    return this then Modifier.background(color)
}

@Composable
fun MyComposable() {
    // コンポーザブルな関数内からのみアクセス可能
    val composedModifier = Modifier.composableModifier()
}
```


## Modifier.Node を使用してカスタムの修飾子の動作を実装する

### Modifier.Node クラスの実装

Modifier.Node の実装 (この例では CircleNode ) は、カスタム修飾子の機能を実装します。

```kotlin
// Modifier.Node
private class CircleNode(var color: Color) : DrawModifierNode, Modifier.Node() {
    override fun ContentDrawScope.draw() {
        drawCircle(color)
    }
}
```

Node を実装するには、 Modifier.Node と 0 個以上のノードタイプ (例では DrawModifierNode ) を実装します。修飾子が必要とする機能に応じて、さまざまなノードタイプがあります。詳細は [公式ドキュメント](https://developer.android.com/develop/ui/compose/custom-modifiers?hl=ja&_gl=1*lnd9pv*_up*MQ..*_ga*MTk0MTI4MDI5NC4xNzE5OTgwMTIw*_ga_6HH9YJMN9M*MTcyMDA3ODMzOS4zLjAuMTcyMDA3ODMzOS4wLjAuMA..#implement_a_custom_modifier_using_modifiernode) を参照してください。


### ModifierNodeElement クラスの実装

ModifierNodeElement は、カスタム修飾子 (そのデータを含む) を作成・更新する機能を持った不変クラスです。先ほどの例で言えば、色を保持するクラスです。

```kotlin
// ModifierNodeElement
private data class CircleElement(val color: Color) : ModifierNodeElement<CircleNode>() {
    override fun create() = CircleNode(color)

    override fun update(node: CircleNode) {
        node.color = color
    }
}
```

ModifierNodeElement 実装では、次のメソッドをオーバーライドする必要があります。

- create
  - 修飾子ノードをインスタンス化する関数です。
- update
  - この関数は、このノードがすでに存在し、プロパティが変更されたときに、修飾子が同じスポットで提供されるたびに呼び出されます。
  - このクラスの equals が false を返した場合は、 update が呼び出されます。
  - update 関数内で、ノードのプロパティを更新する必要があります。
  - このようにノードを再利用することで、パフォーマンスが向上します
  - update が呼び出されると、 Node で継承したノードタイプ (例では DrawModifierNode ) が機能し、必要な処理 (例ではノードの再描画) が行われます。

また、 ModifierNodeElement の実装では equals と hashCode も実装する必要があります。 **上記のサンプルコードでは、これらの関数を自動実装してくれる data クラスを使用しています。**


### 修飾子ファクトリの定義

ほとんどの場合、修飾子要素を作成して修飾子チェーンに追加するだけで済みます。

```kotlin
// Modifier factory
fun Modifier.circle(color: Color) = this then CircleElement(color)
```


## Modifier.Node を使用する一般的な状況

難易度が高そうで、あまり使う機会も少なさそうなので、後回しにします。

公式ドキュメントへのリンクは [こちら](https://developer.android.com/develop/ui/compose/custom-modifiers?hl=ja&_gl=1*rjm62i*_up*MQ..*_ga*MTE2MTIzOTExMy4xNzI0NjIxNDU1*_ga_6HH9YJMN9M*MTcyNDYyOTYyMC4yLjAuMTcyNDYyOTYyMC4wLjAuMA..#common-situations) です。



