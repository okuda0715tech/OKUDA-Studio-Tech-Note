- [タップとプレス](#タップとプレス)
  - [タップまたはクリックに反応する](#タップまたはクリックに反応する)
  - [長押しするとコンテキストメニューが表示されます](#長押しするとコンテキストメニューが表示されます)
  - [Scrim をタップしてコンポーザブルを閉じる](#scrim-をタップしてコンポーザブルを閉じる)
  - [ダブルタップで拡大](#ダブルタップで拡大)


# タップとプレス

多くのコンポーザブルには、タップやクリックのサポートが組み込まれており、 onClick ラムダが含まれています。たとえば、マテリアル デザインの適切な動作に則ったクリック可能なサーフェスを作成できます。

```kotlin
Surface(onClick = { /* handle click */ }) {
    Text("Click me!", Modifier.padding(24.dp))
}
```

ただし、クリックはユーザーがコンポーザブルを操作する唯一の方法ではありません。ドラッグなど、様々なユーザー操作がある中で、このページでは、ポインタの位置が重要ではないジェスチャについて説明していきます。次の表に、ここで扱うジェスチャのタイプを示します。

| ジェスチャ     | 詳細                                           |
| -------------- | ---------------------------------------------- |
| Tap (or Click) | ポインタがダウンしてからアップする             |
| Double tap     | Tap が二回繰り返される                         |
| Long-press     | ポインタがダウンしてからしばらくそのままになる |
| プレス         | ポインタがダウンする                           |


## タップまたはクリックに反応する

[clickable](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*q2adlb*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0)) は、タップやクリックにコンポーザブルが反応するようにする、よく使用される修飾子です。この修飾子は、フォーカスのサポート、マウスやスタイラスのホバリング、押されたときのカスタマイズ可能な視覚表示などの追加機能も追加します。この修飾子は、マウスや指だけでなく、キーボード入力やアクセシビリティ サービスの使用によるクリック イベントなど、最も広い意味での「クリック」に反応します。

画像のグリッドを想像してください。ユーザーが画像をクリックすると、画像が全画面で表示されます。

https://youtube.com/shorts/J2GqJvG6HS8?feature=share

この動作を実装するには、グリッド内の各項目に clickable 修飾子を追加できます。

```kotlin
@Composable
private fun ImageGrid(photos: List<Photo>) {
    var activePhotoId by rememberSaveable { mutableStateOf<Int?>(null) }
    LazyVerticalGrid(columns = GridCells.Adaptive(minSize = 128.dp)) {
        items(photos, { it.id }) { photo ->
            ImageItem(
                photo,
                Modifier.clickable { activePhotoId = photo.id }
            )
        }
    }
    if (activePhotoId != null) {
        FullScreenImage(
            photo = photos.first { it.id == activePhotoId },
            onDismiss = { activePhotoId = null }
        )
    }
}
```

clickable 修飾子は、次の動作も追加します:

- interactionSource と indicator
  - これらは、ユーザーがコンポーザブルをタップするとデフォルトで波紋を描画します。
  - これらをカスタマイズする方法については、 [ユーザー インタラクションの処理のページ](../5.ユーザー操作/1.ユーザー操作を処理する.md) でご確認ください。

- セマンティクス情報を設定することで、アクセシビリティ サービスが要素と対話できるようにします。

- フォーカスを許可し、Enter キーまたは D パッドの中央を押して対話できるようにすることで、キーボードまたはジョイスティックの対話をサポートします。

- 要素をホバー可能にして、マウスまたはスタイラスをホバーすると要素が反応するようにします。


## 長押しするとコンテキストメニューが表示されます

[combinedClickable](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*ay4bv3*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).combinedClickable(androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.Indication,kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.String,kotlin.Function0,kotlin.Function0,kotlin.Function0)) を使用すると、通常のクリック動作に加えて、ダブルタップまたは長押しの動作を追加できます。

次の例では、 combinedClickable を使用して、ユーザーがグリッド画像をタッチして押したままにしたときにコンテキスト メニューを表示します。

注: combinedClickable は試験的な API であるため、Compose の将来のリリースで API サーフェスが変更される可能性があります。ただし、修飾子の動作は安定していると見なされます。

https://youtube.com/shorts/4BwrOc634lk?feature=share

```kotlin
var contextMenuPhotoId by rememberSaveable { mutableStateOf<Int?>(null) }
// Haptic は、触覚(触ったときの振動等によるフィードバック)という意味。
val haptics = LocalHapticFeedback.current
LazyVerticalGrid(columns = GridCells.Adaptive(minSize = 128.dp)) {
    items(photos, { it.id }) { photo ->
        ImageItem(
            photo,
            Modifier
                .combinedClickable(
                    onClick = { activePhotoId = photo.id },
                    onLongClick = {
                        haptics.performHapticFeedback(HapticFeedbackType.LongPress)
                        contextMenuPhotoId = photo.id
                    },
                    onLongClickLabel = stringResource(R.string.open_context_menu)
                )
        )
    }
}
if (contextMenuPhotoId != null) {
    PhotoActionsSheet(
        photo = photos.first { it.id == contextMenuPhotoId },
        onDismissSheet = { contextMenuPhotoId = null }
    )
}
```

ベスト プラクティスとして、ユーザーが要素を長押ししたときに触覚フィードバックを含める必要があります。そのため、スニペットには performHapticFeedback 呼び出しが含まれています。


## Scrim をタップしてコンポーザブルを閉じる

参考 : Scrim とは、後ろがうっすらと見える薄いカーテンのようなもの。つまり、ダイアログ表示中に、その周りにできる半透明の部分のこと。

上記の例では、clickable と combinedClickable によって、コンポーザブルに便利な機能が追加されています。これらは、リップルエフェクトなどの視覚的な表示を行い、ホバーに反応し、フォーカス、キーボード、アクセシビリティのサポートを含みます。ただし、この追加の動作が常に望ましいとは限りません。

画像の詳細画面を見てみましょう。背景は半透明で、ユーザーはその背景をタップして詳細画面を閉じることができる必要があります。

https://youtube.com/shorts/V-glxoQrU7w?feature=share

この場合、その背景には、インタラクションに関する視覚的な表示がなく、ホバーに反応せず、フォーカス可能でもなく、キーボード イベントやアクセシビリティ イベントへの反応が一般的なコンポーザブルとは異なります。クリック可能な動作を適応させる代わりに、抽象化レベルを下げて、detectTapGestures メソッドと組み合わせて、pointerInput 修飾子を直接使用できます。

```kotlin
@Composable
private fun Scrim(onClose: () -> Unit, modifier: Modifier = Modifier) {
    val strClose = stringResource(R.string.close)
    Box(
        modifier
            // handle pointer input
            .pointerInput(onClose) { detectTapGestures { onClose() } }
            // handle accessibility services
            .semantics(mergeDescendants = true) {
                contentDescription = strClose
                onClick {
                    onClose()
                    true
                }
            }
            // handle physical keyboard input
            .onKeyEvent {
                if (it.key == Key.Escape) {
                    onClose()
                    true
                } else {
                    false
                }
            }
            // draw scrim
            .background(Color.DarkGray.copy(alpha = 0.75f))
    )
}
```

ポインター入力修飾子のキーとして、onClose ラムダを渡します。これにより、ラムダが自動的に再実行され、ユーザーがスクリーンをタップしたときに適切なコールバックが呼び出されるようになります。


## ダブルタップで拡大

clickable と combinedClickable には、インタラクションに正しく応答するのに十分な情報が含まれていない場合があります。たとえば、コンポーザブルは、インタラクションが発生したコンポーザブルの境界内の位置にアクセスする必要がある場合があります。

画像の詳細画面をもう一度見てみましょう。ベスト プラクティスは、ダブルタップで画像を拡大できるようにすることです。

https://youtube.com/shorts/iy4BpQ4yfn0?feature=share

ビデオでわかるように、タップ イベントの位置を中心にズームインが行われます。画像の左側と右側の部分でズームインすると、結果が異なります。pointerInput 修飾子を detectTapGestures と組み合わせて使用​​することで、タップ位置を計算に組み込むことができます。

```kotlin
var zoomed by remember { mutableStateOf(false) }
var zoomOffset by remember { mutableStateOf(Offset.Zero) }
Image(
    painter = rememberAsyncImagePainter(model = photo.highResUrl),
    contentDescription = null,
    modifier = modifier
        .pointerInput(Unit) {
            detectTapGestures(
                onDoubleTap = { tapOffset ->
                    zoomOffset = if (zoomed) Offset.Zero else
                        calculateOffset(tapOffset, size)
                    zoomed = !zoomed
                }
            )
        }
        .graphicsLayer {
            scaleX = if (zoomed) 2f else 1f
            scaleY = if (zoomed) 2f else 1f
            translationX = zoomOffset.x
            translationY = zoomOffset.y
        }
)
```




