- [ライフサイクル](#ライフサイクル)
  - [ライフサイクルの概要](#ライフサイクルの概要)
  - [再コンポーズの発生条件](#再コンポーズの発生条件)
    - [State オブジェクトの役割](#state-オブジェクトの役割)
  - [再コンポーズのスキップ条件](#再コンポーズのスキップ条件)
  - [Compose がコンポーザブルを識別する方法](#compose-がコンポーザブルを識別する方法)
  - [コンポーザブルを認識する方法をカスタマイズする](#コンポーザブルを認識する方法をカスタマイズする)
  - [再コンポーズのスキップ](#再コンポーズのスキップ)
    - [パラメータのタイプが安定とは](#パラメータのタイプが安定とは)
    - [強制的に安定型を指定する](#強制的に安定型を指定する)
  - [remember 系の関数](#remember-系の関数)


# ライフサイクル

## ライフサイクルの概要

<img src="./画像/ライフサイクル.png" width="400">

用語の説明

- コンポジション
  - コンポーザブル関数によって構築された UI ツリーのこと
- コンポーザブル
  - `@Composable` アノテーションが付与された関数のこと。 UI ウィジェットとも呼ぶことがあります。
- 入場する
  - コンポーザブルが UI ツリーに追加されること
- 退場する
  - コンポーザブルが UI ツリーから削除されること

基本的には、入場と退場は、ウィジェットが画面に表示されているかどうかに等しいですが、まれに、 LazyColumn などで、 UI ツリーに追加はされているけれど、スクロールされるまで画面にはまだ表示されていないような状況では、入場していても画面に表示されていないことがあります。

**補足** : 公式ドキュメントでは、 「再コンポジション」 と 「再コンポーズ」 という似たような言葉が出てきますが、これらの言葉は、同じ意味で使用されています。そもそも、 Compose は動詞、 Composition は名詞という品詞の違いだけで、それぞれの意味は同じです。 「再コンポジション」 なら名詞として使用し、 「再コンポーズ」 なら動詞として使用しているにすぎません。


## 再コンポーズの発生条件

Compose では、監視している State オブジェクト、または、コンポーザブル関数のパラメータが変更されるたびに、再コンポジションが発生します。


### State オブジェクトの役割

上記の通り、 State オブジェクトの値が変更されると、コンポーズは、その変更を検出して、再コンポーズを行います。

つまり、 State オブジェクトではない、通常のプロパティが変更されるだけでは、再コンポジションは発生しません。


## 再コンポーズのスキップ条件

再コンポジションが発生した際に、前回のコンポジションと引数が同じなら、そのコンポーザブルは再コンポーズされません。

ただし、引数の型が関数型である場合は、その内容が前回の再コンポーズと同じだったとしても、スキップされず、毎回、再コンポーズの対象となるようです。これは、ラムダ式のインスタンスが、実行時に毎回生成されており、ラムダ式には equals 関数のような等価判定を行う術がないために、別オブジェクトとみなされているためだと思われます。

例えば、以下のコンポーザブル関数は、ボタンタップ時に、毎回 `Row` が再コンポーズされ、 `Row is called.` というログが出力されます。

```kotlin
@Composable
fun RecomposeExample() {

    Column {
        var content1 by remember {
            mutableStateOf("one")
        }

        Text(text = content1)

        Button(onClick = {
            content1 = "壱"
        }) {
            Text(text = "英和")
        }

        Button(onClick = {
            content1 = "one"
        }) {
            Text(text = "和英")
        }

        Row {
            Log.i("test", "Row is called.")
            Text("再コンポーズされたくないオブジェクト")
        }
    }
}
```

Row は、 content1 の状態に依存しないため、再コンポーズを実施したくはありません。その場合は、次に示すように、別のコンポーザブル関数として抽出することで、再コンポーズを回避することが可能です。これは、前回の例では、 Row 関数がラムダ式をパラメータに持っていたため、毎回再コンポーズ対象になっていましたが、 Row 関数を別のコンポーザブル関数に抽出することで、 `MyRow()` 関数の呼び出しには、まったく引数を持たなくなったことにより、再コンポーズがスキップされたものだと考えられます。

```kotlin
@Composable
fun RecomposeExample() {

    Column {
        var content1 by remember {
            mutableStateOf("one")
        }

        Text(text = content1)

        Button(onClick = {
            content1 = "壱"
        }) {
            Text(text = "英和")
        }

        Button(onClick = {
            content1 = "one"
        }) {
            Text(text = "和英")
        }

        MyRow()
    }
}

@Composable
fun MyRow() {
    Row {
        Log.i("test", "Row is called.")
        Text("再コンポーズされたくないオブジェクト")
    }
}
```

上記のコードを実行すると、ボタンタップ時に `Row is called.` というログは出力されません。


## Compose がコンポーザブルを識別する方法

以下の条件で、 Compose はコンポーザブルのインスタンスを識別します。インスタンスが同じで、そのインプットも同じ場合、再コンポーズはスキップされます。

1. コールサイト
   - プログラムのどのクラスの何行目から呼び出しているか。
2. 実行順序
   - for ループ内など、コールサイトが同じ場合のコンポーズの呼び出しでは、コールサイトに加えて、実行順序がコンポーザブルのインスタンスの識別に使用されます。


## コンポーザブルを認識する方法をカスタマイズする

次のように実装すると、 Compose は、実行順序でコンポーザブル ( MovieOverview ) を認識するため、 MovieOverview の並び順が変わったり、途中に要素が追加された場合は、再コンポーズが行われます。

```kotlin
@Composable
fun MoviesScreen(movies: List<Movie>) {
    Column {
        for (movie in movies) {
            // MovieOverview composables are placed in Composition given its
            // index position in the for loop
            MovieOverview(movie)
        }
    }
}
```

しかし、再利用できるコンポーザブルがあるにも関わらず、全ての MoviewOverview を再コンポーズするのは無駄であるため、以下のように key() 関数 (コンポーザブル) を使用して、要素の ID を渡してあげると、実行順序に関係なく、同一の要素の場合は、コンポーザブルを再コンポーズすることなく、再利用してくれます。

```kotlin
@Composable
fun MoviesScreenWithKey(movies: List<Movie>) {
    Column {
        for (movie in movies) {
            // 前回と同じ id が存在すれば再コンポーズしない。
            key(movie.id) {
                MovieOverview(movie)
            }
        }
    }
}
```

一部のコンポーザブルは、 key コンポーザブルの組み込みサポートを備えています。たとえば、 LazyColumn は、 items DSL 内のカスタム key の指定を受け入れます。

```kotlin
@Composable
fun MoviesScreenLazy(movies: List<Movie>) {
    LazyColumn {
        items(movies, key = { movie -> movie.id }) { movie ->
            MovieOverview(movie)
        }
    }
}
```


## 再コンポーズのスキップ

コンポーズ可能な関数は、関数のインプットが変わっていない場合は、基本的に再コンポーズがスキップされます。ただし、以下のいずれかの条件に一致する場合、スキップされません。

- 関数に Unit 以外の戻り値の型がある。
- 関数に `@NonRestartableComposable` または `@NonSkippableComposable` アノテーションが付与されている。
- 必須パラメータのタイプが不安定である。 (詳細は後述します)


### パラメータのタイプが安定とは

パラメータのタイプが安定しているとみなされるためには、以下の条件を満たしている必要があります。

- 2 つのインスタンスの equals の結果が、同じ 2 つのインスタンスについて常に同じになる。
- 型の公開プロパティが変化すると、 Composition に通知される。
- すべての public プロパティの型も安定している。

ただし、以下のタイプは、無条件に安定しているとみなされます。

- すべてのプリミティブ値型: Boolean、Int、Long、Float、Char など
- 文字列
- すべての関数型 (ラムダ)

**簡単に言うと、 「安定している」 とは、値が絶対に変わらないか、もしくは、値が変わったら必ず Composition に通知して、再コンポジションの対象にしてくれるか。ということではないか？**


### 強制的に安定型を指定する

強制的に型が安定しているとみなすには、 `@Stable` アノテーションでマークします。

```kotlin
@Stable
interface UiState<T : Result<T>> {
    val value: T?
    val exception: Throwable?

    val hasError: Boolean
        get() = exception != null
}
```

**つまり、独自のクラスを定義して、そのクラスをコンポーズ可能な関数の引数で使用する場合、 equals() 関数で true が返ってきたとしても、通常は、再コンポーズが走る。それを回避する簡単な方法は、 remember 関数や mutableState 関数を使用するべきということか？**


## remember 系の関数

remeber 系の関数は、 State オブジェクトをラップします。ラップされた State は再コンポーズが発生しても破棄されずに保持されます。

以下のコードでは、 `Counter` コンポーザブルが再コンポーズされても、 count は破棄されずに保持されます。

```kotlin
@Composable
fun Counter() {
    var count by remember { mutableStateOf(0) }

    Button(onClick = { count++ }) {
        Text("Clicked $count times")
    }
}
```
