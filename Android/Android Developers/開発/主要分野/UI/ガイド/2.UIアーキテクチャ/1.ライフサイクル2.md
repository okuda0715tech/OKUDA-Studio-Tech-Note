- [ライフサイクル](#ライフサイクル)
  - [ライフサイクルの概要](#ライフサイクルの概要)
  - [Composition 内のコンポーザブルの構造](#composition-内のコンポーザブルの構造)
    - [スマートな再コンポジションに役立つ情報を追加する](#スマートな再コンポジションに役立つ情報を追加する)
    - [入力が変化していない場合にスキップする](#入力が変化していない場合にスキップする)


# ライフサイクル

このページでは、コンポーザブルのライフサイクルと、コンポーザブルの再コンポジションが必要かどうかを Compose が判断する方法について説明します。

## ライフサイクルの概要

[状態の管理のドキュメント](./4.状態の管理/1.概要.md) で説明されているように、コンポジションは、コンポーザブルを実行することによって生成され、アプリの UI を構築します。 **コンポジションは、UI を記述するコンポーザブルのツリー構造です。**

Jetpack Compose がコンポーザブルを初めて実行すると、コンポジションは、コンポーザブルの追跡を開始します。その後、アプリの状態が変化すると、Jetpack Compose は再コンポジションをスケジュールします。 **再コンポジションとは、状態の変化に応じて変更された可能性のあるコンポーザブルを Jetpack Compose が再実行し、変更を反映するようにコンポジションを更新することです。**

コンポジションは、初回実行時にのみ生成され、再コンポジションによってのみ更新されます。

重要なポイント: コンポーザブルのライフサイクルは、コンポジションに入る、0 回以上再コンポーズされる、コンポジションから出るというイベントによって定義されます。

<img src="./画像/ライフサイクル.png" width="400">

図 1. コンポジション内のコンポーザブルのライフサイクル。コンポジションに入り、0 回以上再コンポーズされてから、コンポジションから出ます。

注意 : 以下、「再コンポジション」と「再コンポーズ」という似たような言葉が出てきますが、これらの言葉は、同じ意味で使用されていると思われます。

再コンポジションは通常、 [`State<T>`](https://developer.android.com/reference/kotlin/androidx/compose/runtime/State?_gl=1*1cdj7ul*_up*MQ..*_ga*NTY3MDY5MDA1LjE3MjQ2NTg1MjY.*_ga_6HH9YJMN9M*MTcyNTg1MzQ3OC4xMC4wLjE3MjU4NTM3MjQuMC4wLjA.) オブジェクトの変更によってトリガーされます。Compose はこれらを追跡し、その特定の `State<T>` を読み取るコンポジション内のすべてのコンポーザブルと、それらが呼び出すスキップできないコンポーザブルを実行します。

注: コンポーザブルのライフサイクルは、ビュー、アクティビティ、フラグメントのライフサイクルよりも単純です。コンポーザブルで、より複雑なライフサイクルを持つ外部リソースを管理または操作する必要がある場合は、エフェクトを使用する必要があります。

コンポーザブルが複数回呼び出されると、複数のインスタンスがコンポジションに配置されます。各呼び出しには、コンポジション内で独自のライフサイクルがあります。

```kotlin
@Composable
fun MyComposable() {
    Column {
        Text("Hello")
        Text("World")
    }
}
```

<img src="./画像/複数回呼び出されたコンポーザブルは別物として扱われる.png" width="400">

図 2. コンポジションでの MyComposable の表現。コンポーザブルが複数回呼び出されると、コンポジションに複数のインスタンスが配置されます。異なる色の要素は、別のインスタンスであることを示します。


## Composition 内のコンポーザブルの構造

難しい内容は書かれていないので、省略する。


### スマートな再コンポジションに役立つ情報を追加する

既に知っている内容なのでスキップする。


### 入力が変化していない場合にスキップする

再コンポーズの際に、一部の適格な合成可能関数は、入力が以前の合成から変更されていない場合、実行を完全にスキップできます。

合成可能関数は、次の場合を除き、スキップの対象となります。

- 関数の戻り値の型が Unit 以外である
- 関数に @NonRestartableComposable または @NonSkippableComposable の注釈が付けられている
- 必須パラメータが非安定型である

最後の要件を緩和する試験的なコンパイラ モードである Strong Skipping があります。

型が安定しているとみなされるためには、次の規約に準拠している必要があります。

- 2 つのインスタンスの equals の結果は、同じ 2 つのインスタンスでは常に同じになります。
- 型のパブリック プロパティが変更されると、Composition に通知されます。
- すべてのパブリック プロパティ型も安定しています。

この契約に該当する重要な共通型がいくつかあります。これらの型は、@Stable アノテーションを使用して明示的に安定としてマークされていなくても、Compose コンパイラーによって安定として扱われます。

- すべてのプリミティブ値型: Boolean、Int、Long、Float、Char など。
- 文字列
- すべての関数型 (ラムダ)

これらの型はすべて不変であるため、安定の契約に従うことができます。不変型は変更されないため、変更を Composition に通知する必要がないため、この契約に従う方がはるかに簡単です。

注: 完全に不変な型はすべて、安定型と見なすことができます。

安定しているが可変である注目すべき型の 1 つは、Compose の MutableState 型です。値が MutableState に保持されている場合、State の .value プロパティの変更が Compose に通知されるため、状態オブジェクト全体が安定していると見なされます。

コンポーザブルにパラメーターとして渡されるすべての型が安定している場合、UI ツリー内のコンポーザブルの位置に基づいてパラメーター値が等しいかどうかが比較されます。前回の呼び出し以降、すべての値が変更されていない場合、再合成はスキップされます。

重要なポイント: すべての入力が安定しており、変更されていない場合、Compose はコンポーザブルの再合成をスキップします。比較には equals メソッドを使用します。

Compose は、証明できる場合にのみ型を安定と見なします。たとえば、インターフェースは一般に安定していないものとして扱われ、実装が不変である可能性がある可変パブリック プロパティを持つ型も安定していません。

Compose が型が安定していると推測できないが、Compose にその型を安定として扱うように強制する場合は、@Stable アノテーションでマークします。


