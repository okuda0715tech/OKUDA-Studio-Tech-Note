- [高度なアニメーションの例: 操作](#高度なアニメーションの例-操作)


# 高度なアニメーションの例: 操作

タップイベントやアニメーションを使用する場合は、アニメーションだけを使用する場合と比べて、考慮すべき点がいくつかあります。まず、ユーザー操作を最優先する必要があるため、場合によっては、タップイベントの開始時に実行中のアニメーションを中断する必要があります。

以下の例では、Animatable を使用して Circle コンポーネントのオフセット位置を表しています。 (オフセットは、円の中心点の位置を表します)

タップイベントは、 [pointerInput](https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary?hl=ja&_gl=1*1q53dcl*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(androidx.compose.ui.Modifier).pointerInput(kotlin.Any,%20kotlin.coroutines.SuspendFunction1)) 修飾子で処理されます。新しいタップイベントを検出すると、animateTo を呼び出して、新しいタップ位置までのオフセット値の変更をアニメーション化します。

アニメーション中にタップイベントが発生する場合もあります。その場合、animateTo は実行中のアニメーションを中断し、そのアニメーションの途中の位置から、新しいターゲット位置までのアニメーションを行います。新しいアニメーションを開始する際、中断されたアニメーションの速度で新しいアニメーションが開始されます。

```kotlin
@Composable
fun Gesture() {
    val offset = remember { Animatable(Offset(0f, 0f), Offset.VectorConverter) }
    Box(
        modifier = Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                coroutineScope {
                    while (true) {
                        // タップイベントを検出し、その位置を取得する。
                        awaitPointerEventScope {
                            val position = awaitFirstDown().position

                            launch {
                                // タップされた位置へのアニメーションを実施する。
                                offset.animateTo(position)
                            }
                        }

                        // while(true) なので、無限実行されていそうにも見えますが、
                        // awaitPointerEventScope が suspend 関数なので、
                        // タッチイベントを検出するまで、
                        // while ブロック内の処理を suspend してくれています。
                        // つまり、このログは、画面がタップされたときにしか出力されません。
                        Log.v("test", "while loop")
                    }
                }
            }
    ) {
        Circle(modifier = Modifier.offset { offset.value.toIntOffset() })
    }
}

private fun Offset.toIntOffset() = IntOffset(x.roundToInt(), y.roundToInt())

@Composable
fun Circle(modifier: Modifier = Modifier) {
    Canvas(modifier = modifier) {
        drawCircle(Color.LightGray, radius = 200f)
    }
}
```

https://youtube.com/shorts/F5xeW0_NerI?feature=share

もう 1 つのよくあるパターンでは、アニメーション値を、ドラッグなどのタップイベントから取得した値と同期させる必要があります。

以下の例では、 SwipeToDismiss コンポーザブルを使用するのではなく、Modifier として「スワイプで閉じる」を実装しています。

要素の水平オフセットは、Animatable として表されます。この API には操作アニメーションで役立つ特性があります。この値は、タップイベントとアニメーションによって変更できます。タップイベントを受け取ると、進行中のすべてのアニメーションがインターセプトされるように、stop メソッドにより Animatable を停止します。

ドラッグ イベントでは、snapTo を使用して、タップイベントから計算された値で Animatable の値を更新します。フリングについては、Compose に用意されている VelocityTracker を使うと、ドラッグ イベントを記録して速度を計算できます。速度は animateDecay に直接送られ、フリング アニメーションに使用されます。オフセット値を元の位置に戻すには、animateTo メソッドでターゲット オフセット値を 0f に指定します。

```kotlin
fun Modifier.swipeToDismiss(
    onDismissed: () -> Unit
): Modifier = composed {
    val offsetX = remember { Animatable(0f) }
    pointerInput(Unit) {
        // フリングの減衰を計算するのに使用されます。
        val decay = splineBasedDecay<Float>(this)
        // タッチイベントと Animatable のために suspend 関数を使用します。
        coroutineScope {
            while (true) {
                val velocityTracker = VelocityTracker()
                // 実行中のどんなアニメーションも停止します。
                offsetX.stop()
                awaitPointerEventScope {
                    // タッチダウンイベントを検出します。
                    val pointerId = awaitFirstDown().id

                    horizontalDrag(pointerId) { change ->
                        // タッチイベントによって、アニメーションの値を更新します。
                        launch {
                            offsetX.snapTo(
                                offsetX.value + change.positionChange().x
                            )
                        }
                        velocityTracker.addPosition(
                            change.uptimeMillis,
                            change.position
                        )
                    }
                }
                // 既にタッチイベントを受信しない状態になっています。
                // アニメーションの準備を行います。
                val velocity = velocityTracker.calculateVelocity().x
                val targetOffsetX = decay.calculateTargetValue(
                    offsetX.value,
                    velocity
                )
                // 境界に到達するとアニメーションは停止します。
                offsetX.updateBounds(
                    lowerBound = -size.width.toFloat(),
                    upperBound = size.width.toFloat()
                )
                launch {
                    if (targetOffsetX.absoluteValue <= size.width) {
                        // 十分な速度がないため、スライドバックします。
                        offsetX.animateTo(
                            targetValue = 0f,
                            initialVelocity = velocity
                        )
                    } else {
                        // UI 要素がスワイプによって、非表示になります。
                        offsetX.animateDecay(velocity, decay)
                        onDismissed()
                    }
                }
            }
        }
    }
        .offset { IntOffset(offsetX.value.roundToInt(), 0) }
}
```

