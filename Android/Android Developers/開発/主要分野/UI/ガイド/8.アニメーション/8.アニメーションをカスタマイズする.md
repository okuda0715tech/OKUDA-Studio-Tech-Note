- [アニメーションをカスタマイズする](#アニメーションをカスタマイズする)
  - [AnimationSpec パラメータを使用してアニメーションをカスタマイズする](#animationspec-パラメータを使用してアニメーションをカスタマイズする)
    - [spring を使用して物理ベースのアニメーションを作成する](#spring-を使用して物理ベースのアニメーションを作成する)
      - [dampingRatio](#dampingratio)
      - [stiffness](#stiffness)
    - [tween によるイージングカーブで開始値と終了値の間のアニメーション](#tween-によるイージングカーブで開始値と終了値の間のアニメーション)
    - [keyframes を使用して、特定のタイミングで特定の値にアニメーション化する](#keyframes-を使用して特定のタイミングで特定の値にアニメーション化する)
    - [repeatable でアニメーションを繰り返す](#repeatable-でアニメーションを繰り返す)
    - [infiniteRepeatable を使用してアニメーションを無限に繰り返す](#infiniterepeatable-を使用してアニメーションを無限に繰り返す)
    - [snap で終了値にすぐにスナップ](#snap-で終了値にすぐにスナップ)
  - [カスタムイージング関数を設定する](#カスタムイージング関数を設定する)
  - [AnimationVector との間で変換を行い、カスタムデータ型をアニメーション化する](#animationvector-との間で変換を行いカスタムデータ型をアニメーション化する)


# アニメーションをカスタマイズする

アニメーション API の多くは、動作をカスタマイズするためのパラメータを受け入れます。


## AnimationSpec パラメータを使用してアニメーションをカスタマイズする

ほとんどのアニメーション API では、オプションの AnimationSpec パラメータでアニメーションの仕様をカスタマイズできます。

```kotlin
val alpha: Float by animateFloatAsState(
    targetValue = if (enabled) 1f else 0.5f,
    // アニメーションの実行時間といーじんぐを構成します。
    animationSpec = tween(durationMillis = 300, easing = FastOutSlowInEasing)
)
```

各種アニメーションの作成に対応した、さまざまなタイプの AnimationSpec があります。


### spring を使用して物理ベースのアニメーションを作成する

spring は、開始値と終了値の間で物理学ベースのアニメーションを作成します。dampingRatio と stiffness の 2 つのパラメータを受け取ります。

```kotlin
val value by animateFloatAsState(
    targetValue = 1f,
    animationSpec = spring(
        dampingRatio = Spring.DampingRatioHighBouncy,
        stiffness = Spring.StiffnessMedium
    )
)
```


#### dampingRatio

dampingRatio は、ばねの弾性 (弾み具合) を定義します。

アニメーション終了時に、よく弾むか、まったく弾まないかを定義します。

デフォルト値は Spring.DampingRatioNoBouncy です。

https://youtu.be/FaNEv69cANY


#### stiffness

stiffness は、終了値までのばねの移動速度を定義します。

アニメーションの開始と終了がゆっくりとした速度か、それとも速い速度かを定義します。

デフォルト値は Spring.StiffnessMedium です。

https://youtu.be/_LULCKxngmY


継続時間ベースの AnimationSpec 型と比べて、spring は中断をより適切に処理できます。これは、spring の場合、アニメーション中にターゲット値が変更されたときに速度の継続性が保証されるためです。spring は、animate*AsState や updateTransition など、多くのアニメーション API によってデフォルトの AnimationSpec として使用されます。

たとえば、ユーザーのタッチによって駆動される次のアニメーションにspring と tween を適用した場合を考えてみましょう。アニメーションの進行中に、次のアニメーションが開始された場合、 tween よりも spring の方がスムーズにアニメーションされることがわかります。

https://youtu.be/d4XzOM8ydiE


### tween によるイージングカーブで開始値と終了値の間のアニメーション

tween は、イージング カーブを使用して、指定された durationMillis の開始値と終了値の間をアニメーション化します。tween は、 2 つの値の間 ( between ) の短縮形です。

delayMillis を指定して、アニメーションの開始を延期することもできます。

```kotlin
val value by animateFloatAsState(
    targetValue = 1f,
    animationSpec = tween(
        durationMillis = 300,
        delayMillis = 50,
        easing = LinearOutSlowInEasing
    )
)
```

詳しくは、 [イージング](#カスタムイージング関数を設定する) をご覧ください。


### keyframes を使用して、特定のタイミングで特定の値にアニメーション化する

keyframes は、アニメーションの持続時間内の異なるタイムスタンプで指定されたスナップショット値に基づいてアニメーション化します。アニメーション値は、常に 2 つのキーフレーム値の間で補間されます。これらのキーフレームごとに、イージングを指定して補間曲線を設定できます。

0 ms と持続時間の値の指定はオプションです。これらの値を指定しない場合は、デフォルトでアニメーションの開始値と終了値が設定されます。

```kotlin
val value by animateFloatAsState(
    targetValue = 1f,
    animationSpec = keyframes {
        durationMillis = 375
        0.0f at 0 with LinearOutSlowInEasing // for 0-15 ms
        0.2f at 15 with FastOutLinearInEasing // for 15-75 ms
        0.4f at 75 // ms
        0.4f at 225 // ms
    }
)
```


### repeatable でアニメーションを繰り返す

repeatable は、指定された繰り返し回数に達するまで、持続時間ベースのアニメーション（tween や keyframes など）を繰り返します。アニメーションを繰り返す際に、 repeatMode パラメータを渡すことができ、 RepeatMode.Restart なら最初から開始し、 RepeatMode.Reverse なら最後から開始します。

```kotlin
val value by animateFloatAsState(
    targetValue = 1f,
    animationSpec = repeatable(
        iterations = 3,
        animation = tween(durationMillis = 300),
        repeatMode = RepeatMode.Reverse
    )
)
```


### infiniteRepeatable を使用してアニメーションを無限に繰り返す

infiniteRepeatable は repeatable に似ていますが、繰り返し回数が無限である点が異なります。

```kotlin
val value by animateFloatAsState(
    targetValue = 1f,
    animationSpec = infiniteRepeatable(
        animation = tween(durationMillis = 300),
        repeatMode = RepeatMode.Reverse
    )
)
```

[ComposeTestRule](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/ComposeTestRule?hl=ja&_gl=1*1x8s3w2*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.) を使用したテストでは、infiniteRepeatable を使用したアニメーションは実行されません。各アニメーション値の初期値を使用してコンポーネントがレンダリングされます。


### snap で終了値にすぐにスナップ

snap は、値をすぐに終了値に切り替える特別な AnimationSpec です。delayMillis を指定して、アニメーションの開始を遅らせることができます。

```kotlin
// 50 ms 経過後に、アニメーション値を瞬時に 1f に更新します。
val value by animateFloatAsState(
    targetValue = 1f,
    animationSpec = snap(delayMillis = 50)
)
```

注: View システムでは、次のタスクに ObjectAnimator を使用する必要がありました。 時間ベースのアニメーションの場合は SpringAnimation、物理ベースのアニメーションの場合は SpringAnimation です。これは、 これら 2 種類のアニメーション API を同時に使用するのは簡単ではありませんでした。 Compose の AnimationSpec を使用すると、これらを統一された方法で処理できます。


## カスタムイージング関数を設定する

持続時間ベースの AnimationSpec オペレーション（tween、keyframes など）では、Easing を使用してアニメーションの割合を調整します。これにより、アニメーション化する値の速度を変えながら動かすことができます。割合は、0（開始）から 1.0（終了）までの値で、アニメーションの現在の位置を示します。

Easing とは、実際には 0～1.0 の小数値 (時間経過の割合) を受け取り、浮動小数点数 (アニメーションで使用する値) を返す関数です。戻り値は、オーバーシュート (※ 1 ) または アンダーシュート (※ 2 ) を表すために境界外となる場合もあります。

(※ 1 ) **オーバーシュート** : オーバーシュートは、オブジェクトが最終地点に到達する直前に目標を一度超えてしまい、その後戻ってくる動きです。たとえば、スライドやバウンドするアニメーションで、オブジェクトが一旦ゴール位置を超えて動き、少し後戻りすることで、動きに弾力やエネルギー感を持たせることができます。これは、物理法則に従う物体が力を受けて動いたときの自然な動きに似せています。

(※ 2 ) **アンダーシュート** : アンダーシュートは、オブジェクトが最終地点に達する前に、目標に届かずに一度止まり、その後最終地点に向かって再度動き出す動きです。これにより、オブジェクトが勢いを失いながら徐々に目標に近づくような表現が可能です。アンダーシュートは、より慎重な、または控えめな動きを表現する場合に使われることがあります。

カスタム Easing は、次のようなコードで作成できます。

```kotlin
val CustomEasing = Easing { fraction -> fraction * fraction }

@Composable
fun EasingUsage() {
    val value by animateFloatAsState(
        targetValue = 1f,
        animationSpec = tween(
            durationMillis = 300,
            easing = CustomEasing
        )
    )
    // ……
}
```

カスタムイージングを適用できるのは、 tween 関数のみだと思われます。 spring 関数には、 easing パラメータは存在しません。

Compose には、ほとんどのユースケースに対応できる組み込みの Easing 関数がいくつか用意されています。詳しくは、 [スピード - マテリアル デザイン](https://m3.material.io/styles/motion/easing-and-duration/applying-easing-and-duration) をご覧ください。 ご覧ください。

- FastOutSlowInEasing
- LinearOutSlowInEasing
- FastOutLinearEasing
- LinearEasing
- CubicBezierEasing

詳しくは [こちら](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary?hl=ja&_gl=1*121jwnd*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#Ease()) もご覧ください。

注: Easing オブジェクトは、プラットフォーム内の Interpolator クラスのインスタンスと同じように動作します。ただし、getInterpolation() メソッドの代わりに transform() メソッドを使用します。


## AnimationVector との間で変換を行い、カスタムデータ型をアニメーション化する

ほとんどの Compose アニメーション API は、Float、Color、Dp などの基本的なデータをサポートしています。 型はデフォルトでアニメーション値として設定されていますが、 カスタムのデータタイプを 選択できます。その場合、アニメーション中、アニメーション化する値は AnimationVector として表されます。値は、対応する TwoWayConverter によって AnimationVector に変換されます（逆も同様です）。これにより、コア アニメーション システムが値を均一に処理できるようになります。たとえば、Int は、単一の浮動小数点値を保持する AnimationVector1D として表されます。Int の TwoWayConverter は次のようになります。

```kotlin
val IntToVector: TwoWayConverter<Int, AnimationVector1D> =
    TwoWayConverter({ AnimationVector1D(it.toFloat()) }, { it.value.toInt() })
```

Color は基本的に 4 つの値（赤、緑、青、アルファ）のセットであるため、Color は 4 つの浮動小数点値を保持する AnimationVector4D に変換されます。

このように、アニメーションで使用されるデータ型はすべて、次元数に応じて AnimationVector1D、AnimationVector2D、AnimationVector3D、AnimationVector4D のいずれかに変換されます。これにより、オブジェクトの異なるコンポーネントを別々にアニメーション化し、それぞれの速度をトラッキングすることができます。

基本的なデータ型用の組み込みコンバータにアクセスできる Color.VectorConverter や Dp.VectorConverter などのコンバータもあります。

新しいデータ型のサポートをアニメーション化する値として追加する場合は、独自の TwoWayConverter を作成して API に指定できます。たとえば、次のように animateValueAsState を使用してカスタムのデータ型をアニメーション化できます。

```kotlin
data class MySize(val width: Dp, val height: Dp)

@Composable
fun MyAnimation(targetSize: MySize) {
    val animSize: MySize by animateValueAsState(
        targetSize,
        TwoWayConverter(
            convertToVector = { size: MySize ->
                // Extract a float value from each of the `Dp` fields.
                AnimationVector2D(size.width.value, size.height.value)
            },
            convertFromVector = { vector: AnimationVector2D ->
                MySize(vector.v1.dp, vector.v2.dp)
            }
        )
    )
}
```

以下に、組み込みの VectorConverter をいくつか紹介します。

- [Color.VectorConverter](https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Color.Companion?hl=ja&_gl=1*1c6ugs5*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(androidx.compose.ui.graphics.Color.Companion).VectorConverter())

- [Dp.VectorConverter](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary?hl=ja&_gl=1*1c6ugs5*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(androidx.compose.ui.unit.Dp.Companion).VectorConverter())

- [Offset.VectorConverter](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary?hl=ja&_gl=1*gdzs9n*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(androidx.compose.ui.geometry.Offset.Companion).VectorConverter())

- [Int.VectorConverter](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary?hl=ja&_gl=1*gdzs9n*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(kotlin.Int.Companion).VectorConverter())

- [Float.VectorConverter](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary?hl=ja&_gl=1*gdzs9n*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(kotlin.Float.Companion).VectorConverter())

- [IntSize.VectorConverter](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary?hl=ja&_gl=1*gdzs9n*_up*MQ..*_ga*OTQxMjc1NjExLjE3MjcwMTEwOTk.*_ga_6HH9YJMN9M*MTcyNzE1MTM1OS4yLjAuMTcyNzE1MTM1OS4wLjAuMjI4MzEzOTA.#(androidx.compose.ui.unit.IntSize.Companion).VectorConverter())


