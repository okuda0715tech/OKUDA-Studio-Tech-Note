<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [Style_Theme共通部分と差部分](#style_theme共通部分と差部分)
	- [スタイル、テーマ適用の優先順位](#スタイルテーマ適用の優先順位)
	- [スタイルとテーマの違い](#スタイルとテーマの違い)
	- [スタイルとテーマの共通部分](#スタイルとテーマの共通部分)
	- [styles.xmlファイル内でスタイルとテーマを区別するための命名規則](#stylesxmlファイル内でスタイルとテーマを区別するための命名規則)
	- [styles.xmlの肥大化を防ぐためにファイルを分割する](#stylesxmlの肥大化を防ぐためにファイルを分割する)
	- [スタイル属性とテーマ属性の見分け方](#スタイル属性とテーマ属性の見分け方)
	- [テーマ属性のデフォルト値の調べ方](#テーマ属性のデフォルト値の調べ方)
	- [まとめ](#まとめ)
<!-- TOC END -->


# Style_Theme共通部分と差部分

## スタイル、テーマ適用の優先順位

スタイル、テーマの適用方法について、優先順位が高い順に以下に並べます。

1. TextView 由来のクラスに、テキスト`スパン`による文字レベルまたは段落レベルのスタイル設定を適用する
2. Java,Kotlinのコードによる動的な適用
3. レイアウトxmlファイルの個々のViewの属性を用いた適用
4. レイアウトxmlファイルの個々のViewの`style="@style/xxx"`による適用
5. デフォルトのスタイル設定
6. レイアウトxmlファイルの個々のViewに対する、または、Manifestファイルの`<activity>`、`<application>`に`android:theme="@[android:]style/xxx"`による適用
7. TextView で TextAppearance`android:textAppearance="xxx"` を設定するなど、特定のビュー固有のスタイル設定を適用する

スタイル、テーマを適用しているにもかかわらず、思った通りの表示にならない場合は、優先順位がより高いものが適用されていないかチェックすると良い。


## スタイルとテーマの違い

- 子孫Viewへ適用されるかどうか
	- スタイルは指定したViewのみに対して有効
	- テーマは指定したView(Activity,Application)及びその子孫Viewに対しても有効である。
- 参照方法の違い
	- スタイルはレイアウトxmlの対象のViewから、`style="@style/xxx"`で参照する
	- テーマはレイアウトxmlの対象のViewから、 `android:theme="@style/xxx"` で参照する。または、Manifestファイルの`<application>` タグ or `<activity>` タグから、`android:theme="@style/xxx"`で参照する。
- テーマにはOverlayという仕組みがある
	- Overlayとは、先祖ViewGroupのテーマを活かしつつ、自分のView及び、子孫Viewでは一部をオーバーライドしたテーマを適用すること
	- スタイルはそもそも自分のViewにしか適用されないため、先祖Viewのテーマを自分や子孫Viewに適用することはできない
- スタイル属性とテーマ属性（`<style><item name="xxx"/>`の`xxx`の部分）は異なる性質のものである。
	- スタイル属性は、個別のViewやViewGroupに属するローカル変数のようなものである。
		- そのため、ViewやViewGroupごとに設定することができる属性である。
		- 各View/ViewGroupドキュメントのXML Attributeに記載されている属性はこれである。
		- 例：backgroundColor属性
	- テーマ属性は、アプリ全体で参照できるグローバル変数のようなものである。
		- そのため、ViewやViewGroupごとに設定することはできない属性である。
		- おそらく、個別のViewやViewGroupのスタイル属性(backgroundColor属性など)は、デフォルト値としてテーマ属性を参照しているので、何も設定しないとデフォルトでテーマに沿った見た目の表示となる。
		- 設定できる属性一覧のドキュメントは見つからなかった。xmlレイアウトファイル内で実際に `?attr/colorPrimary` などを記述し、そこからリンクへジャンプして確認すれば少しは役に立ちそう。
		- 例：colorPrimary属性
- テーマはインターフェースのようなもの
	- 複数のテーマを作成しておき、そのViewに与えるテーマを切り替えることよって、そのViewの見た目の表示をガラッと変えることができる。
	- テーマを切り替えることで通常のテーマとダークテーマの切り替えなどを可能にする。
	- テーマは単なるインターフェースであり、実際のリソース( `<color ...>` や `<string ...>` など)が、実際の実装（値）である。
	- テーマから参照するリソースに意味（セマンティック）名を付けるのはよくない。例えば、青色なら`blue`とするべきであって、`primaryColor`とするべきではない。
		- テーマ自身のテーマ属性はセマンティックな名前で定義されている。これは問題ない。
		- セマンティック（意味）名とは、それ本来の意味に加えて、使用用途の名前など、付加的な意味の名前のことである。


## スタイルとテーマの共通部分

- 定義の仕方が同じ
	- Styles.xmlに同じように定義することができる。


## styles.xmlファイル内でスタイルとテーマを区別するための命名規則

以下は、公式でサンプルとして提示された命名規則です。  
これはplatformAPIやAndroidxと同様の命名規則です。

```xml
<!-- 基本フォーマット -->
<!-- 1.Theme/Widget/TextAppearance/ThemeOverlay/ShapeAppearance -->
<!-- 2.アプリ名/モジュール名 -->
<!-- 3.(ウィジェットの場合のみ)ウィジェットのクラス名 -->
<!-- 4.そのテーマ or スタイルを表す任意の名前 -->
<!-- 5.以降、さらに細かいテーマ or スタイルに分類される場合は、そのテーマ or スタイルを表す任意の名前をピリオドで区切りながら続ける。 -->

<!-- テーマ : Theme.アプリ名.基本色 -->
<style name="Theme.AppName.Blue"></style>
<!-- スタイル : Widget.アプリ名.ウィジェット名.基本色 -->
<style name="Widget.AppName.Toolbar.Green"></style>
```


## styles.xmlの肥大化を防ぐためにファイルを分割する

公式で推奨された分割方法は以下の通りです。

themes.xml -> Theme,ThemeOverlay  
type.xml -> TextAppearances,テキストサイズのdimensions,フォントファイルなど  
styles.xml -> ウィジェットのstyle属性に指定するstyleのみ

上記以外はリソースタイプをファイル名とします。

dimens.xml, colors.xml, strings.xml, ...

さらに細かく分類する場合は、

shapes.xml -> shapeの見た目に使用される全てのリソース  
sys_ui.xml -> システムUIの見た目に使用される全てのリソース( `<boolean ...>` や `<color ...>` やナビゲーションバーやステータスバーの色など)


## スタイル属性とテーマ属性の見分け方

- 文法的にはスタイル属性もテーマ属性も同じ
  - `<style>`タグで囲って、`<item>`タグで属性と値をセットする
- `<style>`属性の継承元をどんどんたどっていき、どこかでテーマを継承していればそれはテーマ属性である。
- テーマ属性を継承していない場合はスタイル属性である。
- 継承元の`<style>`の名前が`Theme`で始まるかどうかで判断できる。


## テーマ属性のデフォルト値の調べ方

Android Studioでファイル名検索（Windowsなら`Ctrl + Shift + n`）で、`themes.xml`を検索し、開けば、そこにデフォルト値が定義されているはず。  
もしくは、テーマの継承元をたどっていくと、`appcompat-version\res\values\values.xml`に辿り着くので、そのファイル内でテーマ属性名で検索すればデフォルト値が定義されているはず。


## まとめ

- リソースを参照する時は、テーマ属性を参照すること
- テーマの定義として個別のリソースを参照すること
- `name`属性には、命名規則に沿った名前にすること
