- [関数型](#関数型)
  - [概要](#概要)
  - [文法](#文法)
  - [戻り値を返さない場合は Unit を明示する](#戻り値を返さない場合は-unit-を明示する)
  - [レシーバ付き関数リテラル用の関数型](#レシーバ付き関数リテラル用の関数型)
  - [suspend 修飾子付き関数の関数型](#suspend-修飾子付き関数の関数型)
  - [引数に名前を付けると呼び出し時のヒントとして表示される](#引数に名前を付けると呼び出し時のヒントとして表示される)
  - [Null 許容な関数型](#null-許容な関数型)
  - [関数型の入れ子も可能](#関数型の入れ子も可能)
  - [関数型が推測できる場合は型を省略可能](#関数型が推測できる場合は型を省略可能)
  - [関数型のエイリアスを登録する](#関数型のエイリアスを登録する)
  - [関数型に代入するインスタンスを生成する方法](#関数型に代入するインスタンスを生成する方法)
    - [コードブロックを用いた方法](#コードブロックを用いた方法)
    - [Callable Reference（リフレクション）を用いた方法](#callable-referenceリフレクションを用いた方法)
    - [関数型をインターフェースとしてクラスに実装する方法](#関数型をインターフェースとしてクラスに実装する方法)
  - [関数型インスタンスを呼び出す](#関数型インスタンスを呼び出す)


# 関数型

## 概要

関数型とは、関数をオブジェクトとして扱う際に、その引数の型と戻り値の型を定義した型のことです。


## 文法

```
レシーバの型.(引数の型, 引数の型) -> 戻り値のがた
```

レシーバの型は必須ではありません。  
引数がない場合は丸カッコのみを残します。


## 戻り値を返さない場合は Unit を明示する

戻り値を返さない場合は Unit を明示する必要があります。  
Unit を省略することはできません。


## レシーバ付き関数リテラル用の関数型

以下のような関数型の場合は、 `String` クラスの拡張関数であり、  
引数に `Int` 型を持ち、戻り値が `Boolean` 型の関数であることを示します。

```
String.(Int) -> Boolean
```


## suspend 修飾子付き関数の関数型

`suspend` 修飾子付き関数の関数型には、 `suspend` を付与する必要があります。

```
// 例 1
suspend () -> Unit
// 例 2
suspend A.(B) -> C
```


## 引数に名前を付けると呼び出し時のヒントとして表示される

```kotlin
var increment: (input: Int) -> Int = { i -> i + 1 }

fun main() {
    increment(1) // '(' と '1' の間に input と表示される
}
```


## Null 許容な関数型

Null 許容な関数型を定義したい場合には、 `?` マークが関数型全体にかかるように  
関数型全体をカッコ `()` で囲むことを忘れないでください。

```
((Int, Int) -> Int)?
```


## 関数型の入れ子も可能

関数型は、カッコを使って以下のように入れ子で定義することも可能です。

```
(Int) -> ((Int) -> Unit)
```

矢印記号 `->` は、カッコで優先順位が指定されていない場合は、右側の矢印が優先されます。  
以下の 2 つの例は同じ意味になります。

```
(Int) -> ((Int) -> Unit)

(Int) -> (Int) -> Unit
```

なお、公式ドキュメントでは、例として `((Int) -> (Int)) -> Unit` のような型が記載されていますが、戻り値の型に丸カッコ `()` が付与されても問題ないようです。戻り値の型の丸カッコは、あってもなくても同じ関数型を意味するようです。実験した結果、次のような記述はコンパイルエラーにはなりませんでした。

```kotlin
var c: (Int) -> (Int) = { cArg -> cArg + 1 }
var d: (Int) -> Int = { dArg -> dArg + 1 }
c = d // OK
d = c // OK
```


## 関数型が推測できる場合は型を省略可能

関数型が推測できる場合は、関数型を省略することが可能です。

```kotlin
// increment1 は (Int) -> Int 型であることが推定できます。
val increment1 = { i: Int -> i + 1 }

// コンパイルエラー
// 関数型が推測できないので、関数型の記述を省略することはできません
var increment2 = { i -> i + 1 }

// 関数型が省略できないため明示する。
var increment3: (Int) -> Int = { i -> i + 1 }

// 関数型が推測できるため、関数型の記述を省略することができます
val sum = { 1 + 2 }
```


## 関数型のエイリアスを登録する

`typealias` 修飾子を使用して、関数型のエイリアスを登録することが可能です。エイリアスを登録することで、同じ関数型を繰り返し使用する場合には、簡潔な記述が可能になります。

エイリアスはパッケージレベルにのみ登録が可能です。

```kotlin
typealias IntToInt = (Int) -> Int

class KotlinClass {

    // 関数型が省略できないず、同じ関数型が複数箇所で使用される場合は、エイリアスがあると便利です。
    var increment1: IntToInt = { i -> i + 1 }

}
```

エイリアスだけを登録したファイルがあると便利だなと思います。


## 関数型に代入するインスタンスを生成する方法

### コードブロックを用いた方法

関数型に代入するインスタンスを生成するには、ラムダ式か無名関数を使用します。

```kotlin
// ラムダ式
{ a, b -> a + b }

// 無名関数
fun(s: String): Int { return s.toIntOrNull() ?: 0 }
```


### Callable Reference（リフレクション）を用いた方法

Callable Reference (リフレクション) を用いた方法は、関数参照、プロパティ参照、コンストラクタ参照のことを示します。

```kotlin
// -------------
// 関数参照の例
// -------------
// 奇数なら true, 偶数なら false を返す関数
fun isOdd(x: Int) = x % 2 != 0
val numbers = listOf(1, 2, 3)
println(numbers.filter(::isOdd)) // [1, 3]

// -------------
// プロパティ参照の例
// -------------
val strs = listOf("a", "bc", "def")
println(strs.map(String::length)) // [1, 2, 3]

// -------------
// コンストラクタ参照の例
// -------------
data class Person(val name: String)

val names = listOf("Alice", "Bob", "Charlie")
// List<String> を List<Person> に変換
val people = names.map(::Person)
println("result = ${people}")
// result = [Person(name=Alice), Person(name=Bob), Person(name=Charlie)]
```


### 関数型をインターフェースとしてクラスに実装する方法

```kotlin
class IntTransformer: (Int) -> Int {
    override operator fun invoke(x: Int): Int = x * 2
}

val intFunction: (Int) -> Int = IntTransformer()
intFunction(3) // 6
```

`invoke` 関数は、関数名なしで、 「インスタンス名 + カッコ `()` 」 のみで関数を呼び出せる仕組みです。


## 関数型インスタンスを呼び出す

関数型の値は `invoke()` 演算子を使用するか、カッコ `()` のみで呼び出すことが可能です。

```kotlin
val f: (Int) -> Int = { x -> x + 1 }

// invoke 演算子で呼び出し
f.invoke(x)
// カッコのみで呼び出し
f(x)
```

もし、値がレシーバー型を持っていたら、レシーバーオブジェクトが第一引数に渡される必要があります。もしくは、拡張関数のように、関数呼び出しのプリフィックスとして付与する必要があります。

```kotlin
val stringPlus: (String, String) -> String = String::plus
val intPlus: Int.(Int) -> Int = Int::plus

println(stringPlus.invoke("<-", "->")) // <-->
println(stringPlus("Hello, ", "world!")) // Hello, world!

println(intPlus.invoke(1, 1)) // 2
println(intPlus(1, 2)) // 3
println(2.intPlus(3)) // 5
```





