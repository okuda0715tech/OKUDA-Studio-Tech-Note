- [拡張関数のレシーバーの第一引数化](#拡張関数のレシーバーの第一引数化)
  - [関数型のプロパティ同士なら相互変換が可能](#関数型のプロパティ同士なら相互変換が可能)
  - [関数型を省略した場合の型推論](#関数型を省略した場合の型推論)
  - [レシーバーを第一引数化した関数型を明示的に指定できるのかどうか](#レシーバーを第一引数化した関数型を明示的に指定できるのかどうか)
  - [関数型はレシーバー付きで定義した方が良い](#関数型はレシーバー付きで定義した方が良い)
  - [レシーバーを第一引数に渡して関数呼び出し](#レシーバーを第一引数に渡して関数呼び出し)


# 拡張関数のレシーバーの第一引数化

## 関数型のプロパティ同士なら相互変換が可能

「関数型のプロパティ」 とは、以下のようなプロパティの型が関数型のプロパティのことを示しています。

```kotlin
val a: () -> Unit
```

```kotlin
// 無名拡張関数なので、 Int.(Int) -> Int 型に推論される
val sumFunction = fun Int.(p1: Int): Int {
    return this + p1
}

// 関数型のプロパティ同士なら、レシーバーと第一引数の相互変換が可能
// レシーバーを第一引数化
val noReceiver: (Int, Int) -> Int = sumFunction
// 第一引数をレシーバー化
val withReceiver: Int.(Int) -> Int = noReceiver
```

この性質を利用すれば、通常の関数を拡張関数のようにレシーバー付きで呼び出すことも可能になります。


## 関数型を省略した場合の型推論

拡張関数をプロパティに代入する際に、関数型を省略した場合、どのような関数型になるでしょうか。  
それは、プロパティに代入するものが、 **「関数参照」** か **「無名拡張関数」** かによって異なり、  
以下のようになります。

- 関数参照ならば、レシーバーが第一引数化された関数型
  - 例 : (Int, String) -> Boolean
- 無名拡張関数ならば、レシーバー付きの関数型
  - 例 : Int.(String) -> Boolean

サンプルコードを以下に載せておきます。

```kotlin
// 拡張関数
fun Int.mySumFunction(i: Int): Int {
    return this + i
}

// 関数参照の場合
// 関数型を省略した場合は、レシーバーが第一引数化された型に解決されます。
// 以下の場合 (Int, Int) -> Int 型となります。
// (※ 1 )
val mySum1 = Int::mySumFunction

// 無名拡張関数の場合
// 関数型を省略した場合は、レシーバー付きの型になります。
// 以下の場合 Int.(Int) -> Int 型となります。
val mySum2 = fun Int.(i: Int): Int = this + i
```

(※ 1 )  
後述しますが、できるだけレシーバー付きの関数型を明示的に指定した方が良いです。

なお、ラムダ式で関数のインスタンスを生成する場合は、レシーバーを定義することができないため、必ずレシーバーが第一引数化された関数型になります。


## レシーバーを第一引数化した関数型を明示的に指定できるのかどうか

拡張関数をプロパティに代入する際に、関数型を明示的に指定できるのかどうかは、  
プロパティに代入するものが、 **「関数参照」** か **「無名拡張関数」** かによって異なり、  
以下のようになります。

- 関数参照ならば、レシーバー付きの関数型 or レシーバーを第一引数化した関数型のいずれかを任意に指定可能
  - 例 : Int.(String) -> Boolean
  - 例 : (Int, String) -> Boolean
- 無名拡張関数ならば、レシーバー付きの関数型のみ指定可能
  - 例 : Int.(String) -> Boolean

サンプルコードを以下に載せておきます。

```kotlin
// 拡張関数
fun Int.mySumFunction(i: Int): Int {
    return this + i
}

// 関数参照の場合 1 ( OK )
// レシーバー付きの型
// レシーバー付きの型にすることで、後述するレシーバー付きの関数呼び出しが可能になります。
val mySum1: Int.(Int) -> Int = Int::mySumFunction

// 関数参照の場合 2 ( OK )
// レシーバーが第一引数化された型
val mySum2: (Int, Int) -> Int = Int::mySumFunction

// 無名拡張関数の場合 1 ( OK )
// レシーバー付きの型
val mySum3: Int.(Int) -> Int = fun Int.(i: Int): Int = this + i

// 無名拡張関数の場合 2 ( NG )
// レシーバーが第一引数化された型
val mySum4: (Int, Int) -> Int = fun Int.(i: Int): Int = this + i
// ただし、レシーバー付きの型で定義した変数を
// レシーバーが第一引数化された型で定義した変数に
// 代入することは可能
val mySum5: (Int, Int) -> Int = mySum3
```


## 関数型はレシーバー付きで定義した方が良い

関数型の定義方法によって、同じ関数でも関数呼び出しの方法に一部制限がかかります。  

まずは、以下のコードを見てください。

```kotlin
// 拡張関数
fun Int.mySumFunction(i: Int): Int {
    return this + i
}

// レシーバー付き関数型のプロパティの場合は、 2 種類の関数呼び出しが可能
val mySum: Int.(Int) -> Int = Int::mySumFunction
// OK
1.mySum(2)
// OK
mySum(1, 2)

// レシーバーを第一引数化した関数型のプロパティの場合は、 1 種類の関数呼び出しのみ可能
val mySum2: (Int, Int) -> Int = Int::mySumFunction
// NG
1.mySum2(2)
// OK
mySum2(1, 2)
```

レシーバー付きの関数型を持った拡張関数は、  
2 種類の関数呼び出しが可能なのに対し、  
レシーバーを第一引数化した関数型を持った拡張関数は、  
1 種類の方法でしか、関数を呼び出すことができません。  
そのため、関数型は可能ならば **レシーバー付き関数型** で定義する方が良いでしょう。

上記の内容を表にまとめると、以下のようになります。

|         *関数型の定義方法*         | *レシーバー付きの関数呼び出し* | *レシーバーを第一引数化した関数呼び出し* |
| :--------------------------------: | ------------------------------ | ---------------------------------------- |
|      *レシーバー付きの関数型*      | ○                              | ○                                        |
| *レシーバーを第一引数化した関数型* | ×                              | ○                                        |


## レシーバーを第一引数に渡して関数呼び出し

本来は、拡張関数を実行する際に、レシーバーを第一引数として渡すことはできません。

```kotlin
fun Int.mySumFunction(i: Int): Int {
    return this + i
}

// NG
Int.mySumFunction(1, 2)
// OK
1.mySumFunction2(2)
```

しかし、 **拡張関数を一旦プロパティに代入している場合は、  
レシーバーを第一引数として渡すことが可能** になります。

```kotlin
// 拡張関数
fun Int.mySumFunction(i: Int): Int {
    return this + i
}

// レシーバーを第一引数化した関数型の場合はもちろん OK
val mySum: (Int, Int) -> Int = Int::mySumFunction
// OK
mySum(1, 2)

// レシーバー付き関数型の場合でも OK
val mySum2: Int.(Int) -> Int = Int::mySumFunction
// OK
mySum2(1, 2)

// レシーバー付き関数型、かつ、無名拡張関数の代入の場合でも OK
val mySum3: Int.(Int) -> Int = fun Int.(i: Int): Int = this + i
// OK
mySum3(1, 2)
```




