- [インライン関数](#インライン関数)
  - [概要](#概要)
  - [インライン化の例](#インライン化の例)
    - [インライン化していない場合](#インライン化していない場合)
    - [インライン化した場合](#インライン化した場合)
  - [ラムダ式もインライン化される](#ラムダ式もインライン化される)
  - [ラムダ式をインライン化の対象から除外する（ noinline ）](#ラムダ式をインライン化の対象から除外する-noinline-)
  - [ラムダ式内での return](#ラムダ式内での-return)
    - [ラムダ式内でのラベルのない return は基本的には禁止](#ラムダ式内でのラベルのない-return-は基本的には禁止)
    - [ラムダ式内での return が可能になる](#ラムダ式内での-return-が可能になる)
  - [クロスインライン（ crossinline ）](#クロスインライン-crossinline-)
  - [具体的な型パラメータ](#具体的な型パラメータ)
    - [概要](#概要-1)
    - [例](#例)
    - [リフレクションと具体的な型パラメータを同時に使用する](#リフレクションと具体的な型パラメータを同時に使用する)
  - [パブリック API インライン関数を制限する](#パブリック-api-インライン関数を制限する)


# インライン関数

## 概要

関数の修飾子に `inline` を付与することで、その関数はインライン関数になります。インライン関数は、関数の呼び出し側に展開されます。そのため、、コールスタックに積む作業が不要になったり、関数オブジェクトをメモリに割り当てる必要がなくなり、実行時のパフォーマンスが向上します。


## インライン化の例

### インライン化していない場合

Kotlin コード

```kotlin
fun main(args: Array<String>): Unit {
    hello()
}

private inline fun hello() {
    print("Hello")
}
```

コンパイルされたコード

```java
public final class InlineKt {
    public static final void main(@NotNull String[] args) {
        Intrinsics.checkParameterIsNotNull(args, "args");
        // -------------------------------------------
　　　  // 関数呼び出さずに関数の内容をそのまま実行している
        // -------------------------------------------
        String var1 = "Hello";
        System.out.print(var1);
        // -------------------------------------------
    }

    private static final void hello() {
        String var1 = "Hello";
        System.out.print(var1);
    }
}
```


### インライン化した場合

Kotlin コード

```kotlin
fun main(args: Array<String>): Unit {
    val sum = plus(10, 10)
    println(sum)
}

private inline fun plus(a: Int, b: Int) : Int{
    return a + b
}
```

コンパイルされたコード

```java
// ちょっと足りていないところがあるかもしれませんが、
// あまり気にせず、「インライン化」のイメージをつかめれば OK です。

public final class InlineFuncKt {
    public static final void main(@NotNull String[] args) {
        Intrinsics.checkParameterIsNotNull(args, "args");
        // -------------------------------------------
        // plus 関数がインライン化されている
        // -------------------------------------------      
        byte a$iv = 10;
        int b$iv = 10;
        int sum = a$iv + b$iv;
        // -------------------------------------------
        System.out.println(sum);
    }

    private static final int plus(int a, int b) {
        return a + b;
    }
}
```


## ラムダ式もインライン化される

inline 修飾子は、インライン関数の引数に渡したラムダ式もインライン化されます。

```kotlin
fun main(args: Array<String>): Unit {
    val obj: Lock = ReentrantLock()
    lock(obj) {
        println("Hello")
    }
}

private inline fun lock(l : Lock, body: () -> Unit) {
    l.lock()
    try {
        // この body() 関数の呼び出しもインライン化されます。
        return body()
    }
    finally {
        l.unlock()
    }
}
```


## ラムダ式をインライン化の対象から除外する（ noinline ）

インライン関数の引数に渡したラムダ式に `noinline` 修飾子を付与することで、ラムダ式をインライン化の対象から除外することが可能です。

```kotlin
fun main(args: Array<String>): Unit {
    val obj: Lock = ReentrantLock()
    lock(obj) {
        println("Hello")
    }
}

private inline fun lock(l : Lock, noinline body: () -> Unit) {
    l.lock()
    try {
        return body()
    }
    finally {
        l.unlock()
    }
}
```


## ラムダ式内での return

return による制御の基本は、別紙に記載しているため、そちらも合わせて参照してください。

`Kotlin -> 制御の管理 -> リターンとジャンプ`


### ラムダ式内でのラベルのない return は基本的には禁止

ラムダ式内で、ラベルの付いていない return は禁止されています。なぜなら、ラムダ式の外側の関数を抜け出すことができないためです。

```kotlin
// インライン関数ではない関数
fun ordinaryFunction(block: () -> Unit) {
    println("hi!")
}

fun foo() {
    ordinaryFunction {
        // ここでの return はエラーになります。
        // foo() を抜けることはできません。
        return
    }
}
```

ただし、後述する通り、ラムダ式を引数にとる関数がインライン関数の場合は、修飾子なしの return が許可されています。


### ラムダ式内での return が可能になる

インライン関数に渡すラムダ式がインライン化されると、そのラムダ式内で return することが可能になります。 return すると、そのラムダ式を実際に実行している関数から抜け出します。

```kotlin
fun main(args: Array<String>): Unit {
    val obj: Lock = ReentrantLock()

    println("Start")

    inlineLock(obj) {
        // return が可能です。
        // main() 関数から抜けます。
        // ただし、このラムダ式が main 関数にインライン化されていない場合、retunr はできません。
        return
    }

    // return でこの関数から既に抜け出しているため、
    // この End は出力されません。
    println("End")
}

private inline fun inlineLock(l : Lock, body: () -> Unit) {
    l.lock()
    try {
        return body()
    }
    finally {
        l.unlock()
    }
}
```


## クロスインライン（ crossinline ）

インライン関数の中で非同期の関数が定義される場合もあるでしょう。その場合、そのままでは、非同期の関数内から、インライン関数に渡されたラムダ式を呼び出すことはできません。そのような場合には、ラムダ式に `crossinline` 修飾子を付与します。 crossinline は、ラムダ式内で非ローカルリターンを使用していないことを示すマーカーです。

```kotlin
private inline fun crossinlineLambda(crossinline  lambda: () -> Unit)
{
    val f = object : Runnable {
        override fun run() {
            // crossline にしたことで呼び出せるようになります。
            lambda()
        }
    }

    {
        // crossline にしたことで呼び出せるようになります。
        lambda()
    }.invoke()

    // crossinline が付与されていても、引き続き、インライン関数の直下で呼び出せます。
    lambda()
}
```


## 具体的な型パラメータ

### 概要

具体的な型パラメータ ( Reified type parameters ) を使用すると、リフレクションの使用を抑えることができます。


### 例

以下のコードを具体的な型パラメータを使用して書き換えたいと思います。これは、クラスツリーをさかのぼっていき、一致する型を見つける関数です。

```kotlin
fun <T> TreeNode.findParentOfType(clazz: Class<T>): T? {
    var p = parent
    while (p != null && !clazz.isInstance(p)) {
        p = p.parent
    }
    @Suppress("UNCHECKED_CAST")
    return p as T?
}
```

この関数は次のように呼び出します。

```kotlin
treeNode.findParentOfType(MyTreeNode::class.java)
```

これらを具体的な型パラメータを使用して書き直すと以下のようになります。

```kotlin
// inline 関数の場合のみ型パラメータを reified 修飾子で修飾できます。
inline fun <reified T> TreeNode.findParentOfType(): T? {
    var p = parent
    while (p != null && p !is T) {
        p = p.parent
    }
    return p as T?
}
```

関数の呼び出し側は、以下のようになります。

```kotlin
treeNode.findParentOfType<MyTreeNode>()
```

具体的な型パラメータで書き換えたことにより、リフレクションを使用しなくて済むようになったことがわかります。また、型チェックで is が使えるようになっています。


### リフレクションと具体的な型パラメータを同時に使用する

リフレクションと具体的な型パラメータを同時に使用することも可能です。

```kotlin
inline fun <reified T> membersOf() = T::class.members

fun main(s: Array<String>) {
    println(membersOf<StringBuilder>().joinToString("\n"))
}
```

```
実行結果

fun java.lang.StringBuilder.toString(): kotlin.String
fun java.lang.StringBuilder.append(kotlin.Char): java.lang.StringBuilder!
fun java.lang.StringBuilder.append(kotlin.Double): java.lang.StringBuilder!
fun java.lang.StringBuilder.append(kotlin.Float): java.lang.StringBuilder!
fun java.lang.StringBuilder.append(kotlin.Int): java.lang.StringBuilder!
fun java.lang.StringBuilder.append(kotlin.Long): java.lang.StringBuilder!
...
```


## パブリック API インライン関数を制限する

インライン関数が public または protected であるが、 private または internal 宣言の一部ではない場合、その関数はモジュールのパブリック API とみなされます。 これは他のモジュールで呼び出すことができ、そのような呼び出し側でもインライン化されます。

これにより、変更後に呼び出し側モジュールが再コンパイルされなかった場合に、インライン関数を宣言するモジュールの変更によってバイナリの非互換性が生じる一定のリスクが生じます。

モジュールの非パブリック API の変更によってこのような非互換性が生じるリスクを排除するために、パブリック API インライン関数は、本体内で非パブリック API 宣言 (つまり private 宣言と internal 宣言およびその一部) を使用することを許可されません。

内部宣言には @PublishedApi アノテーションを付けることができ、これによりパブリック API インライン関数での使用が可能になります。 内部インライン関数が @PublishedApi としてマークされている場合、その関数の本体もパブリックであるかのようにチェックされます。






