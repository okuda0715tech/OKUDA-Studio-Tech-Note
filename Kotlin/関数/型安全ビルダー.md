- [型安全ビルダー](#型安全ビルダー)
  - [仕組み](#仕組み)
  - [スコープ制御: @DslMarker](#スコープ制御-dslmarker)
  - [com.example.html パッケージの完全な定義](#comexamplehtml-パッケージの完全な定義)


# 型安全ビルダー

適切に名前付けされた関数をビルダーとして使用し、レシーバー付きの関数リテラルと組み合わせて使用​​することで、Kotlin で型安全で静的に型付けされたビルダーを作成できます。

型安全なビルダーを使用すると、複雑な階層型データ構造を半宣言的に構築するのに適した Kotlin ベースのドメイン固有言語 (DSL) を作成できます。ビルダーのサンプル使用例は次のとおりです。

- HTML や XML などの Kotlin コードでマークアップを生成する

- Web サーバーのルートを構成する: [Ktor](https://ktor.io/docs/routing.html?_gl=1*1ricc38*_gcl_au*Njk2NDUzMTQ0LjE3MTc2ODQyNzk.*_ga*MTg3MzcxODE5MC4xNjkzNzExNTg2*_ga_9J976DJZ68*MTcyMzcwMjcyMi4yNjMuMS4xNzIzNzAyNzgwLjIuMC4w)

次のコードを検討してください。

```kotlin
import com.example.html.* // see declarations below

fun result() =
    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
        body {
            h1 {+"XML encoding with Kotlin"}
            p  {+"this format can be used as an alternative markup to XML"}

            // an element with attributes and text content
            a(href = "https://kotlinlang.org") {+"Kotlin"}

            // mixed content
            p {
                +"This is some"
                b {+"mixed"}
                +"text. For more see the"
                a(href = "https://kotlinlang.org") {+"Kotlin"}
                +"project"
            }
            p {+"some text"}

            // content generated by
            p {
                for (arg in args)
                    +arg
            }
        }
    }
```

これは完全に正当な Kotlin コードです。 [このコードをオンラインで試すことができます (変更してブラウザで実行します)。](https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder?_gl=1*1s7j8fj*_gcl_au*Njk2NDUzMTQ0LjE3MTc2ODQyNzk.*_ga*MTg3MzcxODE5MC4xNjkzNzExNTg2*_ga_9J976DJZ68*MTcyMzcwMjcyMi4yNjMuMS4xNzIzNzAzMDY2LjcuMC4w)


## 仕組み

Kotlin で型安全なビルダーを実装する必要があると仮定します。まず、構築するモデルを定義します。この場合、HTML タグをモデル化する必要があります。これは、一連のクラスで簡単に実行できます。たとえば、HTML は、 `<head>` や `<body>` などの子を定義する `<html>` タグを記述するクラスです。( [以下の宣言](#comexamplehtml-パッケージの完全な定義) を参照してください。)

では、コードで次のように記述できる理由を思い出してみましょう。

```kotlin
html {
    // ...
}
```

html は実際にはラムダ式を引数として受け取る関数呼び出しです。この関数は次のように定義されます。

```kotlin
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```

この関数は、それ自体が関数である init という 1 つのパラメータを取ります。関数の型は HTML.() -> Unit で、これはレシーバーを持つ関数型です。つまり、関数に HTML 型 (レシーバー) のインスタンスを渡す必要があり、関数内でそのインスタンス (レシーバー) のメンバーを呼び出すことができます。

レシーバーには、this キーワードを使用してアクセスできます。

```kotlin
html {
    this.head { ... }
    this.body { ... }
}
```

(head と body は HTML のメンバー関数です。)

通常どおり、これを省略すると、ビルダーによく似たものが得られます。

```kotlin
html {
    head { ... }
    body { ... }
}
```

では、この呼び出しは何をしますか? 上で定義した html 関数の body を見てみましょう。HTML の新しいインスタンスを作成し、引数として渡された関数を呼び出してそれを初期化し (この例では、HTML インスタンスで head と body を呼び出すことになります)、このインスタンスを返します。これはまさにビルダーが行うべきことです。

HTML クラスの head 関数と body 関数は、html と同様に定義されています。唯一の違いは、構築されたインスタンスを囲む HTML インスタンスの children コレクションに追加することです。

```kotlin
fun head(init: Head.() -> Unit): Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -> Unit): Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}
```

実際、これら 2 つの関数はまったく同じことを実行するため、汎用バージョンの initTag を使用できます。

```kotlin
protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
    tag.init()
    children.add(tag)
    return tag
}
```

これで、関数は非常にシンプルになりました。

```kotlin
fun head(init: Head.() -> Unit) = initTag(Head(), init)

fun body(init: Body.() -> Unit) = initTag(Body(), init)
```

また、これらを使用して `<head>` タグと `<body>` タグを構築できます。

ここで説明するもう 1 つの点は、タグ本体にテキストを追加する方法です。上記の例では、次のように記述します。

```kotlin
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
```

つまり、基本的にはタグ本体内に文字列を配置するだけですが、その前に小さな + があるため、プレフィックス unaryPlus() 操作を呼び出す関数呼び出しになります。この操作は、実際には TagWithText 抽象クラス (Title の親) のメンバーである拡張関数 unaryPlus() によって定義されます。

```kotlin
operator fun String.unaryPlus() {
    // this はレシーバー。
    // つまり、レシーバーで渡されてくる文字列。
    children.add(TextElement(this))
}
```

したがって、ここでプレフィックス + が行うことは、 String を TextElement のインスタンスでラップし、それを子コレクションに追加して、タグツリーの一部にすることです。

これらすべては、上記のビルダー例の先頭にインポートされるパッケージ com.example.html で定義されています。最後のセクションでは、このパッケージの完全な定義を読むことができます。


## スコープ制御: @DslMarker

DSL を使用すると、コンテキスト内で呼び出すことができる関数が多すぎるという問題に遭遇したことがあるかもしれません。ラムダ内で利用可能なすべての暗黙的なレシーバーのメソッドを呼び出すことができるため、 head タグ内に head タグを記述するように、一貫性のない結果が返されます。

```kotlin
html {
    head {
        head {} // 禁止されるべき
    }
    // ...
}
```

この例では、最も近い暗黙的なレシーバー this@head のメンバーのみが使用可能である必要があります。head() は外側のレシーバー this@html のメンバーであるため、これを呼び出すことは違法です。

この問題に対処するために、レシーバーのスコープを制御する特別なメカニズムがあります。

コンパイラーがスコープの制御を開始するには、DSL で使用されるすべてのレシーバーの型に同じマーカーアノテーションを付けるだけです。たとえば、HTML ビルダーの場合は、アノテーション `@HTMLTagMarker` を宣言します。

```kotlin
@DslMarker
annotation class HtmlTagMarker
```

アノテーションクラスは、 `@DslMarker` アノテーションが付けられている場合、 **DSL マーカー** と呼ばれます。

DSL では、すべてのタグクラスが同じスーパークラス Tag を拡張します。スーパークラスにのみ @HtmlTagMarker アノテーションを付けるだけで十分であり、その後、 Kotlin コンパイラーは継承されたすべてのクラスをアノテーション付きとして扱います。

```kotlin
@HtmlTagMarker
abstract class Tag(val name: String) { ... }
```

HTML クラスまたは Head クラスに @HtmlTagMarker をアノテーションする必要はありません。それらのスーパークラスにはすでにアノテーションが付けられているからです。

```kotlin
class HTML() : Tag("html") { ... }

class Head() : Tag("head") { ... }
```

このアノテーションを追加すると、Kotlin コンパイラーはどの暗黙的なレシーバーが同じ DSL の一部であるかを認識し、最も近いレシーバーのメンバーのみを呼び出すことができます。

```kotlin
html {
    head {
        head { } // error: a member of outer receiver
    }
    // ...
}
```

外側のレシーバーのメンバーを呼び出すことは可能ですが、そのためにはこのレシーバーを明示的に指定する必要があることに注意してください。

```kotlin
html {
    head {
        // 明示的にレシーバーを指定することで head 関数の
        // 呼び出しが可能になる。
        this@html.head { }
    }
    // ...
}
```


## com.example.html パッケージの完全な定義

これは、パッケージ com.example.html の定義方法です (上記の例で使用されている要素のみ)。HTML ツリーを構築します。拡張関数とレシーバー付きラムダを多用します。

```kotlin
package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent$text\n")
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf<Element>()
    val attributes = hashMapOf<String, String>()

    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent<$name${renderAttributes()}>\n")
        for (c in children) {
            c.render(builder, indent + "  ")
        }
        builder.append("$indent</$name>\n")
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(" $attr=\"$value\"")
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, "")
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText("html") {
    fun head(init: Head.() -> Unit) = initTag(Head(), init)

    fun body(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head : TagWithText("head") {
    fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title : TagWithText("title")

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -> Unit) = initTag(B(), init)
    fun p(init: P.() -> Unit) = initTag(P(), init)
    fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag("body")
class B : BodyTag("b")
class P : BodyTag("p")
class H1 : BodyTag("h1")

class A : BodyTag("a") {
    var href: String
        get() = attributes["href"]!!
        set(value) {
            attributes["href"] = value
        }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```
