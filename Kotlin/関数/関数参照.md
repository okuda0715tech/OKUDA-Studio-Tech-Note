- [関数参照](#関数参照)
  - [概要](#概要)
  - [基本形](#基本形)
  - [関数参照は KFunction を親に持つ](#関数参照は-kfunction-を親に持つ)
  - [オーバーロードされている場合は、型推論を行います](#オーバーロードされている場合は型推論を行います)
  - [バインドされた参照とアンバインドされた参照](#バインドされた参照とアンバインドされた参照)
  - [関数参照の型推論](#関数参照の型推論)
  - [関数参照の応用例](#関数参照の応用例)
    - [関数の合成](#関数の合成)


# 関数参照

## 概要

関数参照は、コロン二つ `::` で行われます。

コロン二つで表現されたコードは、関数への参照を行うだけで、  
その時点では、まだ関数は呼び出されていません。

後からその関数参照を保持しているプロパティを使って、  
あたかもプロパティ名が関数名のようにして関数が呼び出されます。

もしくは、関数参照の直後に関数の引数を渡すことにより、関数が呼び出されます。

また、関数参照を行うことにより、関数を別の関数の引数に渡すことが可能になります。


## 基本形

Kotlin の関数参照を使用する方法は、 Java のメソッド参照と同じです。

コロン二つ ( `::` ) 、かつ、引数なしで関数名を記述すると、  
関数参照を行うことができます。

```kotlin
// 奇数なら true, 偶数なら false を返す関数
fun isOdd(x: Int) = x % 2 != 0

val numbers = listOf(1, 2, 3)

println(numbers.filter(::isOdd)) // [1, 3]
```

コロン二つ ( `::` )  の前には、関数が定義されている場所を示す  
クラス名やインスタンス名 (レシーバ) を指定しますが、  
省略されている場合は、 `this` の指定が省略されています。

関数参照されている関数を実行するには、関数参照の直後に引数用の丸カッコを付与します。  

```kotlin
fun Int.myIncrement(x: Int): Int {
    return x + 1
}

// 関数参照をプロパティに代入
val myInc: Int.(Int) -> Int = Int::myIncrement
// 関数参照している関数を実行 パターン1
1.myInc(2)
// 関数参照している関数を実行 パターン2
myInc(1, 2)

// 関数参照している関数を実行 パターン3
// 参照と同時に実行する場合 (この使用方法はあまりしないとは思うが、参考までに）
(Int::myIncrement)(1, 2)
```


## 関数参照は KFunction を親に持つ

関数参照は `KFunction<out R>` 、もしくは、そのサブタイプを親に持ちます。引数の数ごとにサブタイプは用意されています。

- 引数が一つなら  `KFunction1<T1, R>` 
- 引数が二つなら  `KFunction2<T1, T2, R>` 
- 引数が三つなら  `KFunction3<T1, T2, T3, R>` 


## オーバーロードされている場合は、型推論を行います

オーバーロードされている場合は、型推論が行われ、適切な関数が呼び出されます。

```kotlin
// 奇数かどうかを判定する関数
fun isOdd(x: Int) = x % 2 != 0
// 変わった文字列かどうかを判定する関数
fun isOdd(s: String) = s == "brillig" || s == "slithy" || s == "tove"

// この場合は、引数が Int 型であるため、
// 型推論により isOdd(x: Int) が使用されます。
val predicate: (Int) -> Boolean = ::isOdd

// この場合は、引数が String 型であるため、
// 型推論により isOdd(x: String) が使用されます。
val predicate: (String) -> Boolean = ::isOdd

// このような型推論も可能です。
val numbers = listOf(1, 2, 3)
// isOdd(x: Int) であると推論されます。
println(numbers.filter(::isOdd))
```


## バインドされた参照とアンバインドされた参照

コロン二つの前に、 **インスタンス** が指定されている関数参照を **バインドされた参照** と呼び、 **クラス** が指定されている関数参照を **アンバインドされた参照** と呼びます。

```kotlin
// バインドされた参照
val isNumber: (CharSequence) -> Boolean = numberRegex::matches

// アンバインドされた参照
val matches: (Regex, CharSequence) -> Boolean = Regex::matches
```

バインドされた参照は、その参照にレシーバーの情報を含んでいます。  
そのため、その関数参照を格納するプロパティの関数型にはレシーバーは含みません。

逆に、アンバインドされた参照は、その参照にレシーバーの情報を含んでいません。  
そのため、その関数参照を格納するプロパティの関数型にはレシーバーが必要になります。

コロン二つ ( `::` )  の前にクラス名もインスタンス名も指定されていない場合は、 `this` の指定が省略されています。


## 関数参照の型推論

アンバインドされた関数参照を 「関数型を明示していない変数」 に代入した場合、レシーバーが第一引数化された型に推論されます。

以下の例では、拡張関数の場合ですが、アンバインドされたメンバー関数の場合も同様です。

```kotlin
// 拡張関数 (メンバー関数の場合も同様です。)
fun Int.mySumFunction(i: Int): Int {
    return this + i
}

// (Int, Int) -> Int 型に推論されます。
val mySum1 = Int::mySumFunction
```

詳しくは、別紙 「拡張関数のレシーバーの第一引数化.md 」 で取り上げていますが、レシーバーを第一引数化した関数型よりも、レシーバーをレシーバーとして定義した関数型の方が利便性が高いです。関数型を明示することで、レシーバーをレシーバーとして定義した関数型にすることができます。

```kotlin
// Int.(Int) -> Int 型に推論されます。
val mySum1: Int.(Int) -> Int = Int::mySumFunction
```

レシーバー付きで定義された関数型は、レシーバー付きで関数呼び出しすることもできるし、レシーバーを第一引数として関数呼び出しすることもできます。一方で、レシーバーが第一引数化された関数型は、レシーバー付きで関数呼び出しを行うことができません。


## 関数参照の応用例

### 関数の合成

次の関数について考えてみましょう。

```kotlin
// この関数はライブラリに用意されているものではないため、自分で作成する必要があります。
fun <A, B, C> compose(f: (B) -> C, g: (A) -> B): (A) -> C {
    return { x -> f(g(x)) }
}
```

`compose()` 関数は、渡された二つの関数を連続して実行した結果を返します。  
これを関数参照を使用して実装すると、以下のようになります。

```kotlin
fun isOdd(x: Int) = x % 2 != 0
fun length(s: String) = s.length

val oddLength = compose(::isOdd, ::length)
val strings = listOf("a", "ab", "abc")

println(strings.filter(oddLength)) // ["a", "abc"]
```




