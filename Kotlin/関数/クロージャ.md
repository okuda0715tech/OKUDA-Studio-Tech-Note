- [クロージャ](#クロージャ)
  - [概要](#概要)
  - [クロージャの特徴](#クロージャの特徴)
  - [基本形](#基本形)
  - [内側の関数は生成される度に異なる外側のプロパティを持つ](#内側の関数は生成される度に異なる外側のプロパティを持つ)
  - [Java のクロージャとの違い](#java-のクロージャとの違い)
  - [クロージャのデメリット](#クロージャのデメリット)


# クロージャ

## 概要

関数内で別の関数を定義した際に、内側の関数が外側の関数のプロパティにアクセスできる性質のことをクロージャと呼びます。 (クロージャの定義について明確なものは見つけられておらず、なんとなくこの定義にいきつきました。)


## クロージャの特徴

- 関数内で別の関数を定義した際に、内側の関数が外側の関数のプロパティにアクセスできる
- 内側の関数定義時に外側の関数のプロパティへの参照が渡される
- 本来ならば、関数が終了したらそのローカル変数が保持しているオブジェクトへの参照は失われるが、内部の関数を関数オブジェクトとして保持している間は、そのオブジェクトへの参照が失われない。
  - この性質を保持するために、内側で生成された関数は、外側の関数の戻り値として呼び出し元に渡されたり、プロパティに保持される。


## 基本形

```kotlin
fun increment(): () -> Int {
    var value = 0
    // 関数を返します
    return fun(): Int {
        // 外側の関数のプロパティを参照できる
        return value++
    }
}

val myInc = increment()
println("${myInc()}") // 1
println("${myInc()}") // 2
```


## 内側の関数は生成される度に異なる外側のプロパティを持つ

```kotlin
fun makeAdder(x: Int): (Int) -> Int {
    return fun(y: Int): Int {
        return x + y
    }
}

val add5To = makeAdder(5)
val add10To = makeAdder(10)

println("${add5To(2)}") // 7
println("${add10To(2)}") // 12
```


## Java のクロージャとの違い

Java にはプリミティブ型が存在するため、内側の関数からアクセスする外側の変数がプリミティブ型だった場合には、その値のコピーが内側の関数に渡されていました。しかし、 Kotlin では、プリミティブ型が存在していません。コンパイラーの最適化によって、参照型がプリミティブ型に変換される可能性はあるようですが、クロージャで参照する変数については、最適化の対象外となっているように思われました。そのため、 Kotlin のクロージャでは、値のコピーが渡されるのではなく、常にオブジェクトへの参照が渡されると考えて良さそうです。

そのため、以下のようなコードを Java で記述すると最後に 0 が出力されてしまいそうですが、 Kotlin なら正しく 6 という出力が得られます。

```kotlin
val ints = listOf(1, 2, 3)
var sum = 0
ints.filter { it > 0 }.forEach {
    sum += it
}
print(sum) // 6
```


## クロージャのデメリット

クロージャは、内側の関数を関数オブジェクトとしてメモリに割り当てるため、その分実行時のオーバーヘッドが生じます。



