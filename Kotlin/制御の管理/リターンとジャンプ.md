- [リターンとジャンプ](#リターンとジャンプ)
  - [概要](#概要)
  - [ラベル](#ラベル)
    - [基本](#基本)
    - [ラベルを付与できないもの](#ラベルを付与できないもの)
  - [ラベル付き break とラベル付き continue](#ラベル付き-break-とラベル付き-continue)
  - [ラベル付き return](#ラベル付き-return)
    - [ラベル無し return とラベル付き return](#ラベル無し-return-とラベル付き-return)
    - [ラベル無し return が記述できないケース](#ラベル無し-return-が記述できないケース)
    - [インライン関数のラムダ式内でインライン関数の呼び出し元関数を抜ける return](#インライン関数のラムダ式内でインライン関数の呼び出し元関数を抜ける-return)
    - [インライン関数のラムダ式内でラムダ式を抜ける return（ continue する方法１）](#インライン関数のラムダ式内でラムダ式を抜ける-return-continue-する方法１)
    - [暗黙的なラベルを使用する（ continue する方法２）](#暗黙的なラベルを使用する-continue-する方法２)
    - [ラベルの代わりに無名関数を使用する（ continue する方法３）](#ラベルの代わりに無名関数を使用する-continue-する方法３)
    - [ラベル付き return で値を返す](#ラベル付き-return-で値を返す)
  - [forEach の continue と break](#foreach-の-continue-と-break)
    - [forEach では continue と break が使えない](#foreach-では-continue-と-break-が使えない)
    - [Kotlin の構文を使った forEach の continue](#kotlin-の構文を使った-foreach-の-continue)
    - [Kotlin の構文を使った forEach の break](#kotlin-の構文を使った-foreach-の-break)
    - [Collection の関数を使った forEach の continue](#collection-の関数を使った-foreach-の-continue)
    - [Collection の関数を使った forEach の break](#collection-の関数を使った-foreach-の-break)


# リターンとジャンプ

## 概要

Kotlin には、三つの構造的ジャンプの表現があります。

- return
  - デフォルトでは、一番近い関数か無名関数を抜けます。
- break
  - 一番近くのループを終了します。
- continue
  - 一番近くのループを次のステップに進めます。

これらの式はすべて、より大きな式の一部として使用できます。つまり、例えば、以下のような記述が可能です。

```kotlin
val s = person.name ?: return
```

また、これらは Nothing 型として扱われます。


## ラベル

### 基本

Kotlin では、どのような表現に対してもラベルを付与することが可能です。ラベルを作成するには、ラベルにしたい文字列の後ろに `@` マークを付与します。例えば、 `abc@` や `fooBar@` のようにします。ラベルを付与したい場合は、付与したいものの前にラベルを記述するだけです。

```kotlin
// for 文に loop というラベルが付与されました。
loop@ for (i in 1..100) {
    // ...
}
```

### ラベルを付与できないもの

- トップレベル関数
- メンバー関数


## ラベル付き break とラベル付き continue

```kotlin
loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (...) break@loop
    }
}
```

ラベル付き break が実行されると、ラベルの付いたループの直後にジャンプします。

ラベル付き continue が実行されると、ラベルの付いたループの次のステップに進みます。


## ラベル付き return

### ラベル無し return とラベル付き return

Kotlin では、関数リテラルやローカル関数やオブジェクト式によって、関数がネストされます。修飾されていない return は、一番近い 「通常の名前付き関数」 か 「無名関数」 を抜けます。一方で、修飾された return は、それ以外の内側の関数から抜けることを可能にします。

**ここの見直しが必要。インライン関数の場合のみ上記とは違う挙動になるということか？だから以下にインライン関数の例だけがあるのか？**

### ラベル無し return が記述できないケース

インライン関数ではない関数の引数に渡されたラムダ式内では、ラベル無し return は記述できません。インライン関数の引数に渡されたラムダ式内では、ラベル無し return は記述可能です。

```kotlin
// インライン関数ではない関数
fun ordinaryFunction(block: () -> Unit) {
    println("hi!")
}

// インライン関数
inline fun inlined(block: () -> Unit) {
    println("hi!")
}

fun foo() {
    ordinaryFunction {
        return // コンパイルエラー
    }

    inlined {
        return // 正常に foo() 関数から抜けます
    }
}

fun main() {
    foo()
}
```

上記のように、一番近い関数ではななく、その外側にある関数から抜ける return のことを **非ローカルリターン** と呼びます。


### インライン関数のラムダ式内でインライン関数の呼び出し元関数を抜ける return

インライン関数のラムダ式内での無修飾の return は、インライン関数を呼び出している関数から抜けます。

```kotlin
fun foo() {
    // forEach() 関数はインライン関数です。
    listOf(1, 2, 3, 4, 5).forEach {
        // foo() 関数を抜ける return
        if (it == 3) return
        print("$it, ")
    }
    println("ここは実行されません")
}
```

```
実行結果

1, 2, 
```


### インライン関数のラムダ式内でラムダ式を抜ける return（ continue する方法１）

インライン関数のラムダ式内でラムダ式にラベルを付与すれば、ラベル付き return で、ラムダ式から抜けられます。

```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit
        print("$it, ")
    }
    print("ここは実行されます")
}
```

```
実行結果

1, 2, 4, 5, ここは実行されます
```


### 暗黙的なラベルを使用する（ continue する方法２）

あらかじめ関数名がラベルとして登録されているらしく、その暗黙的なラベルを使用するほうが便利なことがあります。

```kotlin
fun foo() {
    // 自分ではラベルを定義していませんが、あらかじめ関数名でラベルが定義されているようです。
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach
        print("$it, ")
    }
    print("ここは実行されます")
}
```

```
実行結果

1, 2, 4, 5, ここは実行されます
```


### ラベルの代わりに無名関数を使用する（ continue する方法３）

「ラムダ式 + ラベル」 の代わりに無名関数を使用することができます。無名関数内のラベルなしの return は、無名関数を抜けます。

```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return
        print("$value, ")
    })
    print("ここは実行されます")
}
```

```
実行結果

1, 2, 4, 5, ここは実行されます
```


### ラベル付き return で値を返す

以下のようにするとラベル付き return で戻り値 result を返します。

```kotlin
val result = 10
return@myLabel result
```


## forEach の continue と break

### forEach では continue と break が使えない

`forEach()` 関数では、 `continue` と `break` が使用できません。なぜなら、 `for` 文が kotlin の **構文** であるのに対し、 forEach() は kotlin  の **関数** であるためです。


### Kotlin の構文を使った forEach の continue

forEach() 関数で continue を行うためには、以下の三通りの方法があります。

- 明示的なラベル付き return 文で抜ける
- 暗黙的なラベル付き return 文で抜ける
- 無名関数のラベルなし return 文で抜ける

それぞれの実例は、このページの 「ラベル付き return 」 の項に記載してあるため、ここでは省略します。


### Kotlin の構文を使った forEach の break

forEach() 関数で break するには、 forEach() 関数の呼び出しの外側にラベル付きのスコープ関数 `run` を定義します。そして、 break したいところで、ラベル付き return を実行します。

ここで使用している `run()` 関数は、拡張関数ではない方の run() です。そのため、レシーバーを持っておらず、単に run ブロック内の処理を実行して、最終行の結果を返すだけの関数です。

```kotlin
fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop
            print("$it, ")
        }
    }
    print("ここは実行されます")
}
```

```
実行結果

1, 2, ここは実行されます
```


### Collection の関数を使った forEach の continue

`filter()` 関数を使用すると forEach() 関数使用時に、 continue と同等の効果を得ることが出来ます。

```kotlin
collection.filter { it % 2 == 0 }.forEach {
    // 条件を満たした要素に対して何らかの処理を行う。
}
```


### Collection の関数を使った forEach の break

`takeWhile()` 関数を使用すると forEach() 関数使用時に、 break と同等の効果を得ることが出来ます。

```kotlin
collection.takeWhile { it < 10 }.forEach {
    // 条件を初めて満たさなくなるまでの間に取得した要素に対して
    // 何らかの処理を行う。
}
```





