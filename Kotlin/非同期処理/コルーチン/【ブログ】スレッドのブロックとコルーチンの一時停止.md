- [スレッドのブロックとコルーチンの一時停止](#スレッドのブロックとコルーチンの一時停止)
  - [スレッドのブロック](#スレッドのブロック)
  - [コルーチンの中断](#コルーチンの中断)
  - [ブロッキングするコードかどうかを識別する](#ブロッキングするコードかどうかを識別する)
  - [関数のサスペンド](#関数のサスペンド)
  - [サスペンド コンベンション](#サスペンド-コンベンション)
  - [IO のブロックからサスペンドへ](#io-のブロックからサスペンドへ)
  - [結論](#結論)
  - [引用元資料](#引用元資料)


# スレッドのブロックとコルーチンの一時停止

このドキュメントはもう完全に理解している話なので、読む必要はないよ。

最新のオペレーティング システムでは、各プロセスで複数のスレッドがサポートされています。スレッドは、コードを実行する別の CPU コアがあるように見せる抽象化ですが、CPU に実際に搭載されている物理コアの数に関係なく、必要な数のスレッドを開始できます。したがって、複数のスレッドがある場合、一部のスレッドがブロックされることを心配する必要はありません。少なくとも 2 つの理由があります。

<img src="./画像/ブロッキングのイメージ.webp" width="400">

まず、UI アプリケーションを作成する場合、通常、すべての UI 操作とイベントを処理する単一のメイン スレッドがあります。このスレッドをブロックすると、アプリケーション全体が応答しなくなります。バックエンド アプリケーションでは、これが問題になることはほとんどありませんが、一方で、バックエンド アプリケーションは、通常、固定サイズのスレッド プールで実行するようにスケジュールされている、多数の同時要求を処理する傾向があります。要求が迅速に実行される間は、全く問題はありませんが、サービス指向アーキテクチャの現在の世界では、呼び出し元スレッドをブロックして、そのサービスからの応答を待機すると、 1 つの低速サービスがすべてのスレッドをブロックし、システム全体の進行が停止する可能性があります。


## スレッドのブロック

スレッドをブロックするにはどうすればよいですか? スレッドをブロックする方法は 2 つあります。1 つは、CPU を集中的に使用する計算を実行する方法です。これは、多くの時間がかかります (CPU バインド タスクとも呼ばれます)。たとえば、4096 ビットの素数を生成する次の (安全でない) 関数は、私のマシンでは、実行に約 10 秒かかります

```kotlin
fun findBigPrime(): BigInteger =
BigInteger.probablePrime(4096, Random())
```

スレッドをブロックするもう 1 つの方法は、ブロッキング IO (別名 IO バウンド タスク) を使用して、たとえば、到着までに長い時間がかかる可能性があるリモート システムからのメッセージを待機することです。

```kotlin
fun BufferedReader.readMessage(): Message? =
    readLine()?.parseMessage()
```

最初のケースでは CPU リソースが実際に消費され、2 番目のケースでは IO 操作は CPU リソースを実際に消費することなく、長時間待機できます。それでも、これらの関数を呼び出すスレッドは、他の操作を実行できないため、どちらの場合も、スレッドがブロックされていると言えます。つまり、UI イベントを処理できず、他のリクエストを実行できないのです。

スレッドは、コストがかかるため、スレッドをブロックすることは避けるべきです。CPU にバインドされたタスクを実行する必要がある場合は、スレッドをブロックするしかありませんが、どのスレッドをブロックするかは、常に選択できます。バックエンド アプリケーションでメインの UI スレッド、または、制限されたリクエスト処理スレッドをブロックすることは避けてください。

一方、IO が原因でブロックする場合は、通常、スレッドをまったくブロックしない非ブロッキング (非同期) IO ライブラリを使用して、ブロックを完全に回避できます。


## コルーチンの中断

コルーチンは、中断をサポートすることで、スレッド ブロックの代替手段を提供します。では、スレッドのブロックとコルーチンの中断の違いは何でしょうか。次のシーケンシャル コード スニペットを見てみましょう。

```kotlin
val data = awaitData() // does it block or suspend?
processData(data)
```

このスニペットでは、processData は awaitData が戻った後にのみ呼び出されます。processData の呼び出しの観点からは、awaitData が長時間ブロック、または、一時停止しても、実際には問題ではありません。では、なぜブロッキングと一時停止を区別する必要があるのでしょうか。これらには、重要な違いがあります。このコードが UI アプリケーションのメイン スレッドで実行される場合、awaitData によってスレッドをブロックすると UI がフリーズしますが、コルーチンを一時停止するとフリーズしません。したがって、ブロッキング関数と非ブロッキング関数を区別する方法が必要です。


## ブロッキングするコードかどうかを識別する

JVM プラットフォーム上の Java API では、通常、ドキュメントでブロッキング動作が明示的に示されています。コア API では、通常、適切な用語が使用されているため、ブロッキング動作を簡単に認識できます。たとえば、 [InputStream.read メソッド](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html#read--) のドキュメントを見ると、次のように記述されています。

```
このメソッドは、入力データが使用可能になるか、ストリームの終了が検出されるか、例外がスローされるまでブロックします。
```

明示的でない場合もあります。たとえば、 [ReentrantLock.lock メソッド](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html#lock--) のドキュメントには次のように書かれています。

```
ロックが別のスレッドによって保持されている場合、現在のスレッドはスレッド スケジューリングの目的で無効になり、ロックが取得されるまで休止状態になります
```

これは、現在のスレッドが、ロックが取得されるまでブロックされるという複雑な言い方です。

残念ながら、他のケースでは、より深い知識や経験が必要です。たとえば、 [BigInteger.probablePrime](https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#probablePrime-int-java.util.Random-) のドキュメントには、これが CPU をかなり消費するメソッドであるという事実を示唆するものは何もありません。

注: JVM ドキュメントでは、一般的に「ブロッキング」の狭い定義に従っており、ブロッキング IO に対するこの用語の使用を制限しようとしています。ただし、Thread.State 列挙では BLOCKING が別の方法で定義されており、ブロッキング IO を行うメソッドは RUNNABLE 状態であると見なされることに注意してください。この記事では、ブロッキングのより広い定義を採用しています。これは実用的であり、クリティカル スレッド (ブロックすべきではない) を持つアプリケーションにとって便利なメンタル モデルを提供します。

複雑なアプリケーションでは、高レベル メソッドのブロッキング動作を認識するのが簡単ではない場合があります。ブロッキング メソッドと非ブロッキング メソッドを区別するための共通の命名規則やアノテーションはありません。ブロッキング メソッドの呼び出しを見つけるのは困難です。開発者は、不適切なブロッキング呼び出しを見つけるために、lint チェックとランタイム チェックの組み合わせに頼っています。たとえば、Android 開発者は、Android でネットワーク IO をブロックすると NetworkOnMainThreadException がスローされるという事実を喜んでいます。


## 関数のサスペンド

Kotlin プログラミング言語では、suspend 修飾子を介して関数をサスペンドするという概念が導入されています。 **よくある間違いの 1 つは、関数に suspend 修飾子を追加すると、関数が非同期、または、非ブロッキングになるというものです。** この間違いは、KotlinConf 2018 の Venkat Subramariam による講演 [「Exploring Coroutines in Kotlin」](https://www.youtube.com/watch?v=jT2gHPQ4Z1Q) でも確認できます。ブロッキング関数の最初の例に suspend 修飾子を追加して、この間違いを詳しく調べましょう。

```kotlin
suspend fun findBigPrime(): BigInteger = 
    BigInteger.probablePrime(4096, Random())
```

この変更を行っても、findBigPrime 関数は呼び出し元スレッドをかなり長い間ブロックします。UI アプリケーションでは、メイン スレッドでコルーチンを起動し、findBigPrime を呼び出すと、かなり厄介な UI フリーズが発生する可能性があります。実際、この関数を IntelliJ IDEA で記述すると、「冗長な「suspend」修飾子」警告が表示されます。これは、 **suspend 修飾子だけでは、ブロッキング関数が非ブロッキング関数に魔法のように変わるわけではない** ことを示しています。

これにより、デフォルトでメイン スレッドでコルーチンを起動することを推奨する理由を疑問に思う人もいます。Droidcon London 2018 での Christina Lee による優れた講演 [「Coroutines by Example」](https://skillsmatter.com/skillscasts/12727-coroutines-by-example) を見ると、彼女もそのことについて疑問に思っていることに気づかずにはいられません。もう疑問に思う必要はありません。答えはすぐそこにあります。


## サスペンド コンベンション

サスペンド関数は、コード設計に新しい次元を追加します。コルーチンがない時代は、 ブロッキング or 非ブロッキング でしたが、今では、それに加えて サスペンド or 非サスペンド もあります。みんなの生活をシンプルにするために、私たちは次の規則を使用します。サスペンド関数は呼び出し元スレッドをブロックしません。

この規則を実装する手段は、 withContext 関数によって提供されます。たとえば、 findBigPrime 関数をサスペンド関数に変換する適切な方法は次のとおりです。

```kotlin
suspend fun findBigPrime(): BigInteger =
    withContext(Dispatchers.Default) {
        BigInteger.probablePrime(4096, Random())
    }
```

これで、UI アプリケーションのメイン スレッドで起動されたコルーチンから、メイン スレッドをブロックせずに findBigPrime を呼び出すことができます。

ここで適用されるもう 1 つの規則は、CPU バインド コードを実行するためにデフォルトのディスパッチャを使用することです。デフォルトのディスパッチャは、システム内の CPU コアと同じ数のスレッドを持つスレッド プールによってサポートされているため、CPU バインド関数向けに最適化されており、CPU バインド コードが必要に応じてすべての物理リソースを飽和させることができます。ただし、スレッドを過剰に割り当てることはありません。過剰に割り当てると、CPU バインド タスクの実行速度が上がるわけではなく、メモリが無駄になるだけです。


## IO のブロックからサスペンドへ

次に、ブロッキング関数の 2 番目の例 (IO バインド関数) を見てみましょう。同様の方法でサスペンド関数に変換します。

```kotlin
suspend fun BufferedReader.readMessage(): Message? =
    withContext(Dispatchers.IO) {
        readLine()?.parseMessage()
    }
```

ここで重要な違いが 1 つあります。IO ディスパッチャが使用されていることです。ここでデフォルトのディスパッチャを使用しない理由は、CPU バウンド コードと IO バウンド コードの違いにあります。

IO バウンド コードは実際には CPU リソースを消費しないため、デフォルトのディスパッチャを使用すると、たとえば、デフォルトのディスパッチャに 8 つのスレッドが割り当てられている 8 コア マシンでは、すべてのスレッドが IO でブロックされますが、実際には CPU を消費しないため、8 コア マシンが十分に活用されないという状況になる可能性があります。IO ディスパッチャは、デフォルトのディスパッチャに割り当てられたスレッドに加えて追加のスレッドを割り当てるため、ブロッキング IO を実行しながら、同時にマシンの CPU リソースを完全に活用できます。


## 結論

withContext を使用することは、ブロックしない関数を中断する唯一の方法ではありません。別の方法としては、最初に完全に非同期 (非ブロッキング) なライブラリ関数を使用することです。たとえば、ブロッキング Thread.sleep メソッドを withContext 経由でサスペンド関数に変える代わりに、 delay 関数を使用するだけで済みます。

この (すでに長い) 話では、非同期関数 (および非同期 IO) についてこれ以上詳しく説明しません。ブロックしないサスペンド関数もあると言えば十分でしょう。

したがって、サスペンド関数がブロックしないという規則に従う場合、アプリケーションのメイン スレッドですべてのコルーチンを起動してもまったく問題ありません。これは素晴らしいことです。この方法により、心配事が 1 つ減り、このようなコルーチンからアプリケーションの UI に安全にアクセスして変更できるからです。さらに、この規則により、呼び出している関数がブロッキングかどうかを確認するために、ドキュメントを参照する必要が減ります。アプリケーションで使用されるブロッキング コードをサスペンド関数に分離してカプセル化すると、ブロックしているかどうかを二重チェックすることなく、どこからでも自由に呼び出すことができます。

同じことがバックエンドにも当てはまります。この規則により、コードのほとんどをサーバーの非ブロッキングの制限されたスレッド プールで安全に実行でき、コンテキスト スイッチを回避することでサーバーのスループットが向上します。いずれにしても、コストのかかるブロッキング操作を実行する必要がある場合に限り、別のスレッドへのコストのかかるスイッチ (withContext 経由) を実行します。


## 引用元資料

- [Blocking threads, suspending coroutines](https://elizarov.medium.com/blocking-threads-suspending-coroutines-d33e11bf4761)
