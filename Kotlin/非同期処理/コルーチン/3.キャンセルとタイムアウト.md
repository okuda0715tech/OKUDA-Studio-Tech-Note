- [キャンセルとタイムアウト](#キャンセルとタイムアウト)
  - [キャンセルされないケース](#キャンセルされないケース)
    - [1. キャンセルをチェックするタイミングが存在しない場合](#1-キャンセルをチェックするタイミングが存在しない場合)
    - [2. CancellationException をキャッチしてしまっている場合](#2-cancellationexception-をキャッチしてしまっている場合)
  - [処理中のコードをキャンセル可能にする](#処理中のコードをキャンセル可能にする)
    - [1. キャンセルをチェックする一時停止関数を定期的に呼び出す方法](#1-キャンセルをチェックする一時停止関数を定期的に呼び出す方法)
    - [2. キャンセル状態を明示的にチェックする方法](#2-キャンセル状態を明示的にチェックする方法)
  - [finally でリソースを閉じる](#finally-でリソースを閉じる)
  - [キャンセル不可のブロックを実行する](#キャンセル不可のブロックを実行する)
  - [タイムアウト](#タイムアウト)
    - [try / catch ブロックでラップした例](#try--catch-ブロックでラップした例)
    - [withTimeoutOrNull 関数を使用した例](#withtimeoutornull-関数を使用した例)
  - [非同期タイムアウトとリソースの解放漏れ](#非同期タイムアウトとリソースの解放漏れ)
  - [引用元資料](#引用元資料)


# キャンセルとタイムアウト

長時間実行されるアプリケーションでは、バックグラウンドコルーチンを細かく制御する必要がある場合があります。たとえば、ユーザーがコルーチンを起動したページを閉じた場合、その結果は不要になり、その操作をキャンセルできます。

launch 関数は、実行中のコルーチンを表す Job を返します。 Job を使用して、そのコルーチンをキャンセルすることができます。

```kotlin
fun main() = runBlocking {
    val job = launch {
        repeat(1000) { i ->
            println("job: I'm sleeping $i ...")
            delay(500L)
        }
    }
    delay(1300L) // delay a bit
    println("main: I'm tired of waiting!")
    job.cancel() // cancels the job
    job.join() // waits for job's completion 
    println("main: Now I can quit.")
}
```

```
実行結果

job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
```

job.cancel を呼び出すと、コルーチンが 「キャンセル中」 状態になり、キャンセル中状態が検出されると、コルーチンがキャンセルされます。コルーチンがキャンセルされると、そのコルーチンからの出力は表示されません。また、 cancel 呼び出しと join 呼び出しを組み合わせた Job 拡張関数 `cancelAndJoin` 関数も用意されています。

Job がキャンセルされると、その Job に紐づくコルーチンスコープは破棄されます。


## キャンセルされないケース

### 1. キャンセルをチェックするタイミングが存在しない場合

コルーチンはキャンセルが可能です。コルーチンの特定の関数 ( kotlinx.coroutines パッケージ内の全ての suspend 関数) は、キャンセルをチェックし、キャンセルされると CancellationException をスローします。ただし、 「キャンセル指示が出されたか？」 をチェックするタイミングが存在しない処理の場合は、キャンセルできません。以下はキャンセルをチェックするタイミングが存在しない例です。

```kotlin
fun main() = runBlocking {
    val startTime = currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i < 5) {
            // 0.5 秒に一回 if 文の中に入る
            if (currentTimeMillis() >= nextPrintTime) {
                // ただのログ出力
                println("job: I'm sleeping ${i++} ...")
                
                // if 文に入ったら、次は 0.5 秒後に
                // if 文に入るようにする。
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L)
    println("main: I'm tired of waiting!")
    // ジョブをキャンセルし、ジョブが終了するまで待機する。
    job.cancelAndJoin()
    println("main: Now I can quit.")
}
```

```
実行結果

job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm sleeping 3 ...
job: I'm sleeping 4 ...
main: Now I can quit.
```

実行結果を見ると、キャンセルした後もジョブは継続しており、 5 回の 「 I'm sleeping 」 の print 処理が終わるまで、ジョブが終了していないことがわかります。


### 2. CancellationException をキャッチしてしまっている場合

CancellationException をキャッチして再スローしない場合も、ジョブは最後まで実行されます。

```kotlin
fun main() = runBlocking {
    val job = launch(Dispatchers.Default) {
        repeat(5) { i ->
            try {
                println("job: I'm sleeping $i ...")
                delay(500)
            } catch (e: Exception) {
                println(e)
            }
        }
    }
    delay(1300L)
    println("main: I'm tired of waiting!")
    job.cancelAndJoin()
    println("main: Now I can quit.")
}
```

```
実行結果

job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
kotlinx.coroutines.JobCancellationException: ～ (以下略)
job: I'm sleeping 3 ...
kotlinx.coroutines.JobCancellationException: ～ (以下略)
job: I'm sleeping 4 ...
kotlinx.coroutines.JobCancellationException: ～ (以下略)
main: Now I can quit.
```

特に理由がない場合は、 CancellationException を明示的にキャッチすることは避けるべきアンチパターンです。

また、この問題は、 runCatching 関数 (内部で try/catch を使用している) を使用する場合など、例外を無意識的に補足してしまった場合にも発生するため、注意が必要です。

Exception クラスは、 CancellationException クラスの親クラスであるため、 Exception クラスをキャッチすることも避けるべきアンチパターンです。そのため、 IOException など、その他の例外を catch したい場合は、 Exception クラスをキャッチするのではなく、より具体的な IOException クラスなどをキャッチするようにしてください。


## 処理中のコードをキャンセル可能にする

コードをキャンセル可能にする方法は二つあります。一つ目は、キャンセルをチェックする suspend 関数を定期的に呼び出すことです。この目的に適した関数に yield (※ 1 ) 関数があります。二つ目は、キャンセル状態を明示的にチェックすることです。

(※ 1 )  
yield は、イールドカーブ (債券の金利と償還期間との相関性を示したグラフ) のイールドと同じ単語です。


### 1. キャンセルをチェックする一時停止関数を定期的に呼び出す方法

ここに記載する例は、公式ドキュメントに記載されていた方法ではないため、使用する場合は十分に注意しましょう。

yield という単語には、収穫するという意味があり、関数の結果を返す場合などに使用されます。ここでは、処理をキャンセルして終了するため、それが関数の終了などに似ているので使われているのでしょう。

```kotlin
fun main() = runBlocking {
    val startTime = currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i < 5) {
            // 0.5 秒に一回 if 文の中に入る
            if (currentTimeMillis() >= nextPrintTime) {
                // ただのログ出力
                Log.v("test", "job: I'm sleeping ${i++} ...")

                // if 文に入ったら、次は 0.5 秒後に
                // if 文に入るようにする。
                nextPrintTime += 500L
            }
            // ここでキャンセルされたかどうかをチェックする。
            yield()
        }
    }
    delay(1300) // 1.3秒待機
    Log.v("test", "Cancelling coroutine")
    job.cancelAndJoin() // コルーチンをキャンセルして完了するのを待機
    Log.v("test", "Coroutine cancelled")
}
```

```
実行結果

job: I'm sleeping 0 ..
job: I'm sleeping 1 ..
job: I'm sleeping 2 ..
Cancelling coroutine
Coroutine cancelled
```


### 2. キャンセル状態を明示的にチェックする方法

前の例の while (i < 5) を while (i < 5 && isActive) に置き換えて、再実行します。

```kotlin
fun main() = runBlocking {
    val startTime = currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i < 5 && isActive) {
            // 0.5 秒に一回 if 文の中に入る
            if (currentTimeMillis() >= nextPrintTime) {
                // ただのログ出力
                println("job: I'm sleeping ${i++} ...")

                // if 文に入ったら、次は 0.5 秒後に
                // if 文に入るようにする。
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L)
    println("main: I'm tired of waiting!")
    job.cancelAndJoin()
    println("main: Now I can quit.")
}
```

```
実行結果

job: I'm sleeping 0 ..
job: I'm sleeping 1 ..
job: I'm sleeping 2 ..
main: I'm tired of wai
main: Now I can quit.
```

このループはキャンセルされます。 isActive は、 CoroutineScope オブジェクトの拡張プロパティであるため、 CoroutineScope 内でいつでも使用することが可能です。

isActive は、現在のジョブがまだアクティブ状態 (完了しておらず、また、キャンセルもされていない状態) の場合は true を返します。


## finally でリソースを閉じる

キャンセルされたコルーチンは、 CancellationException をスローしますが、これは通常の方法で処理できます。たとえば、 try {...} finally {...} 式と Kotlin の use 関数は、コルーチンがキャンセルされたときに、通常どおり、ファイナライズアクションを実行します。

use 関数は、ファイルなどクローズ可能なオブジェクトを操作する場合にのみ使用可能です。それ以外の場合は、 finally で後処理します。 use 関数はファイルを自動的にクローズしてくれるので、クローズのし忘れがありません。 use 関数に関して、さらに詳しく確認する場合は、 [こちら](../../型_変数_値/use関数.md) を参照してください。

```kotlin
fun main() = runBlocking {
    val job = launch {
        try {
            repeat(1000) { i ->
                println("job: I'm sleeping $i ...")
                delay(500L)
            }
        } finally {
            println("job: I'm running finally")
        }
    }
    delay(1300L) // delay a bit
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // cancels the job and waits for its completion
    println("main: Now I can quit.")
}
```

join 関数、 cancelAndJoin 関数ともに、すべてのファイナライズアクションが完了するまで待機するため、以下の実行結果となります。

```
実行結果

job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
main: Now I can quit.
```


## キャンセル不可のブロックを実行する

前の例の finally ブロックで suspend 関数を使用しようとすると、このコードを実行しているコルーチンがキャンセルされるため、 CancellationException が発生します。　catch ブロック、および、 finally ブロックでは、 suspend 関数を使用しないでください。予期せぬ動作につながる可能性があります。

ただし、通常、 catch ブロックや finally ブロックで suspend 関数を呼び出す必要はないため、そのようなケースはあまりないでしょう。すべての正常な終了操作 (ファイルのクローズ、ジョブのキャンセル、またはあらゆる種類の通信チャネルのクローズ) は、通常、スレッドをブロックする必要のない処理であり、 suspend 関数ではない場合がほとんどです。

ただし、まれにキャンセルされたコルーチンで一時停止する必要がある場合は、次の例に示すように、 withContext 関数と NonCancellable コンテキストを使用してください。対応するコードを `withContext(NonCancellable) {...}` でラップすることで、キャンセルを不可にし、 CancellationExeption を抑制することで、 catch ブロックや finally ブロック内の処理を継続します。

```kotlin
fun main() = runBlocking {
    val job = launch {
        try {
            repeat(1000) { i ->
                println("job: I'm sleeping $i ...")
                delay(500L)
            }
        } finally {
            withContext(NonCancellable) {
                println("job: I'm running finally")
                delay(1000L)
                println("job: And I've just delayed for 1 sec because I'm non-cancellable")
            }
        }
    }
    delay(1300L) // delay a bit
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // cancels the job and waits for its completion
    println("main: Now I can quit.")
}
```

```
実行結果

job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
job: I'm running finally
job: And I've just delayed for 1 sec because I'm non-cancellable
main: Now I can quit.
```


## タイムアウト

コルーチンの実行をキャンセルする最も明白で実用的な理由は、実行時間がタイムアウト時間を超えたためです。タイムアウトでキャンセルするには、自前で実装するよりも、 `withTimeout` 関数を使用すると便利です。

```kotlin
fun main() = runBlocking {
    withTimeout(1300L) {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
    }
}
```

```
実行結果

I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

withTimeout によってスローされる TimeoutCancellationException は、 CancellationException のサブクラスです。 CancellationException は、スタックトレースを出力しませんが、 withTimeout によってスローされる TimeoutCancellationException は、スタックトレースを出力します。

TimeoutCancellationException や CancellationException は、単なる例外であるため、追加の処理が必要な場合は、通常の方法で処理を追加できます。具体的な実装方法は、多くの場合、以下のいずれかの方法になります。

- タイムアウトを発生させる可能性のあるコードを `try { } catch (e: TimeoutCancellationException) { }` ブロックでラップする。
- タイムアウト時に、例外をスローする代わりに null を返す `withTimeoutOrNull` 関数を使用する。


### try / catch ブロックでラップした例

```kotlin
fun main() = runBlocking {
    try {
        withTimeout(1300L) {
            repeat(1000) { i ->
                println("I'm sleeping $i ...")
                delay(500L)
            }
        }
    } catch (e: TimeoutCancellationException) {
        println("Timed out!")
    }
}
```

```
実行結果

I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Timed out!
```

ここで、ふと疑問に思ったことはないでしょうか？ TimeoutCancellationException は、 CancellationException クラスを継承しています。上の方のセクションで、 [「 CancellationException を catch すると、コルーチンが停止せずに最後まで実行されてしまう」](#2-cancellationexception-をキャッチしてしまっている場合) という内容を記載しましたが、 withTimeout 関数を使用して発生した TimeoutCancellationException は、 catch しても問題なく、実行中の処理を中断してくれるため、上のセクションで説明した内容を気にする必要はありません。


### withTimeoutOrNull 関数を使用した例

```kotlin
fun main() = runBlocking {
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
        // withTimeout 関数や withTimeoutOrNull 関数は、
        // ラムダ式内の最終行の結果を
        // タイムアウト関数の結果として返しているようです。
        "Done" // この行が実行される前にキャンセルされます。
    }
    println("Result is $result")
}
```

```
実行結果

I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
Result is null
```


## 非同期タイムアウトとリソースの解放漏れ

withTimeout のタイムアウトイベントは、そのブロック内で実行されているコードに対して非同期であり、 withTimeout ブロック内から戻る直前であっても発生する可能性があります。ブロック内でリソースを取得し、ブロック外で解放する場合は、リソースの解放漏れが発生しないように注意する必要があります。

例えば、以下は、リソースを取得したら acquired カウンターを加算し、解放したらカウンターを減算することで、リソースの取得状況を模倣したプログラムです。リソースは Resource オブジェクトで表現しています。 withTimeout ブロックの最後に Resource を作成し、ブロック外でリソースを解放しています。 

この例では、リソース生成直後から、リソースをクローズするまでの間にタイムアウトが発生してしまい、リソースのクローズ処理を実行できずに、例外処理に移行する可能性があります。そうすると、リソースの解放漏れが起こります。

```kotlin
var acquired = 0

class Resource {
    init { acquired++ } // リソースの取得
    fun close() { acquired-- } // リソースの解放
}

fun main() {
    runBlocking {
        repeat(10_000) { // Launch 10K coroutines
            launch {
                // withTimeout 関数の最後の一文の結果が
                // resource 変数に格納されます。
                val resource = withTimeout(60) {
                    // withTimeout ブロックを出てから
                    // リソースを解放するまでに
                    // タイムアウトが発生するように、
                    // 遅延を入れる
                    delay(59)
                    Resource()
                }
                // ここで、 resource を使用した何らかの処理を実施する。
                // ここでタイムアウトが発生すると、
                // 以下のクローズ処理が行われない。

                // リソースを開放する
                resource.close()
            }
        }
    }
    // Outside of runBlocking all coroutines have completed
    println(acquired) // Print the number of resources still acquired
}
```

上記のコードを実行すると、必ずしも 0 が出力されるわけではないことがわかりますが、これはマシンのタイミングに依存する可能性があります。実際にゼロ以外の値を表示するには、この例のタイムアウトを微調整する必要があるかもしれません。

これを解決するためには、 try {} finally {} を使用した before after パターンで、必ずリソースの解放を行えるようにします。

```kotlin
fun main() {
    runBlocking {
        repeat(10_000) {
            launch { 
                var resource: Resource? = null
                try {
                    withTimeout(60) {
                        delay(50)
                        resource = Resource()
                    }
                    // リソースに対して何か処理を行いたい場合は、ここで実施します。
                    // ここで何らかの処理を実施中にタイムアウトが発生する可能性はありますが、
                    // その場合でも、必ずリソースの解放が行われます。
                } finally {  
                    resource?.close()
                }
            }
        }
    }
    println(acquired)
}
```

このプログラムは、必ず 0 を表示します。


## 引用元資料

- [Cancellation and timeouts - 公式ドキュメント](https://kotlinlang.org/docs/coroutines-and-channels.html)


