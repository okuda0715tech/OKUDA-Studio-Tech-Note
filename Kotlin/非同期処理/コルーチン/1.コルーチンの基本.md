- [コルーチンの基本](#コルーチンの基本)
  - [コルーチンとは](#コルーチンとは)
  - [Kotlin のコルーチンとは](#kotlin-のコルーチンとは)
  - [ディスパッチャー](#ディスパッチャー)
  - [ライブラリの追加](#ライブラリの追加)
  - [基本形](#基本形)
  - [構造化された同時実行](#構造化された同時実行)
  - [関数抽出リファクタリング（suspend 関数）](#関数抽出リファクタリングsuspend-関数)
  - [スコープビルダー (coroutinScope 関数)](#スコープビルダー-coroutinscope-関数)
  - [スコープビルダーと同時実行](#スコープビルダーと同時実行)
  - [coroutineScope 関数と runBlocking 関数の違い](#coroutinescope-関数と-runblocking-関数の違い)
  - [明示的な Job と join (待ち合わせ)](#明示的な-job-と-join-待ち合わせ)
  - [コルーチンは軽量](#コルーチンは軽量)


# コルーチンの基本

## コルーチンとは

コルーチンは、 Kotlin 以外のプログラミング言語でも登場する仕組みであり、  
サブルーチンが、 「呼び出しから戻りまで一気通貫」 なのに対し、  
コルーチンは、 「処理を途中で中断したら、再度呼び出した際に中断箇所から再開する」 ことを意味します。


## Kotlin のコルーチンとは

Kotlin のコルーチンとは、非同期処理を実装するための Kotlin のライブラリです。  
(コルーチン自体がスレッドというわけではありません。)

コルーチンは、中断可能な処理のインスタンスです。  
これは、概念的にはスレッドに似ています。  
ただし、コルーチンは特定のスレッドに紐づきません。  
あるスレッドで途中まで処理を行ったら一時停止し、別のスレッドで再開することができます。

コルーチンは一般的には単一スレッド内で進行しますが、マルチスレッド環境でも使用できます。  
具体的には、複数のコルーチンが同じスレッドで順次実行されたり、複数のスレッドを使用して複数のコルーチンを同時に実行することも可能です。


## ディスパッチャー

コルーチンはディスパッチャーと呼ばれるものによって実行されます。

ディスパッチャーは、コルーチンがどのスレッドやスレッドプールで実行されるかを管理します。

Kotlin の標準ライブラリには、さまざまな種類のディスパッチャーが含まれており、  
開発者は適切なディスパッチャーを選択できます。


## ライブラリの追加

```
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0-RC2")
}
```

【参考】  
`kotlinx-coroutines-core` と `kotlinx-coroutines-android` は別のライブラリです。  
`core` には Kotlin/JS 用や Kotlin/Native 用のコードが含まれています。  
`android` には Android 用のコードのみ含まれています。


## 基本形

```kotlin
fun main() = runBlocking { // this: CoroutineScope
    launch { // 新しいコルーチンを生成し、開始します。
        delay(1000L) // 1 秒の非ブロック遅延 (デフォルトの単位はミリ秒です)
        println("World!") // 1 秒の遅延後に実行されます。
    }
    println("Hello") // 一つ前のコルーチンが遅延されている間も、メインコルーチンは継続しています。
}
```

`runBlocking` は、コルーチンビルダーです。  
特に、これは親コルーチンを生成します。
つまり、コルーチンの外の処理と中の処理の橋渡し役です。

`launch` も、コルーチンビルダーです。特に、これは子コルーチンを生成します。つまり、コルーチンスコープ内でのみ定義可能なコルーチンを生成します。 launch は、コルーチンを生成して開始します。

`delay` は、特別な一時停止関数です。  
コルーチンを指定した時間だけ一時停止します。  
コルーチンを一時停止しても、そのコルーチンを実行していたスレッドはブロックされません。  
よって、そのスレッドは、元のコルーチンを一時停止している間に、他のコルーチンの処理を実行することが可能です。

runBlocking は、その内側の内側のコルーチンの処理が終了するまで、 runBlocking を実行したスレッドをブロックします。それが runBlocking の名前の由来です。


## 構造化された同時実行

コルーチンは、構造化された同時実行の原則に従います。つまり、新たに生成したコルーチンは、特定のコルーチンの内部でのみ開始され、それがコルーチンの生存期間を制限します。

実際のアプリでは、たくさんのコルーチンを起動します。構造化された同時実行は、ロストすることもなく、リークすることもありません。親 (包含) コルーチンは、全ての子 (内部) コルーチンが終了するまで、終了しません。また、構造化された同時実行は、どんなエラーも適切に報告されるため、エラーを決して失うことがありません。


## 関数抽出リファクタリング（suspend 関数）

`launch{}` ブロック内の処理を別の関数として抽出するリファクタリングについて考えてみましょう。

コルーチン内部の処理を関数抽出する場合は、抽出した関数に `suspend` 修飾子を付与する必要がある場合があります。

抽出した関数内で、コルーチンの実行を遅延させる他の関数 ( `delay()` など) を呼び出す場合は、抽出した関数に suspend 修飾子を付与する必要があります。

```kotlin
fun main() = runBlocking {
    launch { doWorld() }
    println("Hello")
}

// suspend 関数
suspend fun doWorld() {
    delay(1000L)
    println("World!")
}
```

suspend 関数には、 「内部に一時停止の処理が含まれている可能性がある」 という意味のマーカーになります。そのため、 suspend 関数を呼び出すことができるのは、別の suspend 関数か、コルーチンスコープ内からのみとなります。


## スコープビルダー (coroutinScope 関数)

`coroutineScope` 関数を使用することで、独自のコルーチンスコープを定義することが可能です。この方法で定義されたコルーチンスコープは、全ての小コルーチンが終了するまで、終了しません。

coroutineScope 関数は、 suspend 関数であるため、使用できるのは、他の suspend 関数内か、他のコルーチンスコープ内部に限ります。

```kotlin
fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello")
}
```


## スコープビルダーと同時実行

複数のコルーチンを一つのコルーチンスコープでまとめたい場合には、 coroutinScope 関数が有用です。

```kotlin
fun main() = runBlocking {
    doWorld()
    println("Done")
}

// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println("World 2")
    }
    launch {
        delay(1000L)
        println("World 1")
    }
    println("Hello")
}
```


## coroutineScope 関数と runBlocking 関数の違い

coroutineScope 関数は、 runBlocking 関数とは違い、一時停止している間、当該スレッドは解放されて、他の処理を行うことが可能です。ただし、実際には、 coroutineScope ブロック内のすべての処理が終わらない限り、ブロックの外側の処理は開始されないため、 coroutineScope 関数と runBlocking 関数は実質的に同じ動きをすると思われます。ただし、中身が異なるため、それぞれの仕組みは覚えておくと良いでしょう。

また、 runBlocking には、コルーチンの外側の世界とコルーチンの世界の橋渡し役をしますが、 coroutineScope は橋渡し役はせず、コルーチンの世界の中だけで使用することが可能です。そのため、 runBlocking は橋渡し役となり、 coroutineScope は、複数のコルーチンのまとめ役になるでしょう。


## 明示的な Job と join (待ち合わせ)

`launch` 関数は、 `Job` オブジェクトを返します。このオブジェクトを使用することによって、そのコルーチンを操作することが可能です。例えば、 `join` 関数 (※ 1 ) は、そのコルーチンが終了するまで待機します。

(※ 1 )  
マルチスレッド関連で使用される join には、複数のスレッドが一つの地点で合流することを意味しています。つまり、複数スレッドの同期をとるという意味を含んでいます。

```kotlin
fun main() = runBlocking {
    // 新しいコルーチンを開始し、その Job への参照を保持します。
    val job = launch {
        delay(1000L)
        println("World!")
    }
    println("Hello")
    // job コルーチンが終了するまで待機します。
    job.join()
    println("Done")     
}
```

上記の例では、 job コルーチンが終了してから Done という文字が出力されます。実行結果は以下の通りです。

```
Hello
World!
Done
```

上記の例では、 launch{} ブロックは、 job 変数に代入されていますが、変数に代入されようが、されなかろうが、 launch{} ブロック内の処理は、 launch 関数が呼び出された時点で、すぐに実行が開始されます。 ( join 関数が呼ばれるまで、 launch{} ブロック内の処理の開始が遅延されるようなことはありません。)


## コルーチンは軽量

Kotlin のコルーチンは、 Java のスレッドに比べて非常に軽量で、メモリの消費量がかなり抑えられます。例えば、以下のコードは、 5 万個のドットを表示するプログラムですが、全くメモリ不足にはなりません。

```kotlin
fun main() = runBlocking {
    repeat(50_000) { // launch a lot of coroutines
        launch {
            delay(5000L)
            print(".")
        }
    }
}
```




