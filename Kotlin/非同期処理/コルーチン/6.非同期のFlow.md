- [非同期の Flow](#非同期の-flow)
  - [複数の値を表現する](#複数の値を表現する)
    - [Sequence を使用した方法](#sequence-を使用した方法)
    - [suspend 関数を使用した方法](#suspend-関数を使用した方法)
    - [Flow を使用した方法](#flow-を使用した方法)
  - [Flow は cold（遅延生成）](#flow-は-cold遅延生成)
  - [Flow をキャンセルする方法の基本](#flow-をキャンセルする方法の基本)
  - [Flow ビルダー](#flow-ビルダー)
  - [Flow の中間演算子（垂直実行される関数のこと）](#flow-の中間演算子垂直実行される関数のこと)
    - [変換演算子](#変換演算子)
    - [サイズを制限した演算子](#サイズを制限した演算子)
  - [Flow の終端演算子（水平実行される関数のこと）](#flow-の終端演算子水平実行される関数のこと)
  - [Flow の連続性（中間演算子と終端演算子の処理順序）](#flow-の連続性中間演算子と終端演算子の処理順序)
  - [Flow のコンテキスト](#flow-のコンテキスト)
    - [withContext を使用する際のよくある落とし穴](#withcontext-を使用する際のよくある落とし穴)
    - [flowOn 演算子](#flowon-演算子)
  - [バッファリング](#バッファリング)
    - [結合（Conflation）](#結合conflation)
    - [古い値の処理はキャンセルして、最新の値で再開する](#古い値の処理はキャンセルして最新の値で再開する)
  - [複数の Flow をまとめる](#複数の-flow-をまとめる)
    - [Zip](#zip)
    - [Combine（組み合わせる）](#combine組み合わせる)
  - [Flow を平らにする（Flattening）](#flow-を平らにするflattening)
    - [flatMapConcat](#flatmapconcat)
    - [flatMapMerge](#flatmapmerge)
    - [flatMapLatest](#flatmaplatest)
  - [Flow の例外](#flow-の例外)
    - [コレクターの try and catch](#コレクターの-try-and-catch)
    - [どこで例外が発生しても catch 可能](#どこで例外が発生しても-catch-可能)
  - [例外の透過性](#例外の透過性)
    - [透過的な catch（上流のエラーのみキャッチする）](#透過的な-catch上流のエラーのみキャッチする)
    - [宣言的にキャッチする（下流のエラーをキャッチする方法）](#宣言的にキャッチする下流のエラーをキャッチする方法)
  - [Flow の完了](#flow-の完了)
    - [命令型の finally ブロック](#命令型の-finally-ブロック)
    - [宣言的に扱う](#宣言的に扱う)
    - [正常終了の場合のみ null が渡ってくる](#正常終了の場合のみ-null-が渡ってくる)
  - [命令的 VS 宣言的](#命令的-vs-宣言的)
    - [フローの起動](#フローの起動)
    - [フローキャンセルチェック](#フローキャンセルチェック)
    - [ビジーな flow をキャンセル可能にする](#ビジーな-flow-をキャンセル可能にする)
  - [Flow と Reactive Streams](#flow-と-reactive-streams)


# 非同期の Flow

suspend 関数は非同期的に一つの値を返しますが、非同期的に計算された複数の値を返すにはどうすればよいのでしょうか？ここで Kotlin Flows が役立ちます。


## 複数の値を表現する

Kotlin では、コレクションを使用して複数の値を表すことができます。たとえば、三つの数値のリストを返し、 forEach を使用してそれらすべてを出力する単純な関数を作成できます。

```kotlin
fun simple(): List<Int> = listOf(1, 2, 3)
 
fun main() {
    simple().forEach { value -> println(value) } 
}
```

```
実行結果

1
2
3
```


### Sequence を使用した方法

スレッドをブロックして複数の値を取得する場合には、 [Sequence](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/) を使用することも検討できます。ただし、この方法では、 `Thread.sleep` がメインスレッドをブロックしてしまうという問題があります。

```kotlin
fun simple(): Sequence<Int> = sequence { // sequence builder
    for (i in 1..3) {
        Thread.sleep(10000)
        yield(i) // yield next value
    }
}

fun main() {
    simple().forEach { value -> println(value) } 
}
```

```
実行結果

1
2
3
```

`sequence` 関数は、 `yield()` 関数の引数に渡した値を Sequence の要素として返します。 Sequence オブジェクトは、遅延評価コレクションです。そのため、各要素が必要になってから、各要素を計算して返します。

yield は、 suspend 関数であるため、 yield が呼ばれて値を返したら、次の値が必要とされるまで、一時停止します。次の値が必要になったら、 yield の次の行から処理を再開します。


### suspend 関数を使用した方法

スレッドをブロックせずに計算したい場合、関数に suspend 修飾子を付けてマークし、結果をリストとして返すことになるでしょう。 (ただし、この例では、 runBlocking がメインスレッドをブロックしているため、完全ではありません。単なる Flow を説明するための序章だと思って無視してください。)

それでもまだ、このコードには問題があります。それは、結果を List として返しているため、その全ての要素がそろうまで結果を返すことができないという点です。

```kotlin
suspend fun simple(): List<Int> {
    // 非同期処理の代わりに delay を入れます。
    delay(3000)
    return listOf(1, 2, 3)
}

fun main() = runBlocking<Unit> {
    simple().forEach { value -> println(value) } 
}
```


### Flow を使用した方法

各要素を Sequence 型のように個別に返したい場合は、 Flow 型を使用することができます。

```kotlin
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

fun simple(): Flow<Int> = flow { // flow builder
    for (i in 1..3) {
        // 時間のかかる非同期処理を模倣します。
        delay(1000)
        println("generating value of $i")
        // 生成した要素 i を要求元に返します。
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    // Flow の要素を回収します。
    // collect 関数は要素を一つずつ取得します。
    // 複数の要素を同時実行で取得するわけではない点に注意してください。
    simple().collect { value ->
        println("value = $value")
    }
}
```

```
実行結果

generating value of 1
value = 1
generating value of 2
value = 2
generating value of 3
value = 3
```

Flow のコードには、以下の特徴があります。

- Flow タイプのビルダー関数は、 flow と呼ばれます。
- simple 関数は、 suspend 修飾子でマークされなくなりましたが、 flow { ... } ビルダーブロック内のコードはスレッドをブロックせず、一時停止が可能です。
- 値は、 emit 関数を使用してフローから値を返します。
- 値は、 collect 関数を使用してフローから要素を収集します。
- collect 関数は suspend 関数であるため、コルーチン or 別の suspend 関数から呼び出す必要があります。

flow {} ブロックは、 emit 関数で要素を排出するため、公式ドキュメント内で、 **エミッター** と呼んでいます。 collect {} ブロックは、要素を取得するため **コレクター** と呼んでいます。


## Flow は cold（遅延生成）

Flow は Sequence に似たコールドストリームです。フロービルダー内のコードは、 Flow が collect されるまで実行されません。これは次の例を見ると明らかです。

```kotlin
fun simple(): Flow<Int> = flow { 
    println("Flow started")
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    println("Calling simple function...")
    val flow = simple()
    println("Calling collect...")
    flow.collect { value -> println(value) } 
    println("Calling collect again...")
    flow.collect { value -> println(value) } 
}
```

```
実行結果

Calling simple function...
Calling collect...
Flow started
1
2
3
Calling collect again...
Flow started
1
2
3
```

これが、 simple 関数に suspend 修飾子が付いていない主な理由です。 simple() 呼び出し自体はすぐに戻り、何も待機しません。 フローは collect されるたびに新たに開始されるため、 collect を再度呼び出すたびに「 Flow started 」と表示されます。


## Flow をキャンセルする方法の基本

フローは、コルーチンの一般的な協調キャンセルに従います。通常どおり、フローがキャンセル可能な一時停止関数 ( delay など) で一時停止されると、フローのコレクションをキャンセルできます。次の例は、 withTimeoutOrNull ブロッ​​クで実行されているときにタイムアウトでフローがキャンセルされ、コードの実行が停止される様子を示しています。

```kotlin
fun simple(): Flow<Int> = flow { 
    for (i in 1..3) {
        delay(100)          
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    // Timeout after 250ms
    withTimeoutOrNull(250) {
        simple().collect { value -> println(value) } 
    }
    println("Done")
}
```

simple 関数の flow ブロックによって二つの数値のみが出力され、三つ目の数値が出力されていない様子がわかります。

```
実行結果

Emitting 1
1
Emitting 2
2
Done
```

詳細については、 [フローのキャンセルチェック](https://kotlinlang.org/docs/flow.html#flow-cancellation-checks) のセクションを参照してください。


## Flow ビルダー

前の例の flow { ... } ビルダーは最も基本的なものです。フローを宣言できるビルダーは他にもあります。

- [flowOf](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html) ビルダーは、固定された値のセットを返す Flow を定義します。
- `.asFlow()` 拡張関数を使用して、さまざまな Collection と Sequence を Flow に変換できます。

たとえば、 Flow から 1 から 3 までの数字を返すスニペットは、次のように書き換えることができます。

```kotlin
fun main() = runBlocking<Unit> {
    // Int 型の Range を Flow に変換します。
    (1..3).asFlow().collect { value -> println(value) }
}
```


## Flow の中間演算子（垂直実行される関数のこと）

Flow は、 Collection や Sequence を変換するのと同じように、演算子 ( map や filtere など) を使用して変換できます。

中間演 (インターミディエート) 算子は、 Flow と同様にコールドで、必要とされるまで実施されません。このような演算子の呼び出し自体は、 suspend 関数ではありませんが、演算子に渡すラムダ式は suspend 関数として実行されます。 Sequence と Flow の違いは、演算子に渡すラムダ式が suspend 関数として実行されるかどうかです。

```kotlin
suspend fun performRequest(request: Int): String {
    // 長時間実行される非同期処理の代わりの delay
    println("1")
    delay(1000)
    println("2")
    return "response $request"
}

fun main() = runBlocking<Unit> {
    (1..3).asFlow()
        .map { request ->
            performRequest(request)
        }
        .collect { response ->
            println("3")
            println(response) }
}
```

次の三行が生成され、それぞれが前の行の 1 秒後に表示されます。

```
実行結果
「1」の行と「2」の行の間に 1 秒程度の遅延がありますが、それ以外は直前の出力から遅延なく表示されます。

1
2
3
response 1
1
2
3
response 2
1
2
3
response 3
```


### 変換演算子

Flow の変換演算子の中で最も一般的なものは `transform` です。これは、 map や filter などの単純な変換を模倣したり、より複雑な変換を実装したりするために使用できます。 transform 演算子を使用すると、任意の値を任意の回数発行できます。

たとえば、 transform を使用すると、長時間実行される非同期要求を実行する前に文字列を発行し、その後に応答を送信できます。

```kotlin
suspend fun performRequest(request: Int): String {
    // 長時間処理の模倣
    delay(1000)

    return "response $request"
}

fun main() = runBlocking<Unit> {
    (1..3).asFlow()
        .transform { request ->
            emit("Making request $request") 
            emit(performRequest(request)) 
        }
        .collect { response -> println(response) }
}
```

```
実行結果

Making request 1
response 1
Making request 2
response 2
Making request 3
response 3
```


### サイズを制限した演算子

take のようなサイズ制限中間演算子は、対応する制限に達したときに Flow の実行をキャンセルします。コルーチンでのキャンセルは常に例外をスローすることによって実行されるため、キャンセルの場合でもすべてのリソース管理関数 (try { ... } finally { ... } ブロックなど) は正常に動作します。

```kotlin
fun numbers(): Flow<Int> = flow {
    try {                          
        emit(1)
        emit(2) 
        println("This line will not execute")
        emit(3)    
    } finally {
        println("Finally in numbers")
    }
}

fun main() = runBlocking<Unit> {
    numbers() 
        .take(2) // 最初の二つのみ取得する。
        .collect { value -> println(value) }
}        
```

このコードの出力は、 numbers() 関数の flow { ... } 本体の実行が二つ目の数値を出力した後に停止したことを明確に示しています。

```
実行結果

1
2
Finally in numbers
```


## Flow の終端演算子（水平実行される関数のこと）

Flow の終端 (ターミナル) 演算子は、 Flow の要素の収集を開始する一時停止関数です。 collect 演算子は最も基本的な演算子ですが、他にも簡単に実行できるターミナル演算子があります。

- toList や toSet などのさまざまなコレクションへの変換
- 最初の値を取得し、 Flow が単一の値を返すようにする演算子
- reduce と fold を使用して Flow を値に縮小するもの

以下に例を示します。

```kotlin
fun main() = runBlocking<Unit> {
    val sum = (1..3).asFlow()
        .map { it * it } // 1 から 3 までの数字の 2 乗
        .reduce { a, b -> a + b } // 合計する
    println(sum)
}
```

reduce 関数の第一引数は蓄積された値を示し、第二引数は元のコレクションの次の要素を示します。

```
実行結果
( 1 + 4 + 9 = 14 なので)

14
```


## Flow の連続性（中間演算子と終端演算子の処理順序）

Flow は終端演算子にあたるまで垂直実行されます。

偶数整数をフィルタリングして文字列にマップする次の例を参照してください。

```kotlin
fun main() = runBlocking<Unit> {
    (1..5).asFlow()
        .filter {
            println("Filter $it")
            it % 2 == 0              
        }              
        .map { 
            println("Map $it")
            "string $it"
        }.
        collect { 
            println("Collect $it")
        }    
}
```

```
実行結果

Filter 1
Filter 2
Map 2
Collect string 2
Filter 3
Filter 4
Map 4
Collect string 4
Filter 5
```


## Flow のコンテキスト

Flow の要素の収集は、常に呼び出し元のコルーチンのコンテキストで行われます。たとえば、 simple() 関数が Flow を返す場合、次のコードは、 Flow の実装の詳細に関係なく、このコードの作成者が指定したコンテキストで実行されます。

```kotlin
withContext(context) {
    simple().collect { value ->
        // collect ブロック内の処理は、 withContext で指定したコンテキストで実行されます。
        println(value)
    }
}
```

フローのこの特性は **コンテキスト保持** と呼ばれます。

したがって、デフォルトでは、 flow { ... } ビルダーのコードは、対応する Flow の収集関数によって提供されるコンテキストで実行されます。

以下のコードは、呼び出されたスレッドを出力し、三つの数値を出力する simple 関数の実装です。

```kotlin
fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")
           
fun simple(): Flow<Int> = flow {
    log("Started simple flow")
    for (i in 1..3) {
        emit(i)
    }
}  

fun main() = runBlocking<Unit> {
    // collect 関数が実行されるコンテキストが
    // flow {} ブロック内の処理でも使用される。
    simple().collect { value -> log("Collected $value") } 
}    
```

```
実行結果

[main @coroutine#1] Started simple flow
[main @coroutine#1] Collected 1
[main @coroutine#1] Collected 2
[main @coroutine#1] Collected 3
```

simple().collect はメインスレッドから呼び出されるため、 simple の Flow 本体もメインスレッドで呼び出されます。これは、実行コンテキストを気にせず、呼び出し元をブロックしない、高速実行または非同期コードに最適なデフォルトです。


### withContext を使用する際のよくある落とし穴

長時間実行される CPU を消費するコードは Dispatchers.Default のコンテキストで実行する必要がある場合があり、 UI 更新コードは Dispatchers.Main のコンテキストで実行する必要がある場合があります。通常、 withContext は Kotlin コルーチンを使用するコード内のコンテキストを変更するために使用されますが、 flow { ... } ビルダー内のコードはコンテキスト保持の特性を尊重する必要があり、別のコンテキストから出力することはできません。

次のコードを実行してみてください。

```kotlin
fun simple(): Flow<Int> = flow {
    // flow ビルダー内で CPU を消費するコードのコンテキストを変更する間違った実装方法
    kotlinx.coroutines.withContext(Dispatchers.Default) {
        for (i in 1..3) {
            // CPU 消費の疑似コード
            Thread.sleep(100)

            // 次の値を返す
            emit(i)
        }
    }
}

fun main() = runBlocking<Unit> {
    simple().collect { value -> println(value) } 
}
```

```
実行結果
( Flow の不変条件に違反しているというメッセージのエラー)

Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
		Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],
		but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default].
		Please refer to 'flow' documentation or use 'flowOn' instead
	at ...
```


### flowOn 演算子

例外が使用を推奨している  [flowOn](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html)  関数は、 Flow の値を返すコンテキストを変更するために使用されます。フローのコンテキストを変更する正しい方法を以下に示します。この例では、すべての処理がどのように実行されるかを示すために、対応するスレッドの名前も出力します。

```kotlin
fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")
           
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        // CPU の消費を模倣します。
        Thread.sleep(100)

        log("Emitting $i")
        emit(i)
    }
// flow ビルダー内で CPU を消耗するコードのコンテキストを変更する正しい方法
}.flowOn(Dispatchers.Default)

fun main() = runBlocking<Unit> {
    simple().collect { value ->
        log("Collected $value") 
    } 
}
```

メインスレッドで収集が行われているのに対して、 flow { ... } はバックグラウンドスレッドで行われています。

```
実行結果

[DefaultDispatcher-worker-1 @coroutine#2] Emitting 1
[main @coroutine#1] Collected 1
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 2
[main @coroutine#1] Collected 2
[DefaultDispatcher-worker-1 @coroutine#2] Emitting 3
[main @coroutine#1] Collected 3
```

ここで注目すべきもう一つの点は、 flowOn 演算子によって Flow のデフォルトの順次性が変わったことです。現在、コレクションは一つのコルーチン ( coroutine#1 ) で発生し、エミッションは別のコルーチン ( coroutine#2 ) で発生します。このコルーチンは、収集コルーチンと別のスレッドで同時実行されています。


## バッファリング

Flow のさまざまな部分を異なるコルーチンで実行すると、 Flow を収集するのにかかる全体的な時間の観点から、特に長時間実行される非同期操作が関係する場合に役立ちます。たとえば、 simple 関数の flow{} 内での値の返却が遅く、要素を生成するのに 100 ミリ秒かかり、要素の収集も遅く、要素を処理するのに 300 ミリ秒かかる場合を考えてみましょう。このような Flow を収集するのにかかる時間を 3 つの数値で確認してみましょう。

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        // 100 ミリ秒の待機を再現
        println("emitting ...")
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> { 
    val time = measureTimeMillis {
        simple().collect { value -> 
            // 300 ミリ秒の待機を再現
            println("collecting ...")
            delay(300)
            println(value) 
        }
    }
    println("Collected in $time ms")
}
```

次のような結果が生成され、コレクション全体に約 1200 ミリ秒 (三つの数値がそれぞれ 400 ミリ秒) かかります。

```
実行結果

emitting ...
collecting ...
1
emitting ...
collecting ...
2
emitting ...
collecting ...
3
Collected in 1229 ms
```

Flow に対して buffer 演算子を使用すると、 flow {} ブロック内の値の返却と collect {} ブロック内の要素の収集を同時に実行できます。つまり、 collect {} ブロックの完了を待つことなく、次の flow {} ブロックの処理が開始されます。 (通常は、 collect が完了してから次の emit が開始されます。)

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> { 
    val time = measureTimeMillis {
        simple()
            .buffer() // collect の完了を待たない。
            .collect { value -> 
                delay(300)
                println(value) 
            } 
    }   
    println("Collected in $time ms")
}
```

処理パイプラインを効果的に作成したため、最初の数字を 100 ミリ秒待つだけで済み、その後は各数字の処理に 300 ミリ秒しかかからないため、同じ数字をより速く生成できます。この方法では、実行に約 1000 ミリ秒かかります。

```
実行結果

1
2
3
Collected in 1071 ms
```

flowOn 演算子でディスパッチャーを変更すると、暗黙的にこのバッファリングメカニズムが使用されます。ここでは、コンテキストを変更せず、明示的にバッファリングを行う方法を学びました。


### 結合（Conflation）

Flow の途中の要素はあまり重要ではなく、最新 (最後) の値のみを処理すれば良い場合があります。例えば、インジケーターを更新する場合などが該当するでしょう。

特に、 flow {} ブロックの計算は短時間で終了するけれど、 collect {} ブロックの処理に長い時間がかかる場合に、 conflate は効果が発揮できます。 conflate は、 buffer 関数同様に collect ブロックの完了を待たずに、 flow ブロックの処理を次々と開始します。そして、 collect ブロックは、 flow ブロックが返した最新の値のみを処理し、途中の値は処理を行いません (処理をスキップします) 。

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> { 
    val time = measureTimeMillis {
        simple()
            .conflate() // Flow の全ての要素を処理しません。
            .collect { value -> 
                delay(300)
                println(value) 
            } 
    }   
    println("Collected in $time ms")
}
```

最初の数字がまだ処理されている間に、二番目と三番目の数字がすでに生成されていたため、二番目の数字が結合され、最新の数字 (三番目の数字) のみがコレクターに配信されたことがわかります。

```
実行結果

1
3
Collected in 758 ms
```

処理時間は、最初の flow の 100 ミリ秒と、最初の collect の 300 ミリ秒と、最後の collect の 300 ミリ秒で、約 700 ミリ秒となります。


### 古い値の処理はキャンセルして、最新の値で再開する

Conflation (結合) は、エミッターとコレクターの両方が遅い場合に処理を高速化する一つの方法です。これは、放出された値をドロップ (スキップ) することで実現します。もう一つの方法は、遅いコレクターをキャンセルし、新しい値が放出されるたびにコレクターを再起動することです。前の例で、 conflate を collectLatest に変更してみましょう。

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> { 
    val time = measureTimeMillis {
        simple()
            // 古くなった値の処理はキャンセルして、最新の値で処理を再開する
            .collectLatest { value ->
                println("Collecting $value") 
                delay(300)
                println("Done $value") 
            } 
    }   
    println("Collected in $time ms")
}
```

collectLatest の本体は 300 ミリ秒かかりますが、新しい値は 100 ミリ秒ごとに発行されます。コレクターはすべての値に対して実行されますが、最後の値の場合だけ処理が完了し、前の二つの値は途中でキャンセルされます。

```
実行結果

Collecting 1
Collecting 2
Collecting 3
Done 3
Collected in 741 ms
```


## 複数の Flow をまとめる

複数の Flow をまとめる方法はたくさんあります。


### Zip

Kotlin 標準ライブラリの [Sequence.zip](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/zip.html) 拡張関数と同様に、 Flow には二つの Flow の対応する値を結合する zip 演算子があります。

```kotlin
fun main() = runBlocking<Unit> { 
    val nums = (1..3).asFlow()
    val strs = flowOf("one", "two", "three")
    nums.zip(strs) { a, b -> "$a -> $b" }
        .collect { println(it) }
}
```

```
実行結果

1 -> one
2 -> two
3 -> three
```


### Combine（組み合わせる）

フローが変数または演算の最新の値を表す場合 (結合に関する関連セクションも参照) 、対応するフローの最新の値に依存する計算を実行し、上流のフローのいずれかが値を出力するたびにそれを再計算する必要がある場合があります。対応する演算子のファミリは Combine と呼ばれます。

たとえば、前の例の数値が 300 ミリ秒ごとに更新され、文字列が 400 ミリ秒ごとに更新される場合、 zip 演算子を使用してそれらを圧縮すると、結果は 400 ミリ秒ごとに印刷されますが、同じ結果が生成されます。

この例では、各要素を遅延させ、サンプルフローを発行するコードをより宣言的かつ短くするために、 onEach 中間演算子を使用します。

```kotlin
fun main() = runBlocking<Unit> { 
    // 300 ms 毎に 1 ～ 3 を返す
    val nums = (1..3).asFlow().onEach { delay(300) }
    // 400 ms 毎に one ～ three を返す
    val strs = flowOf("one", "two", "three").onEach { delay(400) }
    val startTime = currentTimeMillis()
    // zip 関数でまとめる
    nums.zip(strs) { a, b -> "$a -> $b" }
        .collect { value ->
            println("$value at ${currentTimeMillis() - startTime} ms from start") 
        } 
}
```

```
実行結果

1 -> one at 437 ms from start
2 -> two at 838 ms from start
3 -> three at 1240 ms from start
```

上記のコードについて、 zip の代わりに [combine](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html) 演算子を使用すると、次のようになります。

```kotlin
fun main() = runBlocking<Unit> { 
    val nums = (1..3).asFlow().onEach { delay(300) }
    val strs = flowOf("one", "two", "three").onEach { delay(400) }
    val startTime = currentTimeMillis()
    nums.combine(strs) { a, b -> "$a -> $b" }
        .collect { value ->
            println("$value at ${currentTimeMillis() - startTime} ms from start") 
        } 
}
```

出力はまったく異なり、 nums または strs フローからの各出力で一行が出力されます。つまり、二つの Flow のうちどちらか片方の値が放出される度に combine ブロックの処理と collect ブロックの処理が実施されます。

```
実行結果

1 -> one at 450 ms from start
2 -> one at 645 ms from start
2 -> two at 852 ms from start
3 -> two at 945 ms from start
3 -> three at 1253 ms from start
```


## Flow を平らにする（Flattening）

Flow のフラット化はあまり使用する機会はないかも...？

フローは非同期に受信される値のシーケンスを表すため、各値が別の値のシーケンスの要求をトリガーする状況に陥るのは非常に簡単です。たとえば、 500 ミリ秒間隔で二つの文字列のフローを返す次の関数を使用できます。

```kotlin
fun requestFlow(i: Int): Flow<String> = flow {
    emit("$i: First")
    delay(500)
    emit("$i: Second")
}
```

ここで、三つの整数のフローがあり、それぞれに対して requestFlow を呼び出すと、次のようになります。

```kotlin
(1..3).asFlow().map { requestFlow(it) }
```

すると、フローの入れ子 ( `Flow<Flow<String>>` ) が完成し、これをさらに処理するために一つのフローにフラット化する必要があります。コレクションとシーケンスには、このための flatten 演算子と flatMap 演算子があります。ただし、フローの非同期性により、異なるフラット化モードが必要になるため、フローには専用のフラット化演算子が存在します。


### flatMapConcat

フローの連結には、 flatMapConcat 演算子と flattenConcat 演算子が提供されています。次の例に示すように、これらは、内部フローが完了するまで待機してから、次のフローの収集を開始します。

```kotlin
fun requestFlow(i: Int): Flow<String> = flow {
    emit("$i: First") 
    delay(500)
    emit("$i: Second")    
}

fun main() = runBlocking<Unit> { 
    val startTime = currentTimeMillis()
    // 100 ms ごとに数値を放出するフロー
    (1..3).asFlow().onEach { delay(100) }
        .flatMapConcat { requestFlow(it) }
        .collect { value ->
            // 要素の値と start からの経過時間を表示する。
            println("$value at ${currentTimeMillis() - startTime} ms from start") 
        } 
}
```

flatMapConcat 関数は `Flow<Flow<String>>` をフラットにして、 `Flow<String>` を返します。

```
実行結果

1: First at 121 ms from start
1: Second at 622 ms from start
2: First at 727 ms from start
2: Second at 1227 ms from start
3: First at 1328 ms from start
3: Second at 1829 ms from start
```


### flatMapMerge

もう一つのフラット化操作は、すべての着信フローを同時に収集し、それらの値を一つのフローにマージして、値ができるだけ早く出力されるようにすることです。これは、 flatMapMerge 演算子と flattenMerge 演算子によって実装されます。どちらも、同時に収集される同時フローの数を制限するオプションの同時実行パラメータを受け入れます (デフォルトでは DEFAULT_CONCURRENCY と同じです)。

```kotlin
fun requestFlow(i: Int): Flow<String> = flow {
    emit("$i: First") 
    delay(500)
    emit("$i: Second")    
}

fun main() = runBlocking<Unit> { 
    val startTime = currentTimeMillis()
    (1..3).asFlow().onEach { delay(100) }
        .flatMapMerge { requestFlow(it) }
        .collect { value ->
            // 要素の値と start からの経過時間を表示する。
            println("$value at ${currentTimeMillis() - startTime} ms from start") 
        } 
}
```

flatMapConcat との違いは、 `First` が放出されたらすぐに次の要素の処理が開始される点です。 flatMapConcat の場合は、 `Second` の放出が完了するまで次の要素の処理は開始されませんでした。

```
実行結果

1: First at 136 ms from start
2: First at 231 ms from start
3: First at 333 ms from start
1: Second at 639 ms from start
2: Second at 732 ms from start
3: Second at 833 ms from start
```

flatMapMerge はコードブロック (この例では `{ requestFlow(it) }` ) を順番に呼び出しますが、結果のフローは同時に収集することに注意してください。これは、最初に順次マップ `{ requestFlow(it) }` を実行し、その結果に対して flattenMerge を呼び出すのと同じです。


### flatMapLatest

「最新の値の処理」 セクションで説明した collectLatest 演算子と同様に、新しいフローが発行されるとすぐに前のフローのコレクションがキャンセルされる、 「 Latest 」フラット化モードがあります。これは、 flatMapLatest 演算子によって実装されます。

```kotlin
fun requestFlow(i: Int): Flow<String> = flow {
    emit("$i: First") 
    delay(500)
    emit("$i: Second")    
}

fun main() = runBlocking<Unit> { 
    val startTime = currentTimeMillis()
    (1..3).asFlow().onEach { delay(100) }
        .flatMapLatest { requestFlow(it) }
        .collect { value ->
            // 要素の値と start からの経過時間を表示する。
            println("$value at ${currentTimeMillis() - startTime} ms from start") 
        } 
}
```

この例の出力は、 flatMapLatest がどのように動作するかを示す良い例です。次の First が放出されているので、前の Second がスキップされています。 1 の First が完了したら 2 の First の処理が開始されるあたりは、 flatMapMerge と同じです。

```
実行結果

1: First at 142 ms from start
2: First at 322 ms from start
3: First at 425 ms from start
3: Second at 931 ms from start
```

flatMapLatest は、新しい値が受信されると、そのブロック (この例では `{ requestFlow(it) }` ) 内のすべてのコードをキャンセルすることに注意してください。この特定の例では、 requestFlow の呼び出し自体は高速で、一時停止せず、キャンセルできないため、違いはありません。ただし、 requestFlow で delay などの一時停止関数を使用すると、出力に違いが見られます。


## Flow の例外

エミッター、または、オペレーター (コレクター？) 内のコードが例外をスローすると、フローコレクションは例外を伴って完了することがあります。これらの例外を処理する方法はいくつかあります。


### コレクターの try and catch

コレクターは、 Kotlin の try/catch ブロックを使用して例外を処理できます。

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    try {
        simple().collect { value ->         
            println(value)
            check(value <= 1) { "Collected $value" }
        }
    } catch (e: Throwable) {
        println("Caught $e")
    } 
}
```

`check` 関数は Kotlin の標準関数で、 「第一引数が false を返す場合に、第二引数のメッセージで `IllegalStateException` 例外を投げる」 という機能です。

このコードは collect ターミナル演算子で例外を正常にキャッチし、ご覧のとおり、それ以降は値が出力されません。 value が 2 の場合は check 関数の条件を満たさないため、例外が発生します。

```
実行結果

Emitting 1
1
Emitting 2
2
Caught java.lang.IllegalStateException: Collected 2
```


### どこで例外が発生しても catch 可能

前の例では、コレクター内で発生した例外をキャッチしましたが、エミッター内または中間演算子や終端演算子内で発生する例外もキャッチできます。

```kotlin
fun simple(): Flow<String> = 
    flow {
        for (i in 1..3) {
            println("Emitting $i")
            emit(i)
        }
    }
    .map { value ->
        check(value <= 1) { "Crashed on $value" }
        "string $value"
    }

fun main() = runBlocking<Unit> {
    try {
        simple().collect { value -> println(value) }
    } catch (e: Throwable) {
        println("Caught $e")
    }
}
```

この例外は引き続きキャッチされ、収集は停止されます。

```
実行結果

Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
```


## 例外の透過性

フローは例外に対して透過的である必要があります。例外透過性とは、例外が発生したときに、その例外がどこで発生したかが正確に追跡できる性質を指します。 Flow においても、例外が発生したときに、その例外がどの時点で、どのような操作中に発生したかがわかる必要があります。

前の例のように、コレクターを try/catch ブロックで囲むことによって、透過性に違反せず、例外をキャッチすることが可能です。

flow { ... } ビルダー自体を try/catch ブロックで囲むと、例外の透過性に違反するため、注意してください。

または、例外の透過性を維持し、例外処理のカプセル化を可能にする catch 演算子を使用できます。 catch 演算子の本体は例外を分析し、キャッチされた例外に応じてさまざまな方法で対応できます。

- 例外は throw を使用して再スローできます。
- 例外は catch ブロック内で emit 関数を使用してエミットに変換できます。
- 例外は無視、ログ記録、または他のコードで処理できます。

以下の例は、例外をキャッチしたときにテキストを発行します。

```kotlin
fun simple(): Flow<String> = 
    flow {
        for (i in 1..3) {
            println("Emitting $i")
            emit(i)
        }
    }
    .map { value ->
        check(value <= 1) { "Crashed on $value" }
        "string $value"
    }

fun main() = runBlocking<Unit> {
    simple()
        // catch ブロック内で emit する。
        .catch { e -> emit("Caught $e") }
        .collect { value -> println(value) }
}
```

コードの周りに try/catch がなくなったにもかかわらず、出力は同じになります。

```
Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
```


### 透過的な catch（上流のエラーのみキャッチする）

catch 中間演算子は例外透過性を尊重し、上流の例外のみをキャッチし、下流の例外はキャッチしません。つまり catch { ... } より上のすべての演算子からの例外はキャッチしますが、 catch より下のすべての演算子からの例外はキャッチしません。

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    simple()
        // catch ブロック以降の関数で発生した例外はキャッチしません。
        .catch { e -> println("Caught $e") }
        .collect { value ->
            check(value <= 1) { "Collected $value" }                 
            println(value) 
        }
}          
```

catch 演算子があるにもかかわらず、「 Caught ... 」メッセージは出力されず、通常のエラーが出力されます。

```
実行結果

Emitting 1
1
Emitting 2
Exception in thread "main" java.lang.IllegalStateException: Collected 2
```


### 宣言的にキャッチする（下流のエラーをキャッチする方法）

collect 演算子の本体を onEach に移動し、 catch 演算子の前に置くことで、今まで catch よりも下流で発生していたキャッチできなかった例外をキャッチできるようになります。この方法を使用するためには collect() 関数は引数なしで呼び出す必要があります。

```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    simple()
        .onEach { value ->
            check(value <= 1) { "Collected $value" }
            println(value) 
        }
        .catch { e -> println("Caught $e") }
        .collect()
}            
```

ここで、「 Caught ... 」メッセージが出力され、 try/catch ブロックを明示的に使用せずにすべての例外をキャッチできることがわかります。

```
実行結果

Emitting 1
1
Emitting 2
Caught java.lang.IllegalStateException: Collected 2
```


## Flow の完了

フローコレクションが (正常に、または例外で) 完了すると、アクションを実行する必要がある場合があります。すでにお気づきかもしれませんが、これは命令型と宣言型の二つの方法で実行できます。


### 命令型の finally ブロック

コレクターは、 try/catch に加えて、 finally ブロックを使用して、収集完了時にアクションを実行することもできます。

```kotlin
fun simple(): Flow<Int> = (1..3).asFlow()

fun main() = runBlocking<Unit> {
    try {
        simple().collect { value -> println(value) }
    } finally {
        println("Done")
    }
}        
```

このコードは、 simple 関数の Flow によって生成された三つの数値と、それに続く 「 Done 」 文字列を出力します。

```
実行結果

1
2
3
Done
```


### 宣言的に扱う

宣言型アプローチの場合、フローには、フローが完全に収集されたときに呼び出される onCompletion 中間演算子があります。

前の例は、 onCompletion 演算子を使用して書き直すことができ、同じ出力が生成されます。

onCompletion は、 catch とは異なり、自分の下流で発生した例外の場合でも呼ばれる関数です。

```kotlin
fun simple(): Flow<Int> = (1..3).asFlow()

fun main() = runBlocking<Unit> {
    simple()
        .onCompletion { println("Done") }
        .collect { value -> println(value) }
}       
```

```
実行結果

1
2
3
Done
```

onCompletion の主な利点は、コレクターの処理が正常に完了したか、例外的に完了したかの判定に使用できるラムダ式のパラメータがあることです。

```kotlin
fun simple(): Flow<Int> = flow {
    emit(1)
    throw RuntimeException()
}

fun main() = runBlocking<Unit> {
    simple()
        // cause が null なら正常に終了し、
        // not null なら、発生した例外が渡ってきます。
        .onCompletion { cause -> if (cause != null) println("Flow completed exceptionally") }
        .catch { cause -> println("Caught exception") }
        .collect { value -> println(value) }
}
```

```
実行結果

1
Flow completed exceptionally
Caught exception
```

onCompletion 演算子は、 catch とは異なり、例外を処理しません。上記のサンプルコードからわかるように、例外は引き続き下流に流れ、 catch 演算子で処理できます。 catch 演算子の処理後に再び同じ onCompletion 演算子が呼ばれることはありません。

通常、 try/catch/finally では、 catch した後に finally が実行されるのが普通の流れだと思うのですが、上記の例では、 finally を実行してから catch を実行するようになっています。そのため、通常の流れで、 catch してから finally を実行する方法も試してみました。以下のようにすれば catch 後に finally を実行できそうです。

```kotlin
fun simple(): Flow<Int> = flow {
    emit(1)
    throw RuntimeException()
}

fun main() = runBlocking<Unit> {
    simple()
        .onEach { value -> Log.v("test", value.toString()) }
        .catch { cause -> Log.v("test", "Caught exception") }
        .onCompletion { cause ->
            if (cause != null) Log.v("test", "Flow completed exceptionally")
            else Log.v("test", "Flow completed successfully")
        }
        .collect()
}
```

```
実行結果

1
Caught exception
Flow completed successfully
```


### 正常終了の場合のみ null が渡ってくる

catch 演算子とのもう一つの違いは、 onCompletion はすべての例外を認識し、正常に完了した場合にのみ null 値を受け取ることです。 (キャンセルも例外を発生させるため、 null にはなりません。)

```kotlin
fun simple(): Flow<Int> = (1..3).asFlow()

fun main() = runBlocking<Unit> {
    simple()
        .onCompletion { cause -> println("Flow completed with $cause") }
        .collect { value ->
            check(value <= 1) { "Collected $value" }
            println(value) 
        }
}
```

例外によりフローが中止されたため、完了原因が null ではないことがわかります。

```
実行結果

1
Flow completed with java.lang.IllegalStateException: Collected 2
Exception in thread "main" java.lang.IllegalStateException: Collected 2
```


## 命令的 VS 宣言的

これで、フローを収集し、その完了と例外を命令型と宣言型の両方の方法で処理する方法がわかりました。ここで当然の疑問は、どちらのアプローチが好まれ、その理由は何かということです。ライブラリとして、私たちは特定のアプローチを推奨しているわけではなく、両方のオプションが有効であり、自分の好みとコードスタイルに応じて選択する必要があると考えています。


### フローの起動

フローを使用して、何らかのソースから発生する非同期イベントを表すのは簡単です。この場合、着信イベントに対する反応を含むコードを登録し、さらに作業を続行する addEventListener 関数の類似物が必要です。 onEach 演算子はこの役割を果たします。ただし、 onEach は中間演算子です。フローを収集するには、ターミナル演算子 (collect 関数など) も必要です。そうでない場合、 onEach を呼び出すだけでは効果がありません。

onEach の後に collect ターミナル演算子を使用すると、後続のコードはフローが収集されるまで待機します。

```kotlin
fun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }

fun main() = runBlocking<Unit> {
    events()
        .onEach { event -> println("Event: $event") }
        .collect()
    // フローが収集し終わるまで実行されません。
    println("Done")
}          
```

```
実行結果

Event: 1
Event: 2
Event: 3
Done
```

ここでは launchIn ターミナル演算子が便利です。 collect を launchIn に置き換えることで、別のコルーチンを起動して、そこでフローの収集を実行し、収集が完了するのを待つことなく、後続のコードをすぐに続行できます。

```kotlin
fun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }

fun main() = runBlocking<Unit> {
    events()
        .onEach { event -> println("Event: $event") }
        // 別のコルーチンで収集を行う。
        .launchIn(this)
    println("Done")
}          
```

```
実行結果

Done
Event: 1
Event: 2
Event: 3
```

launchIn を使用する際は、新たに起動するコルーチンの親コルーチン (スコープ) を指定する必要があります。上記の例では、親コルーチンは runBlocking となります。 runBlocking は、フローの実行されるコルーチンの完了を待機します。これにより、フローの回収中に main 関数が return されて、意図せず終了してしまうことを防いでいます。

実際のアプリケーションでは、スコープは有効期間が制限されたエンティティから取得されます。このエンティティの有効期間が終了するとすぐに、対応するスコープがキャンセルされ、対応するフローの収集がキャンセルされます。このように、 onEach { ... }.launchIn(scope) のペアは addEventListener のように機能します。ただし、キャンセルと構造化された同時実行がこの目的を果たすため、対応する removeEventListener 関数は必要ありません。

launchIn は Job も返します。これを使用して、スコープ全体をキャンセルせずに、またはスコープに参加せずに、対応するフロー収集コルーチンのみをキャンセルできます。


### フローキャンセルチェック

便宜上、フロービルダーは、 emit 実行時に、ジョブがアクティブかどうかをチェックする [ensureActive](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html) を実行します。これを実行することによって、 `flow { ... }` がビジーの状態 (一時停止していない状態) でも、 emit 実行のタイミングでキャンセルが可能になります。

```kotlin
fun foo(): Flow<Int> = flow { 
    for (i in 1..5) {
        println("Emitting $i") 
        emit(i) 
    }
}

fun main() = runBlocking<Unit> {
    foo().collect { value -> 
        if (value == 3) cancel()  
        println(value)
    } 
}
```

3 までの数字のみが取得され、4 を出力しようとすると CancellationException が発生します。

```
実行結果

Emitting 1
1
Emitting 2
2
Emitting 3
3
Emitting 4
Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@6d7b4f4c
```

ただし、他のほとんどのフロー演算子は、パフォーマンス上の理由から、独自に追加のキャンセルチェックを実行しません。たとえば、 IntRange.asFlow 拡張機能を使用して同じビジーな処理を記述し、どこでも中断しない場合は、キャンセルのチェックは行われません。

```kotlin
fun main() = runBlocking<Unit> {
    (1..5).asFlow().collect { value -> 
        if (value == 3) cancel()  
        println(value)
    } 
}
```

1 から 5 までのすべての数字が収集され、 runBlocking から戻る前にのみキャンセルが検出されます。

```
実行結果

1
2
3
4
5
Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@3327bd23
```


### ビジーな flow をキャンセル可能にする

コルーチンでビジーな処理がある場合は、キャンセルを明示的にチェックする必要があります。 .onEach { currentCoroutineContext().ensureActive() } を追加することもできますが、そのためにすぐに使用できる cancellable 演算子が用意されています。

```kotlin
fun main() = runBlocking<Unit> {
    (1..5).asFlow().cancellable().collect { value -> 
        if (value == 3) cancel()  
        println(value)
    } 
}
```

キャンセル可能な演算子を使用すると、 1 から 3 までの数字のみが収集されます。おそらく、 Flow 内の要素を一つ収集する度に、キャンセルするかどうかの判定をしていると思われます。

```
実行結果

1
2
3
Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@5ec0a365
```


## Flow と Reactive Streams

Reactive Streams や、 RxJava や Project Reactor などのリアクティブフレームワークに精通している人にとっては、 Flow の設計は非常に馴染み深いものかもしれません。

確かに、その設計は Reactive Streams とそのさまざまな実装に触発されました。しかし、 Flow の主な目標は、できるだけシンプルな設計にし、 Kotlin とサスペンションに対応し、構造化された並行性を尊重することです。この目標を達成するには、リアクティブの先駆者たちとその多大な努力が必要です。詳細については、 Reactive Streams と Kotlin Flows の記事をご覧ください。

概念的には異なりますが、 Flow はリアクティブストリームであり、リアクティブ (仕様と TCK に準拠) な Publisher に変換できます。また、その逆も可能です。このようなコンバーターは、 kotlinx.coroutines によってすぐに使用できる状態で提供されており、対応するリアクティブモジュール ( Reactive Streams の場合は kotlinx-coroutines-reactive 、 Project Reactor の場合は kotlinx-coroutines-reactor 、 RxJava2/RxJava3 の場合は kotlinx-coroutines-rx2/kotlinx-coroutines-rx3 ) にあります。統合モジュールには、 Flow との変換、 Reactor の Context との統合、さまざまなリアクティブエンティティを操作するためのサスペンション対応の方法が含まれます。



