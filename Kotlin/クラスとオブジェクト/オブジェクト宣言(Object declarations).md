- [オブジェクト宣言(Object declarations)](#オブジェクト宣言object-declarations)
  - [概要](#概要)
  - [基本形](#基本形)
  - [static フィールド](#static-フィールド)
  - [インスタンスの生成](#インスタンスの生成)
  - [クラスの継承とインターフェースの実装](#クラスの継承とインターフェースの実装)
  - [オブジェクト宣言の内部化](#オブジェクト宣言の内部化)


# オブジェクト宣言(Object declarations)

## 概要

オブジェクト宣言を使用すると、簡単にシングルトンパターンを実装することができます。

オブジェクト宣言では、 `object` 文の直後に必ず名前が続きます。


## 基本形

以下は、オブジェクト宣言を使用した、シングルトンパターンのサンプルです。

```Kotlin
// シングルトンパターンで使用できるオブジェクトを定義
object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) {
        // ...
    }

    val allDataProviders: Collection<DataProvider>
        get() = // ...
}
```


## static フィールド

`object` 宣言の内部に定義されたプロパティは、 `static` なバッキングフィールドを持っています。

**可視性**

通常、 `object` 宣言内に定義されたプロパティは、 `private` ですが、  
以下のいずれかの方法で、公開される可能性があります。

- `@JvmField` アノテーション
- `lateinit` 修飾子
- `const` 修飾子


## インスタンスの生成

インスタンスの生成にコンストラクタを呼び出す必要はありません。  
初回参照時に、インスタンスが自動生成されます。

インスタンスの生成はスレッドセーフとなっており、マルチスレッドでも問題なく使用することができます。

```Kotlin
// 以下のコードは、シングルトンなインスタンスを参照しています。
// (参照時にインスタンスが生成されていなければ自動で生成します。)
DataProviderManager.registerDataProvider(...)
```

コンストラクタを呼び出す必要がないために、稀に、以下のような奇妙なコードを見かけます。

```kotlin
public fun <T> emptyList(): List<T> = EmptyList
```

これは、コンストラクタ呼び出しなしに、インスタンスを生成しています。


## クラスの継承とインターフェースの実装

シングルトンパターンでも、通常のクラスのように、クラスを継承したり、インターフェースを実装することが可能です。

```Kotlin
object DefaultListener : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { ... }

    override fun mouseEntered(e: MouseEvent) { ... }
}
```


## オブジェクト宣言の内部化

何らかの内部にオブジェクト宣言を定義する場合、そこに定義が可能かどうかを以下に示します。

| オブジェクトを宣言する場所           | 宣言の可否 |
| ------------------------------------ | :--------: |
| 関数内                               |     ×      |
| 他のオブジェクト宣言の直接のメンバー |     ○      |
| 非内部クラスの直接のメンバー         |     ○      |





