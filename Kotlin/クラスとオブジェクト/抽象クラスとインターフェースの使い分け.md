- [抽象クラスとインターフェースの使い分け](#抽象クラスとインターフェースの使い分け)
  - [使い分け基準のまとめ](#使い分け基準のまとめ)
  - [抽象クラスを使用するべきケース](#抽象クラスを使用するべきケース)
  - [インターフェースを使用するべきケース](#インターフェースを使用するべきケース)
    - [多重継承の問題点](#多重継承の問題点)
  - [【参考】継承と実装のイメージ](#参考継承と実装のイメージ)
  - [引用元資料](#引用元資料)


# 抽象クラスとインターフェースの使い分け

## 使い分け基準のまとめ

| 条件・目的                               | インターフェース   | 抽象クラス             |
| ---------------------------------------- | ------------------ | ---------------------- |
| 多重継承させたい                         | ✅ 複数OK          | ❌ 1つだけ             |
| 状態（プロパティ）を持ちたい             | △（val/get のみ） | ✅ フィールドOK        |
| コンストラクタ引数を使いたい             | ❌ できない        | ✅ 使える              |


## 抽象クラスを使用するべきケース

- コンストラクタで値を渡したい場合
  - インターフェースはコンストラクタを定義できないため。


## インターフェースを使用するべきケース

- 多重継承を行いたい場合
  - 抽象クラスは一つしか継承できないため、インターフェースを使用するしかない。
  - インターフェースは Java でも Kotlin でも、デフォルト実装を持つことができるようになったため。
  - 多重継承の問題点については、後述します。
  - 多重継承は Mixin (ミックスイン) と呼ばれることもあり、一つのクラスに、デフォルト実装を持ったインターフェースを、任意の数だけ継承し、複数の機能を追加することです。


### 多重継承の問題点

複数の親クラスが “同じ名前のメンバー” を持っている場合、どれを使えばいいか分からなくなります。これはいわゆる「ダイヤモンド継承問題」とも呼ばれます。

これを解決するために、どちらの親のメンバーを使用するのかを明示するというルールができました。

```kotlin
interface A {
    fun hello() = println("Hello from A")
}

interface B {
    fun hello() = println("Hello from B")
}

class C : A, B {
    override fun hello() {
        super<A>.hello()  // 明示的に A の hello を呼ぶ
        super<B>.hello()  // 明示的に B の hello も呼べる
    }
}
```


## 【参考】継承と実装のイメージ

- クラスの継承
  - 「is-a」
- インターフェースの実装
  - 「can-do」
- 委譲
  - 「has-a」


## 引用元資料

- ChatGPT


