- [Functional（SAM）インターフェース](#functionalsamインターフェース)
  - [概要](#概要)
  - [関数型インターフェースを定義する](#関数型インターフェースを定義する)
  - [SAM 変換](#sam-変換)
  - [Java の関数型インターフェースとの互換性](#java-の関数型インターフェースとの互換性)
  - [コンストラクター関数を使用したインターフェースから関数型インターフェースへの移行](#コンストラクター関数を使用したインターフェースから関数型インターフェースへの移行)
  - [関数型インターフェース VS 型エイリアス](#関数型インターフェース-vs-型エイリアス)
  - [関数型インターフェースの制約](#関数型インターフェースの制約)
    - [ジェネリクスな抽象関数は定義できない](#ジェネリクスな抽象関数は定義できない)


# Functional（SAM）インターフェース

## 概要

たった一つの抽象メソッドを持つインターフェースを関数型インターフェース、または、SAM ( Single Abstract Method ) インターフェースと呼びます。これらは、複数の abstract ではないメンバーを持つことが可能ですが、 abstract なメンバーは一つしか持つことができません。


## 関数型インターフェースを定義する

関数型インターフェースを定義するには、インターフェースの定義に `fun` 修飾子を付与します。

```kotlin
fun interface KRunnable {
   fun invoke()
}
```


## SAM 変換

SAM 変換とは、ラムダ式を使用して、関数型インターフェースの実装とインスタンス化を行うことです。ラムダ式を使用することで、コードを簡潔で読みやすいものにすることができます。

SAM 変換に使用するラムダ式は、インターフェースの抽象メソッドのシグネチャに一致している必要があります。

例えば、以下の関数型インターフェースについて考えてみましょう。

```kotlin
fun interface IntPredicate {
    fun accept(i: Int): Boolean
}
```

もし、 SAM 変換を使用しなかった場合、以下のようなコードを記述する必要があります。

```kotlin
// インターフェースを実装したインスタンスを生成する
val isEven = object : IntPredicate {
    override fun accept(i: Int): Boolean {
        return i % 2 == 0
    }
}
```

SAM 変換を活用することで、以下のような同様のコードを記述することができます。

```kotlin
// インターフェースを実装したインスタンスを生成する
val isEven = IntPredicate { it % 2 == 0 }
```

生成したインスタンスは関数型インターフェースを実装した匿名クラスのインスタンスであるため、その関数を使用するには、関数名を指定して関数呼び出しを行います。

```kotlin
fun main() {
    println("7 は偶数？ - ${isEven.accept(7)}")
    // 7 は偶数？ - false
}
```


## Java の関数型インターフェースとの互換性

Java の関数型インターフェースでも SAM 変換を使用することが可能です。


## コンストラクター関数を使用したインターフェースから関数型インターフェースへの移行

Kotlin のバージョン 1.6.20 から、関数型インターフェースコンストラクターの Callable reference (リフレクション) が認められています。これにより、コンストラクター関数を含むインターフェイスから関数型インターフェイスに移行するソース互換の方法が追加されます。次のコードを考えてみましょう。

以下のコードについて考えてみましょう。

```kotlin
interface Printer {
    fun print()
}

fun Printer(block: () -> Unit): Printer = object : Printer { override fun print() = block() }
```

関数型インターフェイスコンストラクターへの Callable reference を有効にすると、このコードは関数型インターフェイス宣言だけで置き換えることができます。

```kotlin
fun interface Printer {
    fun print()
}
```

こうすることで、コンストラクターは暗黙的に生成され、 `::Printer` 関数参照を使用するコードはすべてコンパイルされます。 例えば以下のようにします。

```kotlin
// addPrinter の引数の型がどうなるのかドキュメントに明示されていないので、よくわからない...
documentsStorage.addPrinter(::Printer)
```

バイナリ互換性を保持するために、レガシー関数 `Printer` には、 `DeprecationLevel.HIDDEN` で `@Deprecated` アノテーションを付与します。

```kotlin
@Deprecated(message = "Your message about the deprecation", level = DeprecationLevel.HIDDEN)
fun Printer(...) {...}
```


## 関数型インターフェース VS 型エイリアス

関数型インターフェースは、型エイリアスを使用するとより簡潔に書き換えられる可能性があります。

例えば、最初に紹介した以下のコードについて考えてみましょう。

```kotlin
fun interface IntPredicate {
    fun accept(i: Int): Boolean
}

// インターフェースを実装したインスタンスを生成する
val isEven = IntPredicate { it % 2 == 0 }

fun main() {
    println("7 は偶数？ - ${isEven.accept(7)}")
    // 7 は偶数？ - false
}
```

型エイリアスを使用すると以下のように書き換えることができます。

```kotlin
typealias IntPredicate = (i: Int) -> Boolean

val isEven: IntPredicate = { it % 2 == 0 }

fun main() {
    println("7 は偶数？ - ${isEven(7)}")
    // 7 は偶数？ - false
}
```

関数型インターフェースと型エイリアスの根本的な違いは、新しい型を定義するかどうかです。言い換えると、型エイリアスは、既存の型に対する単なる別名であり、新しい型を作ることはしません。一方で、関数型インターフェースは新しい型を作ります。

関数型インターフェースと型エイリアスの違いを表にすると以下の通りです。

| 観点                                       | 関数型インターフェース | 型エイリアス |
| ------------------------------------------ | ---------------------- | ------------ |
| 機能拡張が可能か                           | ○                      | ×            |
| メンバーをいくつ持てるか                   | 複数                   | 一つ         |
| 他のインターフェースを継承 or 実装できるか | ○                      | ×            |
| 実行等にかかるコスト                       | 高い                   | 低い         |

関数型インターフェースは、新しい型を定義するため、機能拡張を行うことができます。具体的には、一つの抽象関数以外に、具象関数をいくつでも持つことが可能です。また、他のインターフェースを継承したり実装することが可能です。一方で、パフォーマンスについては、型エイリアスの方が優れています。


## 関数型インターフェースの制約

### ジェネリクスな抽象関数は定義できない

ジェネリクスな抽象関数を持つ関数型インターフェースは定義できません。

```kotlin
// コンパイルエラー
fun interface ElementSupplier {
    fun <T> get(list: List<T>): T
}
```

代替案としては、通常のインターフェースにする方法が考えられます。

```kotlin
// コンパイルOK
interface ElementSupplier {
    fun <T> get(list: List<T>): T
}
```




