- [関数型をクラスに直接実装する](#関数型をクラスに直接実装する)
  - [概要](#概要)
  - [invoke() 関数で実装する](#invoke-関数で実装する)
  - [仕組み](#仕組み)
  - [引数の数が同じ関数型は一つしか実装できない](#引数の数が同じ関数型は一つしか実装できない)


# 関数型をクラスに直接実装する

## 概要

Koltin では、以下のように、関数型をクラスに直接実装することが可能です。

```kotlin
class DoubleOperator: (Int) -> Int {

}
```


## invoke() 関数で実装する

関数型をクラスに直接実装するには、 `invoke()` 関数を実装します。 invoke() 関数は特別な関数であるため、関数定義時に `operator` 修飾子を付与する必要があります。付与するのを忘れてると、特別な関数ではなく、ただの invoke() という名前の関数になってしまいます。

```kotlin
class DoubleOperator : (Int) -> Int {
    override operator fun invoke(x: Int): Int = x * 2
}
```


## 仕組み

関数型をクラスに直接実装する仕組みには、 `Functions.kt` クラスが関係しているようです。

[Functions.kt - JetBrains kotlin](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt)

Functions.kt クラスは、引数の数ごとに、 Function インターフェースを継承したインターフェースが複数定義されています。

- `Function0<R>`
- `Function1<P1, R>`
- `Function2<P1, P2, R>`
- ...
- `Function22<P1, ... , R>`

例えば、 Function1 は、以下のように定義されています。

```kotlin
public interface Function1<in P1, out R> : Function<R> {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
```

関数型を実装したクラスは、上記の FunctionX インターフェースをどこかで実装しているようです。そのため、関数型を実装するクラスでは、 invoke() 関数をオーバーライドすることで、その処理を定義することが可能になっているようです。


## 引数の数が同じ関数型は一つしか実装できない

引数の数が同じ関数型は一つしか実装することができません。例えば、以下の例はコンパイルエラーになります。

```kotlin
class DoubleOperator : (Int) -> Int, (String) -> String {
    override operator fun invoke(x: Int): Int = x * 2
    override operator fun invoke(x: String): String = x + x
}
```

仕組みの項でも説明した通り、この仕組みを実現するには、 FunctionX というインターフェースを実装しています。上記の例では、引数が一つであるため、 Function1 というインターフェースが実装されます。一つのクラスが同じインターフェースを複数回実装することは不可能であるため、引数の数が同じ invoke() 関数は一つしか定義できないことになります。




