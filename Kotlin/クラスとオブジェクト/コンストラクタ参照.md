- [コンストラクタ参照](#コンストラクタ参照)
  - [概要](#概要)
  - [基本形](#基本形)
  - [使い所](#使い所)
  - [コンストラクタ参照は KFunction クラスに格納される](#コンストラクタ参照は-kfunction-クラスに格納される)
  - [バインドされた参照とバインドされていない参照](#バインドされた参照とバインドされていない参照)


# コンストラクタ参照

## 概要

コンストラクタも関数やプロパティのように参照することができます。  
コンストラクタを参照するには、クラス名の前にコロン二つ `::` を付与します。


## 基本形

```kotlin
data class Person(val name: String)

val p = ::Person
// Person インスタンスの生成
val taro: Person = p("Taro")
```


## 使い所

関数型を引数に持つ関数に、コンストラクタ参照を渡すことでコンストラクタ参照を有効に活用することができます。

コンストラクタ参照を関数型に代入できるかどうかは、コンストラクタの引数の型と生成するオブジェクトの型が、関数型の引数と戻り値の型に一致しているかどうかで決まります。

```kotlin
data class Person(val name: String)

val names = listOf("Alice", "Bob", "Charlie")
// List<String> を List<Person> に変換
val people = names.map(::Person)
Log.d("test", "result = ${people}")
// result = [Person(name=Alice), Person(name=Bob), Person(name=Charlie)]
```

参考までに、上記の `map()` 関数の定義を以下に記載しておきます。

```kotlin
public inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
}
```


## コンストラクタ参照は KFunction クラスに格納される

コンストラクタ参照は KFunction クラス、もしくは、そのサブタイプのうちの一つにの型に割り当てられます。どのクラスが使用されるかは、引数の数によります。


## バインドされた参照とバインドされていない参照

コロン二つの前に、 **インスタンス**が指定されているコンストラクタ参照を **バインドされた参照 (バウンド参照)** と呼び、 **クラス** が指定されている関数参照を **バインドされていない参照 (アンバウンド参照)** と呼びます。

```kotlin
class Outer {
    // inner が付与された内部クラスは、包含クラスのインスタンスに紐づきます。
    inner class Inner {
        
    }
}

// バインドされた参照
val o = Outer()
val boundConstructor = o::Inner
// レシーバー不要でインスタンスを生成
val i1: Outer.Inner = boundConstructor()

// アンバインドされた参照
val unboundConstructor: Outer.() -> Outer.Inner = Outer::Inner
// レシーバーを第一引数化
val i2: Outer.Inner = unboundConstructor(Outer()) 
// レシーバー付きで使用
val i3: Outer.Inner = o.unboundConstructor()
// ちなみに以下のようにすることもできるが、これだとレシーバー付きで使用することができなくなる。
// (拡張関数のレシーバーの第一引数化.md で説明している通り)
val unboundConstructor: (Outer) -> Outer.Inner = Outer::Inner
```

バインドされた参照は、その参照にレシーバーの情報を含んでいます。  
そのため、そのコンストラクタ参照を格納するプロパティを使用する際にはレシーバーは含みません。

逆に、アンバインドされた参照は、その参照にレシーバーの情報を含んでいません。  
そのため、そのコンストラクタ参照を格納するプロパティを使用する際にはレシーバーが必要になります。





