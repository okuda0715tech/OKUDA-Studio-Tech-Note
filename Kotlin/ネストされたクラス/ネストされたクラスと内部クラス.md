- [ネストされたクラスと内部クラス](#ネストされたクラスと内部クラス)
  - [内部クラスと内部インターフェース](#内部クラスと内部インターフェース)
  - [Java との比較](#java-との比較)
  - [無印のネストされたクラス](#無印のネストされたクラス)
    - [サンプルコード](#サンプルコード)
  - [inner 付きのネストされたクラス](#inner-付きのネストされたクラス)
    - [サンプルコード](#サンプルコード-1)
  - [匿名内部クラス](#匿名内部クラス)
    - [サンプルコード 1](#サンプルコード-1)
    - [サンプルコード 2](#サンプルコード-2)


# ネストされたクラスと内部クラス

## 内部クラスと内部インターフェース

クラスもインターフェースも別のクラス、別のインターフェースの内部に定義することが可能です。  

以下の 4 パターンについて、全て定義することが可能です。

| 包含             | 内部             |
| ---------------- | ---------------- |
| クラス           | クラス           |
| クラス           | インターフェース |
| インターフェース | クラス           |
| インターフェース | インターフェース |


## Java との比較

| Java                        | Kotlin                         |
| --------------------------- | ------------------------------ |
| static なネストされたクラス | 無印のネストされたクラス       |
| メンバー内部クラス          | inner 付きのネストされたクラス |
| メソッドローカル内部クラス  | ローカル関数？                 |
| 匿名内部クラス              | 匿名内部クラス                 |
|                             |                                |


## 無印のネストされたクラス

### サンプルコード

```Kotlin
class Outer {
    private val bar: Int = 1
    // inner 無し
    class Nested {
        fun foo() = 2
    }
}

// ネストされたクラスは、包含クラスのクラス自体に紐づく
val demo = Outer.Nested().foo() // == 2
```


## inner 付きのネストされたクラス

### サンプルコード

```Kotlin
class Outer {
    private var bar: Int = 1
    // inner 付き
    inner class Nested {
        // 包含クラスのインスタンスが存在しているため
        // インスタンスフィールドにアクセスが可能。
        fun foo() = bar
    }
}

// ネストされたクラスは、包含クラスのインスタンスに紐づく
val demo = Outer().Nested().foo() // == 1
```


## 匿名内部クラス

### サンプルコード 1

匿名内部クラスのインスタンスは、オブジェクト式を使用して作成されます。

```Kotlin
window.addMouseListener(object : MouseAdapter() {

    override fun mouseClicked(e: MouseEvent) { ... }

    override fun mouseEntered(e: MouseEvent) { ... }
})
```


### サンプルコード 2

JVM では、オブジェクトが関数型 Java インターフェイス (つまり、単一の抽象メソッドを持つ Java インターフェイス) のインスタンスである場合、  
インターフェイスの型をプレフィックスとして付けたラムダ式を使用してオブジェクトを作成できます。

```Kotlin
val listener = ActionListener { println("clicked") }
```


