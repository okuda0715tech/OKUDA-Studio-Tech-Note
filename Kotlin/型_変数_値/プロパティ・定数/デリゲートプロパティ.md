- [デリゲートプロパティ](#デリゲートプロパティ)
  - [デリゲートプロパティの重要なポイント](#デリゲートプロパティの重要なポイント)
  - [概要](#概要)
    - [文法](#文法)
    - [仕組み](#仕組み)
    - [例](#例)
  - [標準デリゲート](#標準デリゲート)
    - [Lazy プロパティ](#lazy-プロパティ)
      - [lazy プロパティの正体](#lazy-プロパティの正体)
      - [スレッドコントロール](#スレッドコントロール)
      - [エラーコントロール](#エラーコントロール)
      - [Lazy プロパティと lateinit の違い](#lazy-プロパティと-lateinit-の違い)
    - [Observable プロパティ](#observable-プロパティ)
      - [シグネチャ](#シグネチャ)
    - [Vetoable プロパティ](#vetoable-プロパティ)
      - [概要](#概要-1)
      - [基本形](#基本形)
      - [シグネチャ](#シグネチャ-1)
      - [エラーハンドリング](#エラーハンドリング)
  - [他のプロパティへのデリゲート](#他のプロパティへのデリゲート)
  - [Map にプロパティを保存する](#map-にプロパティを保存する)
  - [State / MutableState への委譲](#state--mutablestate-への委譲)
  - [ローカルなデリゲートプロパティ](#ローカルなデリゲートプロパティ)
  - [プロパティデリゲートの要件](#プロパティデリゲートの要件)
    - [匿名オブジェクト（ReadOnlyProperty / ReadWriteProperty）の場合の要件](#匿名オブジェクトreadonlyproperty--readwritepropertyの場合の要件)
  - [デリゲートプロパティの変換ルール](#デリゲートプロパティの変換ルール)
    - [最適化されたケース](#最適化されたケース)
    - [他のプロパティに委譲する際の変換ルール](#他のプロパティに委譲する際の変換ルール)
  - [デリゲートクラスのプロバイダーを使用する](#デリゲートクラスのプロバイダーを使用する)
  - [引用元資料](#引用元資料)


# デリゲートプロパティ

## デリゲートプロパティの重要なポイント

- デリゲートは、 「委譲」 という意味です。
- デリゲートプロパティは、 `by` を使用して定義します。
- `by` の右側には、委譲先クラスのインスタンスを指定します。
  - 関数によって、インスタンスが生成される場合もあります。
  - まれに、委譲先クラスのインスタンスを生成する 「プロバイダ」 クラスのインスタンスを指定することもあります。 [デリゲートクラスのプロバイダーを使用する](#デリゲートクラスのプロバイダーを使用する) セクション参照。
- 委譲先クラスには、 operator 修飾子付きの getValue() / setValue() 関数が定義されており、プロパティの参照、更新時にそれらが呼び出されます。


## 概要

いくつかの一般的な種類のプロパティでは、必要なときに毎回手動で実装できますが、一度実装してライブラリに追加し、後で再利用する方が便利です。例えば、

- **Lazy プロパティ** : 値は最初のアクセス時にのみ計算されます。

- **Observable プロパティ** : このプロパティの変更についてリスナーに通知されます。

- プロパティごとに個別のフィールドではなく、 **Map** にプロパティを保存します。

- **State プロパティ** : State オブジェクトは、 getValue() を実装しており、 MutableState オブジェクトは、 setValue() を実装しています。そのため、 State / MutableState を返す関数でも、 by による委譲が可能です。

これらのケース (およびその他のケース) に対応するために、 Kotlin は、委譲プロパティをサポートしています。


### 文法

```kotlin
class Example {
    var p: String by Delegate()
}
```

構文は、 `val/var <プロパティ名>: <タイプ> by <式>` です。


### 仕組み

`by` の後の式は、 **デリゲート(委譲先のインスタンス)** です。プロパティに対応するゲッター、および、セッターは、委譲先の `getValue()` 関数と `setValue()` 関数に委譲されます。プロパティ デリゲートは、インターフェイスを実装する必要はありませんが、 `getValue()` 関数 ( `var` プロパティの場合は、追加で `setValue()` 関数も) を定義する必要があります。

### 例

```kotlin
import kotlin.reflect.KProperty

class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}
```

プロパティ p が、 Delegate クラスのインスタンスに委譲している場合、 p プロパティを参照すると、 Delegate の getValue() 関数が呼び出されます。 getValue() 関数の最初のパラメーター ( `thisRef` ) は、 p を保持するインスタンスです。 2 番目のパラメーター ( `property` ) は、 p 自体の説明が保持されます (たとえば、プロパティ名を取得できます)。

```kotlin
val e = Example()
println(e.p)
```

上記のコードは、 getValue() 関数を呼び出し、次のような結果を出力をします。

```
実行結果

Example@33a17727, thank you for delegating 'p' to me!
```

同様に、p に値を代入すると、 setValue() 関数が呼び出されます。 setValue() 関数の最初の 2 つのパラメーターは、 getValue() 関数と同じで、 3 番目のパラメータには、代入する値が渡されてきます。

```kotlin
e.p = "NEW"
```

上記のコードは、 setValue() 関数を呼び出し、次のような結果を出力をします。

```
実行結果

NEW has been assigned to 'p' in Example@33a17727.
```

setValue() 関数内では、実際には、第三引数の value の値を別のプロパティに代入する必要があります。 (詳しくは、 [自分でデリゲートを定義する](#自分でデリゲートを定義する) セクションを参照してください。)

[委譲オブジェクトの要件の仕様](#プロパティデリゲートの要件) は、このドキュメント内にあります。

委譲プロパティは、関数、または、コード ブロック内で宣言できます。クラスのメンバーである必要はありません。 [ローカルなデリゲートプロパティ](#ローカルなデリゲートプロパティ) セクションに例を示します。


## 標準デリゲート

Kotlin 標準ライブラリは、いくつかの便利な種類のデリゲート用のファクトリ メソッドを提供します。


### Lazy プロパティ

[lazy()](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html) は、ラムダを受け取り、 `Lazy<T>` のインスタンスを返す関数です。これは、遅延プロパティを実装するためのデリゲートとして機能します。

- get() の最初の呼び出し
  - lazy() に渡されたラムダが実行され、その結果が記憶されます。
- get() の 2 回目以降の呼び出し
  - 記憶された結果が返されるだけです。

**注意** : Lazy プロパティは、 `val` プロパティにのみ適用することができます。

```kotlin
val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main() {
    println(lazyValue)
    println(lazyValue)
}
```

```
実行結果

computed!
Hello
Hello
```


#### lazy プロパティの正体

`lazy{}` ブロックは、 `lazy()` という名前の関数です。

```kotlin
fun <T> lazy(initializer: () -> T): Lazy<T>

fun <T> lazy(
    mode: LazyThreadSafetyMode,
    initializer: () -> T
): Lazy<T>
```


#### スレッドコントロール

デフォルトでは、 `lazy{}` ブロック内の処理はスレッドセーフです。つまり、値は 1 つのスレッドでのみ計算されますが、すべてのスレッドで同じ値が表示されます。初期化デリゲートの同期が必要でない場合は、複数のスレッドで同時に実行できるようにするために、 `lazy(LazyThreadSafetyMode.PUBLICATION){}` のように、 lazy() 関数の第一引数を指定してください。

プロパティを使用するスレッドと同じスレッドで、初期化が実行されることが確実な場合は、 `LazyThreadSafetyMode.NONE` を lazy() 関数の第一引数に指定してください。これにより、スレッド セーフティの保証や関連するオーバーヘッドは発生しません。


#### エラーコントロール

`lazy{}` ブロック実行中にエラーが発生した場合は、次に プロパティにアクセスした際に、再度 `lazy{}` ブロックが実行され、値の取得が試みられます。


#### Lazy プロパティと lateinit の違い

Lazy プロパティと lateinit の違いについては、 [lateinit と by lazy の比較表](./遅延初期化.md/#lateinit-と-by-lazy-の比較表) を参照してください。


### Observable プロパティ

[Delegates.observable()](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) は、初期値と変更用のハンドラーの 2 つの引数を取ります。

ハンドラーは、プロパティに代入するたびに (代入の実行後に) 呼び出されます。ハンドラーには、代入先のプロパティ、古い値、新しい値の 3 つのパラメーターがあります。

```kotlin
import kotlin.properties.Delegates

class User {
    // 第一引数は、初期値
    // 第二引数は、値が変更された直後に何らかの処理するハンドラー
    var name: String by Delegates.observable("<no name>") {
        prop, old, new ->
        println("$old -> $new")
    }
}

fun main() {
    val user = User()
    user.name = "first"
    user.name = "second"
}
```

```
実行結果

<no name> -> first
first -> second
```

値の代入をインターセプトして拒否したい場合は、 observable() の代わりに [vetoable()](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html) (詳しくは次のセクション [Vetoable プロパティ](#vetoable-プロパティ) を参照してください。) を使用します。 vetoable に渡されるハンドラーは、新しいプロパティ値の代入前に呼び出されます。


#### シグネチャ

```kotlin
inline fun <T> observable(
    initialValue: T,
    crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit
): ReadWriteProperty<Any?, T>
```


### Vetoable プロパティ

#### 概要

Vetoable プロパティは、 Observable プロパティの応用版です。 Observable プロパティのように、値の変更を監視しつつ、値を更新したくない場合は、値の更新を拒否 ( Veto ) することができます。


#### 基本形

```kotlin
var max: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    // ここに、値を更新する条件を記載します。
    // このラムダブロックが true を返す場合のみ、値が更新されます。
    // この場合、新しい値が古い値よりも大きい場合のみ、値を更新します。
    newValue > oldValue
}

println(max) // 0

max = 10
println(max) // 10

max = 5
println(max) // 10
```


#### シグネチャ

```kotlin
inline fun <T> vetoable(
    initialValue: T,
    crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Boolean
): ReadWriteProperty<Any?, T>
```


#### エラーハンドリング

基本的には、値の更新を拒否してもエラーにはなりませんが、意図的にエラーにしたい場合は、以下のように実装することができます。

```kotlin
var max: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    if (newValue > oldValue) true else throw IllegalArgumentException("New value must be larger than old value.")
}

println(max) // 0

max = 10
println(max) // 10

// max = 5 // will fail with IllegalArgumentException
```


## 他のプロパティへのデリゲート

プロパティは、そのゲッターとセッターを別のプロパティに委譲できます。このような委譲は、トップレベル プロパティとクラス プロパティ (メンバーと拡張) の両方で使用できます。委譲プロパティは次のようになります:

- トップレベル プロパティ
- 同じクラスのメンバー、または、拡張プロパティ
- 別のクラスのメンバー、または、拡張プロパティ

プロパティを別のプロパティに委譲するには、委譲名に `::` 修飾子を使用します (例: `this::delegate` 、または、 `MyClass::delegate` )。

公式ドキュメントに記載があったものだけ、以下に例をあげます。

```kotlin
var topLevelInt: Int = 0
class ClassWithDelegate(val anotherClassInt: Int)

class MyClass(var memberInt: Int, val anotherClassInstance: ClassWithDelegate) {
    // 同一クラス内のメンバープロパティ
    var delegatedToMember: Int by this::memberInt
    // トップレベルのプロパティ
    var delegatedToTopLevel: Int by ::topLevelInt

    // 他のクラスのメンバープロパティ
    val delegatedToAnotherClass: Int by anotherClassInstance::anotherClassInt
}
// 他のクラスの拡張プロパティがトップレベルのプロパティにデリゲート
var MyClass.extDelegated: Int by ::topLevelInt
```

これは、たとえば、下位互換性のある方法で、プロパティの名前を変更する場合に役立ちます。つまり、新しいプロパティを導入し、古いプロパティに `@Deprecated` アノテーションを付け、その実装を委譲します。

```kotlin
class MyClass {
    var newName: Int = 0
    @Deprecated("Use 'newName' instead", ReplaceWith("newName"))
    var oldName: Int by this::newName
}

fun main() {
    val myClass = MyClass()
    // このコードには、次のようなワーニングが表示されます。
    // 'oldName: Int' is deprecated. Use 'newName' instead
    myClass.oldName = 42
    println(myClass.newName) // 42
}
```

```
実行結果

42
```


## Map にプロパティを保存する

一般的な使用例の 1 つは、プロパティの値をマップに保存することです。これは、JSON の解析や、他の動的タスクの実行などのアプリケーションで、よく使用します。この場合、マップ インスタンス自体を委譲されたプロパティのデリゲートとして使用できます。

```kotlin
class User(val map: Map<String, Any?>) {
    // 自動的に、プロパティ名が Map のキーに紐づきます。
    val name: String by map
    val age: Int by map
}
```

この例では、コンストラクターはマップを受け取ります。

```kotlin
val user = User(mapOf(
    // 自動的に、 Map のキーが プロパティ名に紐づきます。
    "name" to "John Doe",
    "age" to 25
))
```

委譲されたプロパティは、プロパティの名前に関連付けられた文字列キーを通じてこのマップから値を取得します。

```kotlin
println(user.name) // Prints "John Doe"
println(user.age)  // Prints 25
```

`var` 修飾子と `MutableMap` クラスを使用すれば、再代入可能なプロパティとして使用できます。

```kotlin
class MutableUser(val map: MutableMap<String, Any?>) {
    var name: String by map
    var age: Int by map
}
```


## State / MutableState への委譲

State オブジェクトは、 getValue() を実装しており、 MutableState オブジェクトは、 setValue() を実装しています。そのため、 State / MutableState を返す関数は全て、 by による委譲が可能です。

例えば、作用 API である `produceState` 関数は、 `State` オブジェクトを返すため、次のように、 by を使用した委譲の形での実装が可能です。

```kotlin
@Composable
fun MyComposable(userId: String) {

    val userState by produceState<User?>(initialValue = null, key1 = userId) {
        // サスペンド関数でユーザーを取得
        val fetchedUser = fetchUser(userId)

        // 取得したユーザーデータを State に格納する
        value = fetchedUser
    }
```

produceState 関数は、コンポーザブル関数であるため、別のコンポーザブル関数内からのみ、呼び出し可能です。 produceState のラムダブロックは、 produceState コンポーザブルが、コンポジションに入場した場合、もしくは、キーが変更した場合にのみ再実行されます。そのため、 MyComposable の再コンポーズが発生し、 userState に何度もアクセスされたとしても、ラムダブロックが必要以上に実行されることもありません。


## ローカルなデリゲートプロパティ

ローカルプロパティでもデリゲートプロパティを使用できます。たとえば、ローカルプロパティに Lazy を適用することができます。

```kotlin
fun example(computeFoo: () -> Foo) {
    // memoized は、プログラミング用語で 「メモ化」 という日本語訳になります。
    // 結果をキャッシュしておき、後で再利用することを意味します。
    val memoizedFoo by lazy(computeFoo)

    // isValid() 関数は Foo クラスに定義されているものとします。
    if (someCondition && memoizedFoo.isValid()) {
        memoizedFoo.doSomething()
    }
}
```

上記の例では、 `someCondition` が `false` だった場合は、 `memoizedFoo` は初期化が行われません。これにより、パフォーマンスの向上が見込まれます。


## プロパティデリゲートの要件

読み取り専用プロパティ (val) の場合、デリゲートは、次のパラメータを持つ operator 関数 getValue() を提供する必要があります。

- `thisRef` は、プロパティ所有者と同じタイプ、または、そのスーパータイプである必要があります (拡張プロパティの場合は、拡張されるタイプである必要があります)。

- `property` は、 `KProperty<*>` 、または、そのスーパータイプである必要があります。

getValue() は、プロパティ (または、そのサブタイプ) と同じタイプを返す必要があります。

```kotlin
class Resource

class Owner {
    val valResource: Resource by ResourceDelegate()
}

class ResourceDelegate {
    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {
        return Resource()
    }
}
```

可変プロパティ (var) の場合、デリゲートは、次のパラメータを持つ operator 関数 setValue() を追加で提供する必要があります:

- `thisRef` は、プロパティ所有者と同じ型、または、そのスーパータイプである必要があります (拡張プロパティの場合は、拡張される型である必要があります)。

- `property` は、 `KProperty<*>` 型、または、そのスーパータイプである必要があります。

- `value` は、プロパティ (または、そのスーパータイプ) と同じ型である必要があります。

```kotlin
class Resource

class Owner {
    var varResource: Resource by ResourceDelegate()
}

class ResourceDelegate(private var resource: Resource = Resource()) {
    operator fun getValue(thisRef: Owner, property: KProperty<*>): Resource {
        return resource
    }

    // デリゲートされるプロパティが val の場合は、 setValue() 関数は不要
    operator fun setValue(thisRef: Owner, property: KProperty<*>, value: Any?) {
        if (value is Resource) {
            resource = value
        }
    }
}
```

getValue() および setValue() 関数は、上記の例のように、デリゲートクラスのメンバー関数として定義することもできますし、拡張関数として定義することもできます。特に、拡張関数として定義すると、これらの関数をもともと提供していないオブジェクトにプロパティをデリゲートする必要がある場合に便利です。両方の関数は、 operator キーワードでマークする必要があります。


### 匿名オブジェクト（ReadOnlyProperty / ReadWriteProperty）の場合の要件

Kotlin 標準ライブラリのインターフェイス ReadOnlyProperty および ReadWriteProperty を使用すると、新しいクラスを作成せずに、匿名オブジェクトとして、デリゲートを作成できます。これらは、必要な関数 ( getValue() 及び setValue() ) を定義できます。これらの関数は operator 関数ではなく、 override 関数である点に注意してください。

getValue() は ReadOnlyProperty で宣言され、 ReadWriteProperty は、それを拡張して setValue() を追加します。つまり、 ReadOnlyProperty が必要な場合は、いつでも ReadWriteProperty からアップキャストすることができます。あるいは、 val プロパティとすることで、自動的にアップキャストしてくれます。

```kotlin
fun resourceDelegate(resource: Resource = Resource()): ReadWriteProperty<Any?, Resource> =
    object : ReadWriteProperty<Any?, Resource> {
        var curValue = resource
        override fun getValue(thisRef: Any?, property: KProperty<*>): Resource = curValue
        override fun setValue(thisRef: Any?, property: KProperty<*>, value: Resource) {
            curValue = value
        }
    }

// val でプロパティを定義することによって、
// ReadWriteProperty を ReadOnlyProperty として使用
val readOnlyResource: Resource by resourceDelegate()
// var でプロパティを定義することによって、
// ReadWriteProperty を ReadWriteProperty として使用
var readWriteResource: Resource by resourceDelegate()
```


## デリゲートプロパティの変換ルール

内部的には、 Kotlin コンパイラは、委譲されたプロパティの種類に応じて、補助プロパティ ( `ぷrパティ名$delegate` ) を生成し、それらに委譲します。

最適化のため、コンパイラは [いくつかのケースで補助プロパティを生成しません。](#最適化されたケース) [別のプロパティに委譲する](#他のプロパティに委譲する際の変換ルール) 例で、最適化について学習します。

たとえば、プロパティ prop の場合、非表示のプロパティ prop$delegate が生成され、アクセサのコードは、この追加プロパティに委譲するだけです。

```kotlin
class C {
    var prop: Type by MyDelegate()
}

// this code is generated by the compiler instead:
class C {
    private val prop$delegate = MyDelegate()
    var prop: Type
        get() = prop$delegate.getValue(this, this::prop)
        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}
```

Kotlin コンパイラは、引数で prop に関する必要な情報をすべて提供します。最初の引数 this は外部クラス C のインスタンスを参照し、this::prop は prop 自体を記述する KProperty 型のリフレクション オブジェクトです。


### 最適化されたケース

委譲が次の場合は、$delegate フィールド (前のセクション [デリゲートプロパティの変換ルール](#デリゲートプロパティの変換ルール) を参照) は省略されます:

- 参照されたプロパティ:

```kotlin
class C<Type> {
    private var impl: Type = ...
    var prop: Type by ::impl
}
```

- 名前付きオブジェクト:

```kotlin
object NamedObject {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String = ...
}

val s: String by NamedObject
```

- 同じモジュール内のバッキング フィールドとデフォルトのゲッターを持つ final val プロパティ:

```kotlin
val impl: ReadOnlyProperty<Any?, String> = ...

class A {
    val s: String by impl
}
```

- 定数式、 Enum エントリ、 `this` 、 `null` 。this の例:

```kotlin
class A {
    operator fun getValue(thisRef: Any?, property: KProperty<*>) ...

    val s by this
}
```


### 他のプロパティに委譲する際の変換ルール

別のプロパティに委譲する場合、Kotlin コンパイラは、参照先のプロパティへの即時アクセスを生成します。つまり、コンパイラは prop$delegate フィールドを生成しません。この最適化により、メモリを節約できます。

たとえば、次のコードを見てみましょう。

```kotlin
class C<Type> {
    private var impl: Type = ...
    var prop: Type by ::impl
}
```

prop 変数のプロパティ アクセサーは、委譲されたプロパティの getValue および setValue 演算子をスキップして impl 変数を直接呼び出すため、 KProperty 参照オブジェクトは、必要ありません。

上記のコードの場合、コンパイラは次のコードを生成します。

```kotlin
class C<Type> {
    private var impl: Type = ...

    var prop: Type
        get() = impl
        set(value) {
            impl = value
        }

    fun getProp$delegate(): Type = impl // This method is needed only for reflection
}
```


## デリゲートクラスのプロバイダーを使用する

`provideDelegate` operator 関数を定義すると、プロパティ実装が委譲されるオブジェクトを作成するためのロジックを拡張できます。by の右側で使用されるオブジェクトが、 provideDelegate operator 関数をメンバー、または、拡張関数として定義している場合、その関数が呼び出されて、プロパティ委譲インスタンスが作成されます。

provideDelegate の考えられる使用例の 1 つは、プロパティの初期化時に、その一貫性をチェックすることです。

たとえば、バインド前にプロパティ名をチェックするには、次のように記述します。

```kotlin
class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {
    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }
}

class ResourceLoader<T>(id: ResourceID<T>) {
    operator fun provideDelegate(
        thisRef: MyUI,
        prop: KProperty<*>
    ): ReadOnlyProperty<MyUI, T> {
        // 委譲先のクラスを生成する前に、
        // (制御フローをインターセプトして)
        // このブロックで、独自の処理を実施できます。

        // プロパティ名をチェックする例
        checkProperty(thisRef, prop.name)

        // 委譲先のクラスのインスタンスを生成
        return ResourceDelegate()
    }

    private fun checkProperty(thisRef: MyUI, name: String) {
        // おそらく、この例では、
        // 画像系のプロパティなら、 xxxImage というプロパティ名なっているか？
        // 文字列系のプロパティなら、 xxxText というプロパティ名なっているか？
        // という感じのチェックをする想定だと思われる。
    }
}

class MyUI {
    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }

    val image by bindResource(ResourceID.image_id)
    val text by bindResource(ResourceID.text_id)
}
```

provideDelegate のパラメータは getValue のパラメータと同じです:

- `thisRef` は、プロパティ所有者と同じ型、または、そのスーパータイプである必要があります (拡張プロパティの場合は拡張される型である必要があります)。

- `property` は、 `KProperty<*>` 型、または、そのスーパータイプである必要があります。

provideDelegate メソッドは、 MyUI インスタンスの作成中に、各プロパティに対して呼び出され、必要な検証をすぐに実行します。

プロパティとそのデリゲート間のバインディングをインターセプトする、この機能がなければ、同じ機能を実現するには、プロパティ名を明示的に渡す必要があり、これはあまり便利ではありません:

```kotlin
class MyUI {
    // プロパティ名を直接渡しているあまり良くない例
    val image by bindResource(ResourceID.image_id, "image")
    val text by bindResource(ResourceID.text_id, "text")
}

fun <T> MyUI.bindResource(
    id: ResourceID<T>,
    propertyName: String
): ReadOnlyProperty<MyUI, T> {
    checkProperty(this, propertyName)
    // create delegate
}
```

生成されたコードでは、 provideDelegate メソッドが呼び出され、補助プロパティ ( prop$delegate ) が初期化されます。 provideDelegate メソッドが存在しない場合と存在する場合を比較してみると、次のようになります。

provideDelegate 関数が存在する場合 : 

```kotlin
class C {
    var prop: Type by MyDelegateProvider()
}

// 上記のコードがコンパイラーによって生成されたコードは次のようになります。
class C {
    // provideDelegate 関数を呼び出すコードが生成されます。
    // provideDelegate 関数は、デリゲートクラスを返します。
    private val prop$delegate = MyDelegateProvider().provideDelegate(this, this::prop)
    var prop: Type
        // デリゲートクラスから getValue や setValue にアクセスします。
        get() = prop$delegate.getValue(this, this::prop)
        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}
```

provideDelegate 関数が存在しない場合 : 

```kotlin
class C {
    var prop: Type by MyDelegate()
}

// 上記のコードがコンパイラーによって生成されたコードは次のようになります。
class C {
    // デリゲートクラスのインスタンスを直接生成するコードが、
    // コンパイラによって、生成されます。
    private val prop$delegate = MyDelegate()
    var prop: Type
        get() = prop$delegate.getValue(this, this::prop)
        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}
```

provideDelegate メソッドは、補助プロパティの作成にのみ影響し、ゲッター、または、セッター用に生成されるコードには、影響しません。 (上記の例では、 provideDelegate の有無にかかわらず、 `get() = prop$delegate.getValue(this, this::prop)` の部分は、同じです。)

標準ライブラリの PropertyDelegateProvider インターフェースを使用すると、新しいクラスを作成せずに、デリゲート プロバイダーを作成できます。

```kotlin
val provider = PropertyDelegateProvider { thisRef: Any?, property ->
    ReadOnlyProperty<Any?, Int> {_, property -> 42 }
}
val delegate: Int by provider
```


## 引用元資料

- [Delegated properties](https://kotlinlang.org/docs/delegated-properties.html#providing-a-delegate)



