- [プロパティ](#プロパティ)
  - [プロパティの宣言](#プロパティの宣言)
  - [var と val](#var-と-val)
  - [アクセッサーの自動生成](#アクセッサーの自動生成)
  - [アクセッサーが定義できない場合](#アクセッサーが定義できない場合)
  - [カスタムゲッター](#カスタムゲッター)
  - [カスタムセッター](#カスタムセッター)
  - [カスタムアクセッサーの注意点](#カスタムアクセッサーの注意点)
  - [アクセッサーにアノテーションを付与したり、可視性を変更する](#アクセッサーにアノテーションを付与したり可視性を変更する)
  - [自動生成されるアクセッサーの名前が特殊なケース](#自動生成されるアクセッサーの名前が特殊なケース)
  - [バッキングフィールド](#バッキングフィールド)
    - [前提](#前提)
    - [概要](#概要)
    - [バッキングフィールドへのアクセス](#バッキングフィールドへのアクセス)
    - [バッキングフィールドが自動生成される条件](#バッキングフィールドが自動生成される条件)
  - [バッキングプロパティ](#バッキングプロパティ)


# プロパティ

## プロパティの宣言

**文法**

```kotlin
var <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]
```


## var と val

- var
  - 可変
  - デフォルトのゲッターとセッターが、自動的に定義される。

- val
  - 読み取り専用
  - デフォルトのゲッターが、自動的に定義される。

関数の引数は、自動的に `val` で定義されます。そのため、 `val a: String` や `var a: String` のように、明示的に `val / var` を記載することはできません。


## アクセッサーの自動生成

Kotlin では、プロパティを定義すると、デフォルトのゲッターとセッターが自動的に生成されます。

メンバ変数のことを Kotlin では、 「プロパティ」 と呼び、 Java では 「フィールド」 と呼びますが、  
まさに、プログラミングの世界では、アクセッサーが自動生成されるかどうかで、呼び方が変わっており、  
自動生成されるものを 「プロパティ」 と呼び、されないものを 「フィールド」 と呼びます。


## アクセッサーが定義できない場合

プライマリコンストラクタでプロパティを定義した場合は、そのプロパティにカスタムアクセッサーを定義することができません。

```kotlin
// name にカスタムアクセッサーを定義することはできない。
class Example(val name: String) { /*...*/ }
```

カスタムアクセッサーを定義したい場合には、例えば以下のようにします。

```kotlin
// この nameParam は、コンストラクタ内でのみ有効なローカル引数
class Example(nameParam: String) {
    // この name は、クラス外からもアクセス可能なプロパティ
    val name = nameParam
} 
```

上記のように、プライマリコンストラクタの引数に val や var を付与しなかった場合、コンストラクタ内でのみ利用できるローカルな引数となります。 (プロパティとして定義されません。)

そのため、そのクラスの外から、その変数にアクセスすることはできません。


## カスタムゲッター

**基本形**

```kotlin
class Rectangle(val width: Int, val height: Int) {
    val area: Int
        get() = this.width * this.height
}
```


## カスタムセッター

プロパティが `var` で定義されている場合のみ、カスタムセッターを定義することができます。

カスタムセッターは、通常、プロパティに値を代入する場合は常に呼ばれます。ただし、プロパティの初期化時には呼ばれません。次の例で言うと、 "Unknown" をセットする際には、セッターは呼ばれません。


**基本形**

以下の例では、空文字 ( "" ) が設定されそうになった場合に、カスタムセッターで "No Name" を設定します。

```kotlin
class Person {
    var name: String = "Unknown"

        // 引数 value には、 name プロパティに代入された値が渡ってきます。
        //
        // セッターの引数名は、 value にするのが慣例ですが、
        // 任意の名前に変更することも可能です。
        set(value) {
            // field はバックフィールド(実際に値を保持する隠れた変数)を指します。
            // セッターやゲッターの中で直接プロパティにアクセスする際には、 field を使用します。
            field = if (value.isNotBlank()) value else "No Name"
        }
}

fun main() {
    val person = Person()

    person.name = "John"
    println(person.name)  // 出力: John

    person.name = ""  
    println(person.name)  // 出力: No Name
}
```


## カスタムアクセッサーの注意点

アクセッサー内部で、プロパティ名を直接参照すると、  
アクセッサーが再帰呼び出しされ、無限ループに陥る可能性があります。

そのため、アクセッサー内部では、後述するバッキングフィールド ( `field` 変数) を  
使用するのが基本的な形となります。


## アクセッサーにアノテーションを付与したり、可視性を変更する

アクセッサーにアノテーションを付与したり、可視性を変更したいが、  
デフォルトの実装を変更したくない場合は、本体を定義せずにアクセサーを定義できます。

```kotlin
var setterVisibility: String = "abc"
    private set // 本体なしで可視性のみ指定

var setterWithAnnotation: Any? = null
    @Inject set // 本体なしでアノテーションのみ指定
```


## 自動生成されるアクセッサーの名前が特殊なケース

プロパティの名前が `is` で始まる場合、自動生成されるアクセッサーの名前が通常とは異なります。

例えば、 `isOpen` というプロパティを定義した場合、  
ゲッターは、 `isOpen()` という名前になります。  
セッターは、 `setOpen()` という名前になります。

このルールは、 `Boolean` 型のプロパティに限った話ではなく、  
どんな型のプロパティにも適用されます。


## バッキングフィールド

### 前提

バッキングフィールドを理解するための前提として、まずは、以下のことを把握しておく必要があります。

```
プロパティ自体がデータを保持しているわけではなく、プロパティの中に定義された、 「バッキングフィールド」 が値を保持している。

プロパティとは、バッキングフィールドとそのアクセッサーの総称のことである。
```


### 概要

バッキングフィールドとは、プロパティのデータを実際に保持している変数のことです。


### バッキングフィールドへのアクセス

バッキングフィールドへアクセスするには、アクセッサー内部で `field` とう名前の変数を参照します。

**例**

```kotlin
// 初期化時は、値がバッキングフィールドへ直接代入されます。
// (セッターは使用されません。)
var counter = 0
    set(value) {
        if (value >= 0)
            field = value
    }
```


### バッキングフィールドが自動生成される条件

以下の条件のいずれかを満たした場合に、バッキングフィールドは自動生成されます。

- 少なくとも 1 つのアクセサー (ゲッター or セッター) のデフォルト実装を使用する場合
- カスタムアクセッサーが `field` 識別子を参照している場合

上記以外の場合は、バッキングフィールドを生成する必要がないため、自動生成せずにリソースを節約しています。例えば、以下の場合は、バッキングフィールドが自動生成されません。

```kotlin
// val であるため、デフォルトセッターは定義されていません。
val isEmpty: Boolean
    get() = this.size == 0
```


## バッキングプロパティ

もし、自動生成されるバッキングフィールドでは満たせない要件がある場合は、独自にバッキングフィールドを定義することが可能です。  
独自に定義したバッキングフィールドを、 **「バッキングプロパティ」** と呼びます。

例えば、以下のようにバッキングプロパティを使用します。

```kotlin
// バッキングプロパティ
private var _table: Map<String, Int>? = null
// 通常のプロパティ
public val table: Map<String, Int>
    get() {
        if (_table == null) {
            _table = HashMap()
        }
        return _table ?: throw AssertionError("別のスレッドによって null が設定されました。")
    }
```

【参考】  
上記の例で、なぜバッキングプロパティを定義する必要があったかというと、  
自動生成されるバッキングフィールドは、元のプロパティと同じ型で生成されます。  
しかし、上記の例では、バッキングフィールドを null 許容型としたいため、元のプロパティと型が一致しません。  
そのため、独自のバッキングプロパティを定義しています。






