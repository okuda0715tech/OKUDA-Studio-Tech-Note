- [プロパティ参照](#プロパティ参照)
  - [概要](#概要)
  - [メリット](#メリット)
    - [関数の代わりに使用できる](#関数の代わりに使用できる)
    - [実行時にインスタンスを指定できる](#実行時にインスタンスを指定できる)
  - [基本形](#基本形)
    - [val の場合](#val-の場合)
    - [var の場合](#var-の場合)
  - [プロパティ参照を関数の代わりとして使用する](#プロパティ参照を関数の代わりとして使用する)
  - [KProperty の種類](#kproperty-の種類)
  - [バインドされた参照とアンバインドされた参照](#バインドされた参照とアンバインドされた参照)
  - [拡張プロパティでもプロパティ参照が使用可能](#拡張プロパティでもプロパティ参照が使用可能)
  - [Java リフレクションとの相互運用性](#java-リフレクションとの相互運用性)


# プロパティ参照

## 概要

プロパティ参照を使用すると、そのプロパティは自分で定義した型ではなく、 `KProperty<V>` or `KMutableProperty<V>` の型が取得されます。ジェネリック `<V>` には、実際のプロパティの型が入ります。

[KProperty - kotlinlang.org](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/)  
[KMutableProperty - kotlinlang.org](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-mutable-property/)

例えば、 String 型の val プロパティを定義した場合は、そのプロパティのプロパティ参照では、 `KProperty<String>` が取得されます。 var の場合は、 `KMutableProperty<String>` が取得されます。




## メリット

プロパティ参照を使用するメリットは主に二つあります。

### 関数の代わりに使用できる

プロパティ参照は、関数が必要な場面で使用することが可能です。
例えば、 `String::length` というプロパティ参照は `(String) -> Int` という関数型のプロパティに代入することが可能になります。

つまり、 `(レシーバーの型) -> プロパティの型` という関数型として使用可能です。


### 実行時にインスタンスを指定できる

プロパティ参照を使用することで、コンパイル時にはプロパティだけを指定することが可能です。後から、実行時に 「どのインスタンスのプロパティを参照するか」 を決定することができるようになります。


## 基本形

プロパティに第一級オブジェクトとしてアクセスするには、コロン二つ `::` でアクセスします。

### val の場合

```kotlin
val x = 1

fun main() {
    println(::x.get()) // 1
    println(::x.name) // x
    println(::x.isConst) // false
    println(::x.isLateinit) // false
}
```

`::x` は、 `KProperty0<Int>` 型のインスタンスです。


### var の場合

```kotlin
var y = 1

fun main() {
    ::y.set(2)
    println(y) // 2
}
```

`::y` は、 `KMutableProperty0<Int>` 型のインスタンスです。


## プロパティ参照を関数の代わりとして使用する

プロパティ参照は、一つのジェネリックな引数を持つ関数の代わりに使用することが可能です。

```kotlin
val strs = listOf("a", "bc", "def")
println(strs.map(String::length)) // [1, 2, 3]
```

`map()` 関数の引数 ( transform ) は以下のとおり、一つのジェネリックな引数を持つ関数型であるため、プロパティ参照を渡すことが可能です。

```kotlin
public inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
}
```


## KProperty の種類

KProperty には三種類のサブクラスがあります。

- `KProperty0<out V>`
  - バインドされたプロパティ参照で使用します。
  - V は、フィールドの型です。
- `KProperty1<T, out V>`
  - アンバインドされたプロパティ参照で使用します。
  - T はレシーバーの型です。
- `KProperty2<D, E, out V>`
  - レシーバーを二つ持つプロパティ
  - 例えば、クラスのメンバーに定義された拡張プロパティがあります。
  - E がプロパティが定義された拡張クラス、 D がそれをメンバーに持つクラスを示します。


## バインドされた参照とアンバインドされた参照

コロン二つの前に、 **インスタンス** が指定されているプロパティ参照を **バインドされた参照** と呼び、 **クラス** が指定されているプロパティ参照を **アンバインドされた参照** と呼びます。

```kotlin
// バインドされた参照
val prop = "abc"::length
Log.d("test", "result = ${prop.get()}") // result = 3

// アンバインドされた参照
val prop2 = String::length
Log.d("test", "result = ${prop2.get("abcd")}") // result = 4
```

バインドされた参照は、その参照にレシーバーの情報を含んでいます。  
そのため、そのプロパティ参照を参照する時にレシーバーを与えることはできません。

逆に、アンバインドされた参照は、その参照にレシーバーの情報を含んでいません。  
そのため、そのプロパティ参照を参照する時にレシーバーが必要になります。

コロン二つ ( `::` )  の前にクラス名もインスタンス名も指定されていない場合は、 `this` の指定が省略されています。


## 拡張プロパティでもプロパティ参照が使用可能

```kotlin
val String.lastChar: Char
    get() = this[length - 1]

fun main() {
    println(String::lastChar.get("abc")) // c
}
```


## Java リフレクションとの相互運用性

Kotlin のリフレクションオブジェクトと Java のリフレクションオブジェクトを相互に変換する拡張機能があります。以下はその一例です。それ以外の例は、 `kotlin.reflect.jvm` パッケージを参照してください。

```kotlin
import kotlin.reflect.jvm.*

class A(val p: Int)

fun main() {
    println(A::p.javaGetter) // "public final int A.getP()"
    println(A::p.javaField)  // "private final int A.p"
}
```

Java クラスに対応する Kotlin クラスを取得するには、 `.kotlin` 拡張プロパティを使用します。

```kotlin
fun getKClass(o: Any): KClass<Any> = o.javaClass.kotlin
```





