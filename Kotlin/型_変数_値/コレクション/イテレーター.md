- [イテレーター](#イテレーター)
  - [イテレーターのメリット](#イテレーターのメリット)
  - [基本的な使用方法](#基本的な使用方法)
  - [使用例](#使用例)
  - [List に特化した ListIterator](#list-に特化した-listiterator)
  - [MutableIterator](#mutableiterator)
  - [MutableListIterator](#mutablelistiterator)


# イテレーター

## イテレーターのメリット

イテレーターは、コレクションの基礎となる構造を公開せずに要素への順次アクセスを提供するオブジェクトです。そのため、コレクションの具体的な実装を気にすることなく、使用することが可能です。

大きなコレクションを扱う場合、イテレーターを使用するとメモリの使用量を最適化できます。イテレーターは、要素を一度に一つずつ取り出すため、大きなコレクション全体をメモリに読み込むことなく反復処理できます。

イテレーターを使用すると、コレクションを変更する際に発生する可能性のある同期化や ConcurrentModificationException のような問題を回避できます。イテレーターは、コレクションの状態が変更された場合にそれを検知し、適切に処理します。


## 基本的な使用方法

Set や List などの Iterable<T> インターフェイスの継承したイテレーターは、 iterator() 関数を呼び出すことで取得できます。

イテレータを取得すると、それはコレクションの最初の要素を指します。 next() 関数を呼び出すと、この要素が返され、次の要素が存在する場合はイテレータの位置を次の要素に移動します。

イテレーターが最後の要素を通過すると、要素の取得には使用できなくなります。 以前の位置にリセットすることもできません。 コレクションを再度反復するには、新しいイテレーターを作成します。


## 使用例

```kotlin
val numbers = listOf("one", "two", "three", "four")
val numbersIterator = numbers.iterator()
while (numbersIterator.hasNext()) {
    println(numbersIterator.next())
    // one
    // two
    // three
    // four
}
```

`for` ループや `forEach` は暗黙的にイテレーターを使用しています。以下は、上記と等価です。

```kotlin
val numbers = listOf("one", "two", "three", "four")
for (item in numbers) {
    println(item)
    // one
    // two
    // three
    // four
}
```

```kotlin
val numbers = listOf("one", "two", "three", "four")
numbers.forEach {
    println(it)
    // one
    // two
    // three
    // four
}
```


## List に特化した ListIterator

ListIterator は、 List のみで使用でき、前方からのイテレーションと後方からのイテレーションに対応しています。

逆方向反復は、関数 `hasPrevious()` および `previous()` によって実装されます。 さらに、 ListIterator は関数 `nextIndex()` および`previousIndex()` を使用して、次のインデックス番号を取得することが可能です。

```kotlin
val numbers = listOf("one", "two", "three", "four")
val listIterator = numbers.listIterator()
while (listIterator.hasNext()) listIterator.next()
println("Iterating backwards:")
// Iterating backwards:
while (listIterator.hasPrevious()) {
    print("Index: ${listIterator.previousIndex()}")
    println(", value: ${listIterator.previous()}")
    // Index: 3, value: four
    // Index: 2, value: three
    // Index: 1, value: two
    // Index: 0, value: one
}
```

順方向反復と逆方向反復をリストの最後まで実施しなくても、イテレーターがリストの途中の要素をポイントしている状態で、前後任意の方向にイテレートできます。

ListIterator は、通常のイテレーターとは違い、イテレーターが端まで到達しても、逆方向にイテレートすることで何度も要素を取得することが可能です。


## MutableIterator

MutableIterator は要素を削除する remove() 関数を持っています。イテレート中にコレクションから要素を削除できます。

```kotlin
val numbers = mutableListOf("one", "two", "three", "four")
// MutableIterator の取得方法は通常のイテレータを同じ
// 違うのは、コレクションが Mutable コレクションだということ
val mutableIterator = numbers.iterator()

// イテレーターを最初の要素に移動
mutableIterator.next()
// イテレーターが示している要素を削除
mutableIterator.remove()    
println("$numbers") // [two, three, four]
```


## MutableListIterator

MutableIterator の場合は、要素の削除しかできませんが、 MutableIistIterator では、要素の追加や入れ替えが可能です。

```kotlin
val numbers = mutableListOf("one", "four", "four") 
val mutableListIterator = numbers.listIterator()

mutableListIterator.next()
// 要素の追加
mutableListIterator.add("two")
println(numbers) // [one, two, four, four]
mutableListIterator.next()
// 要素の入れ替え
mutableListIterator.set("three")   
println(numbers) // [one, two, three, four]
```






