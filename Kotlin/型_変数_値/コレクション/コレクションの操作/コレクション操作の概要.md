- [コレクション操作の概要](#コレクション操作の概要)
  - [拡張関数とメンバー関数](#拡張関数とメンバー関数)
  - [一般的な操作](#一般的な操作)
  - [書き込み操作](#書き込み操作)


# コレクション操作の概要

## 拡張関数とメンバー関数

コレクションの関数には、拡張関数とメンバー関数があります。

コレクションのメンバー関数をカスタマイズ実装する場合は、ベース実装が行われているクラス ( `AbstractCollection` , `AbstractList` , `AbstractSet` , `AbstractMap` など) を使用すると良いでしょう。


## 一般的な操作

一般的な操作は、読み取り専用のコレクションと書き込み可能なコレクションの両方で提供されています。一般的な操作は以下のグループに分類されます。

- Transformations
- Filtering
- plus and minus operators
- Grouping
- Retrieving collection parts
- Retrieving single elements
- Ordering
- Aggregate operations

これらについて、詳細は後ほど記載しますが、これらの操作は元のコレクションに影響を与えません。つまり、新しいコレクションを生成して、元のコレクションとは切り離され、要素も別のインスタンスを参照します。以下は、フィルター操作の例です。

```kotlin
val numbers = listOf("one", "two", "three", "four")  

numbers.filter { it.length > 3 }
println("numbers are still $numbers")
// numbers are still [one, two, three, four]

val longerThan3 = numbers.filter { it.length > 3 }
println("numbers longer than 3 chars are $longerThan3")
// numbers longer than 3 chars are [three, four]
```

コレクションの操作の中には、格納先のコレクションを指定できるオプションが備わっているものもあります。格納先のコレクションを指定すれば、新たに生成されたオブジェクトに格納されることはありません。格納先を指定する場合は、 to という接尾辞を付与した関数名になる場合が多いです。例えば、 filter() は filterTo() となり、 associate() は associateTo() となります。

```kotlin
val numbers = listOf("one", "two", "three", "four")
val filterResults = mutableListOf<String>()

numbers.filterTo(filterResults) { it.length > 3 }
numbers.filterIndexedTo(filterResults) { index, _ -> index == 0 }

// 両方の操作の結果を含みます。
println(filterResults) // [three, four, one]
```

上記以外にも、 grouping , flatterning などの関数で格納先を指定することができます。その他については、次のドキュメントを参照してください。 [Package kotlin.collections](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/)


## 書き込み操作

書き込み操作の中には、同じ処理を行うけれど、処理する場所が異なるペアとなる関数があります。つまり、処理を元のコレクション上で行うか、それとも別のコレクションを生成して、そのコレクション上で行うかという違いです。例えば、 sort() 関数は、元のコレクション上でソートを行いますが、 sorted() 関数は、新しいコレクションを生成し、そのコレクション上でソートを行います。

```kotlin
val numbers = mutableListOf("one", "two", "three", "four")

// 別のコレクションを生成して、その中でソートを行う
val sortedNumbers = numbers.sorted()

// 並び順が異なるため false
println(numbers == sortedNumbers)

// レシーバーの中でソートを行う
numbers.sort()

// 並び順が同じため true
println(numbers == sortedNumbers)
```






