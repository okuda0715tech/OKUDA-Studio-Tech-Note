- [要素の並べ替え](#要素の並べ替え)
  - [【前提知識】Comparable と Comparator について](#前提知識comparable-と-comparator-について)
    - [Comparable と Comparator の共通点](#comparable-と-comparator-の共通点)
    - [Comparable インターフェース](#comparable-インターフェース)
    - [Comparator インターフェース](#comparator-インターフェース)
    - [Comparable と Comparator のどちらを使うべきか](#comparable-と-comparator-のどちらを使うべきか)
  - [【このページの前提】読み取り専用のコレクションに対する並べ替え](#このページの前提読み取り専用のコレクションに対する並べ替え)
    - [compareTo() 関数には中置記法がある](#compareto-関数には中置記法がある)
    - [より簡潔に Comparator を定義する](#より簡潔に-comparator-を定義する)
  - [並べ替え関数](#並べ替え関数)
    - [並べ替え関数の一覧](#並べ替え関数の一覧)
    - [sorted() と sortedDescending()](#sorted-と-sorteddescending)
    - [sortedBy() と sortedByDescending()](#sortedby-と-sortedbydescending)
    - [sortedWith() と compareBy()](#sortedwith-と-compareby)
    - [reversed()](#reversed)
    - [asReversed()](#asreversed)
    - [reversed() と asReversed() の使い分け](#reversed-と-asreversed-の使い分け)
    - [shuffled()](#shuffled)


# 要素の並べ替え

## 【前提知識】Comparable と Comparator について

オブジェクトの大小比較を行うためのインターフェースとして、 `Comparable` と `Comparator` という二種類のインターフェースが用意されています。それぞれについて見ていきます。


### Comparable と Comparator の共通点

Comparable インターフェースは compareTo() 関数を持っており、 Comparator インターフェースは compare() 関数を持っていますが、これらの処理結果の見方は同じです。

正の数を返すか、負の数を返すか、 0 を返すかで大小比較の結果を表現しています。


### Comparable インターフェース

`Comparable` インターフェースは大小比較したいオブジェクト自身が実装すべきインターフェースです。 `compareTo()` 関数を持っており、この関数はレシーバーと引数で与えられたオブジェクトの間で大小比較を行います。

プリミティブ型のオブジェクトには最初から実装されており、これらは自然順序と呼ばれます。数値型の場合は、数字の大小関係がそのままオブジェクトの大小関係となります。文字列の場合は辞書式順序で先に出てくるほうが小さい値であると定義されています。


### Comparator インターフェース

`Comparator` インターフェースは比較処理を行うオブジェクトが実装すべきインターフェースです。 `compare()` 関数を持っており、第一引数と第二引数のオブジェクト間で大小比較を行います。

Comparisons.kt ファイルに Comparator の拡張関数 `thenBy()` が定義されており、 compare() 関数での比較結果が同一と見なされた場合は、 thenBy() 関数でさらに大小比較を行うことが可能です。

```kotlin
val numbers = mutableListOf("one", "two", "three", "four")

// 文字列の長さが同じ場合はアルファベット順にソート
numbers.sortWith(compareBy<String> { it.length }.thenBy { it })
println("Sort by Comparator: $numbers")
// Sort by Comparator: [one, two, four, three]
```


### Comparable と Comparator のどちらを使うべきか

特に理由がない場合は、 Comparable よりも Comparator を使用する方が良いでしょう。以下に Comparator を選択するメリットを記載します。

- 複数の比較方法を動的に提供できる
  - あるクラスで Comparable を実装すると、その一種類の比較方法しか使用できません
  - Comparator は、複数作成すれば、複数の比較方法が使用できます。
- 並べ替え機能をオブジェクト本体から切り離して実装できる (関心の分離)


## 【このページの前提】読み取り専用のコレクションに対する並べ替え

このページでは、読み取り専用のコレクションに対する並べ替え関数を紹介します。そられは、別のコレクションを生成して返しますが、要素は元のコレクションと同じインスタンスを参照します。書き込み可能なコレクションに対する並べ替え処理については、別紙で記載予定です。


### compareTo() 関数には中置記法がある

Kotlin では、 `compareTo()` 関数には中置記法が用意されています。

```kotlin
val a = 1
val b = 2

if ((a compareTo b) < 0) {
    // do something.
}
```


### より簡潔に Comparator を定義する

より簡潔に Comparator を定義する方法として、 `compareBy()` 関数が用意されています。この関数は以下の要件を必要とします。

- ラムダ式を引数にとります。
- ラムダ式は、 Comparable オブジェクトを返す必要があります。

```kotlin
println(listOf("aaa", "bb", "c").sortedWith(compareBy { it.length }))
// [c, bb, aaa]
```


## 並べ替え関数

### 並べ替え関数の一覧

| 関数名               | 引数 (ラムダ式)     | 使用する I/F |
| -------------------- | ------------------- | ------------ |
| sorted()             | なし                | Comparable   |
| sortedDescending()   | なし                | Comparable   |
| sortedBy()           | T -> Comparable\<R> | Comparable   |
| sortedByDescending() | T -> Comparable\<R> | Comparable   |
| sortedWith()         | Comparator          | Comparator   |
| reversed()           | なし                | Iterator     |
| asReversed()         | なし                | Iterator     |
| shuffled()           | なし                | なし         |


### sorted() と sortedDescending()

`sorted()` 関数と `sortedDescending()` 関数を使用してコレクションをソートすることが可能です。要素は Comparable オブジェクトである必要があります。

```kotlin
val numbers = listOf("one", "two", "three", "four")

println("Sorted ascending: ${numbers.sorted()}")
// Sorted ascending: [four, one, three, two]

println("Sorted descending: ${numbers.sortedDescending()}")
// Sorted descending: [two, three, one, four]
```


### sortedBy() と sortedByDescending()

`sortedBy()` 関数と `sortedByDescending()` 関数は、引数にラムダ式をとります。ラムダ式では、大小比較の基準となる Comparable オブジェクトを返します。ラムダ式内では、 it でコレクションの各要素を参照することが可能です。

```kotlin
val numbers = listOf("one", "two", "three", "four")

val sortedNumbers = numbers.sortedBy { it.length }
println("Sorted by length ascending: $sortedNumbers")
// Sorted by length ascending: [one, two, four, three]

val sortedByLast = numbers.sortedByDescending { it.last() }
println("Sorted by the last letter descending: $sortedByLast")
// Sorted by the last letter descending: [four, two, one, three]
```


### sortedWith() と compareBy()

`sortedWith()` 関数を使用することで `Comparator` オブジェクトを使用したソートを行うことが可能です。 Comparator オブジェクトでは、 compare() 関数をオーバーライドします。

```kotlin
val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }

println(listOf("aaa", "bb", "c").sortedWith(lengthComparator))
// [c, bb, aaa]
```

`compareBy()` 関数を使用することで、 Comparator オブジェクトをより簡単に生成することが可能です。

```kotlin
// it はコレクションの要素を示します。
println(listOf("aaa", "bb", "c").sortedWith(compareBy { it.length }))
// [c, bb, aaa]
```


### reversed()

`reversed()` 関数は現在の要素の順番を逆順に入れ替えます。 Comparable インターフェースも Comparator インターフェースも使用せず、 Iterator で逆順にアクセスします。

```kotlin
val numbers = listOf("one", "two", "three", "four")
println(numbers.reversed())
// [four, three, two, one]
```


### asReversed()

`asReversed()` 関数も `reversed()` 関数同様に、元のコレクションの逆順のコレクションを返す関数です。

```kotlin
val numbers = listOf("one", "two", "three", "four")
val reversedNumbers = numbers.asReversed()
println(reversedNumbers)
// [four, three, two, one]
```


### reversed() と asReversed() の使い分け

reversed() と asReversed() の違いは以下の通りです。

- 新しいコレクションを生成するかどうか
  - reversed() は、新しいコレクションを生成します。
  - asReversed() は、元のコレクションのラッパークラスを生成するだけで新しいコレクションは生成しません
- 一方の要素の更新がもう一方に影響するかどうか
  - reversed() は、影響しません。
  - asReversed() は、影響します。
- パフォーマンス
  - reversed() は、新しいコレクションを生成する分、生成コストが高いですが、生成時に並び替えが完了するため、その後の毎回のアクセスは高速です。
  - asReversed() は、単なるラッパークラスを生成するだけの分、生成コストが低いですが、参照時に毎回並び替えが発生するため、その後の毎回のアクセスは低速です。

元のコレクションが書き込み可能なリストかどうかわからない場合は、 reversed() を使用するほうが無難です。なぜなら、元のコレクションの変更の影響を受けないためです。

以下は、 asReversed() で生成したオブジェクトが元のオブジェクトの修正によって影響を受ける例です。

```kotlin
val numbers = mutableListOf("one", "two", "three", "four")
val reversedNumbers = numbers.asReversed()

println(reversedNumbers)
// [four, three, two, one]

numbers.add("five")

println(reversedNumbers)
// [five, four, three, two, one]
```


### shuffled()

`shuffled()` 関数は、要素の順番をランダムで入れ替えた新しいコレクションを返します。

```kotlin
val numbers = listOf("one", "two", "three", "four")
println(numbers.shuffled())
// [two, four, one, three] などランダムな入れ替え後のコレクション
```

引数に `Random` オブジェクトを渡すことで、乱数の生成方法を変更することも可能です。





