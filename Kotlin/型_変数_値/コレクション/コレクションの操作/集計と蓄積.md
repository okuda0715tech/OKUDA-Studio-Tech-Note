- [集計と蓄積](#集計と蓄積)
  - [最小値 or 最大値の取得](#最小値-or-最大値の取得)
    - [基本形](#基本形)
    - [類似関数の一覧](#類似関数の一覧)
    - [maxByOrNull() と minByOrNull()](#maxbyornull-と-minbyornull)
    - [maxWithOrNull() と minWithOrNull()](#maxwithornull-と-minwithornull)
    - [maxOfOrNull() と minOfOrNull()](#maxofornull-と-minofornull)
    - [maxOfWithOrNull() と minOfWithOrNull()](#maxofwithornull-と-minofwithornull)
  - [平均値の取得](#平均値の取得)
  - [合計値の取得](#合計値の取得)
    - [基本形](#基本形-1)
    - [要素に関数を適用してから合計する](#要素に関数を適用してから合計する)
  - [要素数の取得](#要素数の取得)
  - [Fold and reduce](#fold-and-reduce)
    - [基本形](#基本形-2)
    - [要素の末尾から蓄積する](#要素の末尾から蓄積する)
    - [ラムダ式でインデックスを受けとる](#ラムダ式でインデックスを受けとる)
    - [空のコレクションの場合](#空のコレクションの場合)
    - [蓄積の途中経過を保持する](#蓄積の途中経過を保持する)


# 集計と蓄積

## 最小値 or 最大値の取得

### 基本形

次の関数で、最小値 or 最大値を取得することができます。空のコレクションの場合は、 null を返します。コレクションの要素が Comparable を実装している必要があります。

```kotlin
val numbers = listOf(6, 42, 10, 4)

println("Max: ${numbers.maxOrNull()}") // Max: 42
println("Min: ${numbers.minOrNull()}") // Min: 4
```


### 類似関数の一覧

種類が多いので max の方のみ記載しています。 min の方の関数もあります。

| 関数名            |
| ----------------- |
| maxByOrNull()     |
| maxWithOrNull()   |
| maxOfOrNull()     |
| maxOfWithOrNull() |

それぞれの関数について、関数名末尾の `OrNull` がない関数も存在しています。それらは、空のコレクションの場合に null ではなく、 `NoSuchElementException` を返します。


### maxByOrNull() と minByOrNull()

各要素にラムダ式 ( selector 関数) を適用し、その結果の中から一番大きい値 or 一番小さい値を生成する元の要素を返します。同一の値を生成する要素がある場合は、最初の要素を返します。空のコレクションの場合は、 null を返します。

```kotlin
val numbers = listOf(5, 42, 10, 4)
val min3Remainder = numbers.minByOrNull { it % 3 }
println(min3Remainder) // 42
```


### maxWithOrNull() と minWithOrNull()

`Comparator` オブジェクトを引数に受け取り、 Comparator オブジェクトの判定に従って、最大 or 最小と判定された要素を返します。

```kotlin
val strings = listOf("one", "two", "three", "four")
val longestString = strings.maxWithOrNull(compareBy { it.length })
println(longestString) // three
```


### maxOfOrNull() と minOfOrNull()

各要素にラムダ式 ( selector 関数) を適用し、その結果の中から一番大きい値 or 一番小さい値を返します。空のコレクションの場合は、 null を返します。 (同一の値を返す要素が複数存在しても、それらの最大値 or 最小値は同じなので、どちらを返すか気にする必要はありません。)

```kotlin
val numbers = listOf("one", "two", "three", "four")
val longestLength = numbers.maxOfOrNull { it.length }
println(longestLength) // 5
```


### maxOfWithOrNull() と minOfWithOrNull()

【注意】この関数はややこしいので、あまり使わないほうが良いかもしれません。

各要素に selector 関数を適用した結果について、 Comparator で定義された大小比較を行い、最大値 or 最小値と判定された selector 関数適用後の値を返します。

```kotlin
val numbers = listOf("one", "two", "three", "four")
// 第二引数が selector 関数です。
// 第一引数は Comparator です。
val max = numbers.maxOfWithOrNull(compareBy { it % 3 }) { it.length }
println(max) // 5
```


## 平均値の取得

`average()` 関数は、コレクションの要素が数値型の場合に、その平均値を返します。

```kotlin
val numbers = listOf(6, 42, 10, 4)

println("Average: ${numbers.average()}") // Average: 15.5
```


## 合計値の取得

### 基本形

`sum()` 関数は、コレクションの要素が数値型の場合に、その合計値を返します。

```kotlin
val numbers = listOf(6, 42, 10, 4)

println("Sum: ${numbers.sum()}") // Sum: 62
```


### 要素に関数を適用してから合計する

`sumOf()` 関数は、各要素に selector 関数を適用してからその値の合計を返します。

```kotlin
val numbers = listOf(5, 3, 4)
println(numbers.sumOf { it % 2 }) // 2
```


## 要素数の取得

`count()` 関数は、コレクション内の要素の数を返します。

```kotlin
val numbers = listOf(6, 42, 10, 4)

println("Count: ${numbers.count()}") // Count: 4
```


## Fold and reduce

### 基本形

[reduce()](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/reduce.html) 関数と [fold()](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/fold.html) 関数は、コレクションの要素を蓄積し、最終的に全てを蓄積した一つの値を返します。 reduce という単語には、 「少なくする、縮小する」 という意味があり、 fold という単語には、 「折りたたむ、収める」 という意味があります。

これらの関数は、蓄積方法を定義するラムダ式を引数にとります。ラムダ式の第一引数は、蓄積された値で、第二引数は元のコレクションの各要素です。

reduce() と fold() の違いは以下の二点です。

- 初期値をとるかどうか
  - fold() は初期値をとります。
  - reduce() は初期値をとりません。
- ラムダ式の一回目の処理で、ラムダ式のパラメータが何を示すか
  - fold() の場合、第一引数は初期値、第二引数はコレクションの最初の要素を示します。
  - reduce() の場合、第一引数はコレクションの最初の要素、第二引数はコレクションの二番目の要素を示します。

```kotlin
val numbers = listOf(5, 2, 1)

// reduce の例
val simpleSum = numbers.reduce { sum, element -> sum + element }
println(simpleSum) // 8

// fold の例
val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }
println(sumDoubled) // 16

// 間違った実装: 最初の要素は二倍されません。
val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } 
println(sumDoubledReduce) // 11
```


### 要素の末尾から蓄積する

fold() と reduce() の代わりに `foldRight()` と `reduceRight()` を使用することで、要素を末尾から蓄積することができます。注意すべき点は、ラムダ式の第一引数と第二引数が入れ替わる点です。つまり、第一引数が次の要素を示し、第二引数が蓄積された値を示します。

```koltin
val numbers = listOf(5, 2, 1)
val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }
println(sumDoubledRight) // 16
```


### ラムダ式でインデックスを受けとる

もし、ラムダ式で要素のインデックスを使用したい場合には、次の関数を使用します。

- reduceIndexed()
- foldIndexed()
- reduceRightIndexed()
- foldRightIndexed()

```kotlin
val numbers = listOf(5, 2, 1)
val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }
println(sumEven) // 6

val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }
println(sumEvenRight) // 6
```


### 空のコレクションの場合

これまで記載した関数は、コレクションが空の場合には、例外を投げます。 null を返したい場合には、 `OrNull` を関数名の末尾に付与します。


### 蓄積の途中経過を保持する

`runningFold()` 関数や `runningReduce()` 関数を使用すると、蓄積の途中経過を保持することが可能です。これらの関数は、 List を返します。 List の各要素に蓄積の途中経過が格納されます。

ラムダ式内でインデックスを使用したい場合は `runningFoldIndexed()` と `runningReduceIndexed()` も用意されています。

```kotlin
val strings = listOf("a", "b", "c")

println(strings.runningFold("s") { acc, string ->
    acc + string
})
// [s, sa, sab, sabc]

println(strings.runningFoldIndexed("s") { index, acc, string ->
    acc + string + index
})
// [s, sa0, sa0b1, sa0b1c2]
```

runningFold() 関数の別名呼び出しとして `scan()` 関数が用意されていますが、現時点 ( 2024 年 3 月時点) でこれは実験段階のようです。





