- [グループ化](#グループ化)
  - [基本形](#基本形)
  - [要素を変換しながらグループピングする](#要素を変換しながらグループピングする)
  - [グルーピング後に操作を行いたい場合](#グルーピング後に操作を行いたい場合)


# グループ化

## 基本形

`groupBy()` 関数を使用するとコレクションの要素をグルーピングすることが可能です。この関数は、引数にラムダ式をとり、 Map オブジェクトを返します。ラムダ式の結果が Map のキーとなります。 Map の値は、 List オブジェクトになっており、そのキーに該当する元の要素の値が格納されます。つまり、関数のシグネチャは以下のようになっています。

```kotlin
fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>>
```

```kotlin
val numbers = listOf("one", "two", "three", "four", "five")

println(numbers.groupBy { it.first().uppercase() })
// {O=[one], T=[two, three], F=[four, five]}
```


## 要素を変換しながらグループピングする

第二引数にラムダ式を渡すことによって、要素を変換しながらグループピングすることができます。

```kotlin
val numbers = listOf("one", "two", "three", "four", "five")

println(numbers.groupBy(keySelector = { it.first() }, valueTransform = { it.uppercase() }))
// {o=[ONE], t=[TWO, THREE], f=[FOUR, FIVE]}
```


## グルーピング後に操作を行いたい場合

グルーピング後に操作を行いたい場合は、 `groupingBy()` 関数を使用します。この関数は `Grouping` オブジェクトを返します。

Grouping オブジェクトには主に以下の関数が用意されています。

- eachCount()
  - グループごとに要素の数をカウントします。
- fold() と reduce()
  - 詳細は別紙に記載予定ですが、グループごとに要素を合計するような処理です。
- aggregate()
  - fold() と reduce() では十分にカスタマイズできない場合に使用します。
  - aggregate という英単語には、 「集計」 という意味があります。

```kotlin
// eachCount() 関数の例

val numbers = listOf("one", "two", "three", "four", "five", "six")
println(numbers.groupingBy { it.first() }.eachCount())
```

```kotlin
// aggregate() 関数の例

val numbers = listOf(3, 4, 5, 6, 7, 8, 9)

val aggregated = numbers.groupingBy { it % 3 }.aggregate { key, accumulator: StringBuilder?, element, first ->
    if (first) // first element
    StringBuilder().append(key).append(":").append(element)
    else
    accumulator!!.append("-").append(element)
}

println(aggregated.values) // [0:3-6-9, 1:4-7, 2:5-8]
```

