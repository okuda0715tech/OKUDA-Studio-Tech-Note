- [コレクション間の変換](#コレクション間の変換)
  - [単純な変換方法](#単純な変換方法)
  - [Set を加工してから List に変換](#set-を加工してから-list-に変換)
  - [List を Map に変換](#list-を-map-に変換)


# コレクション間の変換

## 単純な変換方法

List, Set, Map を相互に変換するには、コピー関数と同じ `toList()` や `toMutableList()` などを使用します。

```kotlin
val sourceList = mutableListOf(1, 2, 3)    
val copySet = sourceList.toMutableSet()
copySet.add(3)
copySet.add(4)    
println(copySet) // [1, 2, 3, 4]
```


## Set を加工してから List に変換

```kotlin
val numbers = setOf(1, 2, 3)

// 要素の値に対して何らかの処理を実施してから、新しく生成した List に格納する。
// ここでは、要素をそれぞれ 3 倍する。
println(numbers.map { it * 3 }) // [3, 6, 9]

// Set の要素のインデックスと値を使用して、何らかの処理を実施してから、新しく生成した List に格納する。
println(numbers.mapIndexed { idx, value -> value * idx }) // [0, 2, 6]
```

プログラミングで使用される map という名前の関数は、何らかの処理を実施して、その結果を別のインスタンスに格納するものが多い。これは関数型プログラミングで、 「ある配列の各要素に対して、一定の関数を適用して、別の配列に格納する。」 という関数が map という名前になっていることに由来していると思われる。 ( map という英単語自体には、 「関数を適用する」 という意味はありません)


## List を Map に変換

List の要素が Map のキーになり、 `associateWith()` 関数の引数で渡した関数の結果が Map の値になります。

```kotlin
val numbers = listOf("one", "two", "three", "four")
println(numbers.associateWith { it.length }) // {one=3, two=3, three=5, four=4}
```

