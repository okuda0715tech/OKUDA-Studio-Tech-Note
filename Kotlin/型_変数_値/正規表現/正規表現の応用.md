- [正規表現の応用](#正規表現の応用)
  - [Raw string / Multiline strings](#raw-string--multiline-strings)
    - [概要](#概要)
    - [`\Q` と `\E` で文字列を囲む](#q-と-e-で文字列を囲む)
    - [$ 記号は特殊文字として認識される場合がある](#-記号は特殊文字として認識される場合がある)
  - [三種類の実装方法](#三種類の実装方法)
    - [Java からある旧式の実装方法](#java-からある旧式の実装方法)
    - [Kotlin から登場した簡潔な実装方法](#kotlin-から登場した簡潔な実装方法)
  - [一致判定](#一致判定)
    - [指定したパターンに該当するものが含まれているかの判定](#指定したパターンに該当するものが含まれているかの判定)
    - [全ての文字が指定したパターンに該当するかの判定](#全ての文字が指定したパターンに該当するかの判定)
    - [指定したパターンに該当するものが何個含まれているかを返す](#指定したパターンに該当するものが何個含まれているかを返す)
    - [前方で一致したパターンを後方のパターンで使用する（後方参照）](#前方で一致したパターンを後方のパターンで使用する後方参照)
    - [名前付きキャプチャグループでの後方参照](#名前付きキャプチャグループでの後方参照)
  - [一致した文字列を取得](#一致した文字列を取得)
    - [パターンに最初に一致した文字列を取得する](#パターンに最初に一致した文字列を取得する)
    - [パターンに一致した文字列を全て取得する](#パターンに一致した文字列を全て取得する)
    - [パターンに一致した文字列から複数の指定した部分を取得する（ find + グループ化）](#パターンに一致した文字列から複数の指定した部分を取得する-find--グループ化)
    - [パターンに一致した文字列から一部の指定した部分を取得する（ replace + グループ化）](#パターンに一致した文字列から一部の指定した部分を取得する-replace--グループ化)
  - [置換](#置換)
    - [パターンに一致した文字列を全て置換する](#パターンに一致した文字列を全て置換する)
    - [パターンに最初に一致した文字列を置換する](#パターンに最初に一致した文字列を置換する)


# 正規表現の応用

## Raw string / Multiline strings

### 概要

Raw string 、または Multiline strings と呼ばれる文字列の定義方法があります。これは、文字列をダブルクオーテーション三つ ( `"""` ) で囲んで文字列を定義する方法です。

Raw strings で定義された文字列は、特殊文字とみなされる文字を単なる文字列と見なすようになります。ただし、これは完全ではない点に注意してください。

文字が 「特殊文字」 なのか、 「単なる文字」 なのかを判定するタイミングは、二回あります。一つは、文字列の定義時です。もう一つは、正規表現のパターンがコンパイルされる時です。 Raw strings は、前者の判定時にのみ有効な設定です。後者の判定時にのみ有効な設定方法は、 `\Q` と `\E` で文字列を囲む方法です。この方法については次の項で説明します。


### `\Q` と `\E` で文字列を囲む

正規表現の文字列を `\Q` と `\E` で囲むことで、正規表現のコンパイル時に 「特殊文字」 と見なされる文字を 「単なる文字」 と見なします。

例えば、以下のような正規表現のパターンについて考えます。

```kotlin
val regex = "(2.4)*(3)=7.2"
```

`()` や `.` や `*` は、正規表現上の特殊文字であるため、これらを単なる文字列と見なすためには、バックスラッシュでエスケープする必要があります。エスケープしたものは以下のようになります。

```kotlin
val regex = "\\(2\\.4\\)\\*\\(3\\)=7\\.2"
```

バックスラッシュがたくさんありすぎて、元の文字列がどのようなものか非常にわかりづらくなってしまっています。これを解決する方法が `\Q` と `\E` です。これらの特殊文字で囲まれた文字列は、正規表現のコンパイル時に常に 「単なる文字」 と見なされます。 Q と E を使用すると、以下のように非常に見やすい形で表現できます。

```kotlin
val regex = "\\Q(2.4)*(3)=7.2\\E"
```


### $ 記号は特殊文字として認識される場合がある

Raw strings の内部でも `$変数名` や `${変数名}` のような記述は可能になっています。そのため、 `$` 記号が特殊文字として扱われる可能性があります。意図せず `$` が特殊文字として認識されてしまった場合は `${'$'}` と記述してください。これは通常の `$` 記号として認識されます。

```kotlin
// a が変数名だと見なされ、 $ という文字として認識されない。
val a = """$a"""

// $a という文字として認識される。
val a = """${'$'}a"""
```


## 三種類の実装方法

### Java からある旧式の実装方法

```kotlin
val regex = "[a-z]"
val p: Pattern = Pattern.compile(regex)
val m: Matcher = p.matcher("c")
println("${m.matches()}") // true
```

### Kotlin から登場した簡潔な実装方法

Kotlin から登場した実装方法は、 Regex インスタンスの生成方法でさらに二つの実装方法に分けられます。

```kotlin
val regex = Regex("[a-z]")
val result = regex.matches("c")
println("$result") // true
```

```kotlin
val regex = "[a-z]".toRegex()
val result = regex.matches("c")
println("$result") // true
```


## 一致判定

### 指定したパターンに該当するものが含まれているかの判定

指定したパターンに該当するものが含まれているかどうかを判定するには、 `containsMatchIn()` 関数を使用します。

```kotlin
val target = "1 apple. 2 bananas."
val regex = Regex("""\d""")
val isMatched = regex.containsMatchIn(target)
println(isMatched) // true
```


### 全ての文字が指定したパターンに該当するかの判定

全ての文字が指定したパターンに該当するかどうかを判定するには、 `matches()` 関数を使用します。

```kotlin
val target = "123"
val regex = Regex("""\d+""")
val isMatched = regex.matches(target)
println(isMatched) // true

val target = "123a"
val regex = Regex("""\d+""")
val isMatched = regex.matches(target)
println(isMatched) // false
```


### 指定したパターンに該当するものが何個含まれているかを返す

```kotlin
var matchedCount = 0
var index = 0
val p = Pattern.compile("111")
val m = p.matcher("111111")
while (m.find(index)) {
    matchedCount++

    // 前回一致した部分の開始地点の次の文字から検索を再開したい場合
    index = m.start() + 1

    // 前回一致した部分の終了地点の次の文字から検索を再開したい場合
    index = m.end()
}
Log.d("test", "matchedCount = $matchedCount")
```


### 前方で一致したパターンを後方のパターンで使用する（後方参照）

`<head></head>` や `<body></body>` のように、前方で一致したパターンについて、後方でも同じパターンで一致するかどうか判定したい場合もあると思います。その場合は、後方参照 ( `\n` : n には正の整数が入る ) を使用します。

以下の例では、正規表現の `\\1` の部分で、その前にあるグループ `(div|span)` の一致した方の文字列を参照しています。つまり、 `<dev>` なら `</div>` で終わる文字列とマッチングし、 `<span>` なら `</span>` とマッチングします。

```kotlin
private fun check(p: Pattern, target: String) {
    val m = p.matcher(target)
    if (m.find()) {
        println("○")
    } else {
        println("×")
    }
}

val str1 = "Today is <div>Tuesday</div>"
val str2 = "Border Color is <span>red</span>"
val str3 = "<span>Hello</div>"

val regex = "<(div|span)>.*?</\\1>" // 後方参照
val p = Pattern.compile(regex)

check(p, str1) // ○
check(p, str2) // ○
check(p, str3) // ×
```


### 名前付きキャプチャグループでの後方参照

グループに名前を付けることで、後方参照の際に、名前で参照することができるようになります。

```kotlin
// インデックスで後方参照した場合
val regex = "<(div|span)>.*?</\\1>"
// 名前で後方参照した場合
val regex = "<(?<tag>(div|span))>.*?</\\k<tag>>"
```

`x` というグループに対して名前をつけるには、 `(?<name>x)` のように定義します。

後方参照の際には、 `\k<name>` のように参照します。


## 一致した文字列を取得

### パターンに最初に一致した文字列を取得する

パターンに最初に一致した文字列を取得するには、 `find()` 関数を使用します。

```kotlin
val target = "123a456"
val regex = Regex("""\d+""")
val found = regex.find(target)
println(found?.value) // 123

val target = "123a456"
val regex = Regex("""\d""")
val found = regex.find(target)
println(found?.value) // 1
```


### パターンに一致した文字列を全て取得する

パターンに一致した文字列を全て取得するには、 `findAll()` 関数を使用します。

```kotlin
val target = "123a456"
val regex = Regex("""\d""")
val found = regex.findAll(target)
found.forEach {
    print("${it.value},")
}
```

```
実行結果
1,2,3,4,5,6,
```


### パターンに一致した文字列から複数の指定した部分を取得する（ find + グループ化）

グループ化することで、パターンに一致した文字列の中から必要な部分をより簡単に抽出することが可能になります。丸カッコ `()` でグループを定義することができます。

```kotlin
val target = "090-1111-2222"
val regex = Regex("""(\d+)-(\d+)-(\d+)""")
val found = regex.find(target)
found?.groups?.forEach {
    println("${it?.value}")
}
```

`groups` は `Collection` クラスとなっており、要素番号 0 には、グループに関係ない 「パターンに一致した全体の文字列」 が格納されます。続いて、要素番号 1 から順に、グループの定義順に対応して格納されています。

```
実行結果
090-1111-2222
090
1111
2222
```


### パターンに一致した文字列から一部の指定した部分を取得する（ replace + グループ化）

```kotlin
val target = "090-2345-6789"
val regex = Regex("""(\d+)-(\d+)-(\d+)""")
val replaced = regex.replace(target, "$2")
print(replaced) // 2345
```

`replace()` 関数の第二引数で、 `$数字` を渡すと、パターンに一致した文字列の特定のグループを抽出することが可能です。 $1 はグループの一番目、 $2 はグループの二番目 ... といった具合に取得できます。 $0 はグループに関係なく、パターンに一致した文字列全体を返します。

このように `replace()` 関数の引数で $n でグループを取得できる機能を **後方参照** と呼ぶそうです。


## 置換

### パターンに一致した文字列を全て置換する

```kotlin
val target = "090-1111-2222"
val regex = Regex("""\d""")
val replaced = regex.replace(target, "x")
print(replaced) // xxx-xxxx-xxxx
```


### パターンに最初に一致した文字列を置換する

```kotlin
val target = "090-1111-2222"
val regex = Regex("""\d""")
val replaced = regex.replaceFirst(target, "x")
print(replaced) // x90-1111-2222
```








