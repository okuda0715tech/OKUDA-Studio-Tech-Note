- [時間の計測](#時間の計測)
  - [時間・期間の計測](#時間期間の計測)
    - [Duration クラスの概要](#duration-クラスの概要)
    - [Duration を生成する](#duration-を生成する)
    - [Duration 同士の計算](#duration-同士の計算)
    - [Duration を文字列として表現する](#duration-を文字列として表現する)
    - [単位の変換](#単位の変換)
    - [Duration 同士の比較](#duration-同士の比較)
    - [任意のフォーマットで文字列化する](#任意のフォーマットで文字列化する)
  - [時間を計測する](#時間を計測する)
    - [ある処理を実行するのにかかった時間を計測する](#ある処理を実行するのにかかった時間を計測する)
    - [ある瞬間を記録する](#ある瞬間を記録する)
    - [時間的差分を計算する](#時間的差分を計算する)
    - [締め切りやタイムアウトに到達したかのチェック](#締め切りやタイムアウトに到達したかのチェック)
  - [Time Sources](#time-sources)
    - [プラットフォームごとのデフォルトタイムソース](#プラットフォームごとのデフォルトタイムソース)
    - [タイムソースを生成する](#タイムソースを生成する)
  - [参考](#参考)


# 時間の計測

## 時間・期間の計測

### Duration クラスの概要

Kotlin では `Duration` クラスを使用して時間・期間を表します。 Duration は `DurationUnit` という Enum クラスを使用して、以下の単位で表現されます。

- NANOSECONDS
- MICROSECONDS
- MILLISECONDS
- SECONDS
- MINUTES
- HOURS
- DAYS

Duration は、正の数、負の数、 0 、正の無限の値、負の無限の値で表現可能です。


### Duration を生成する

Duration を生成するには、 Int, Long, Double クラスに用意されている拡張プロパティを使用します。以下の拡張プロパティが用意されています。

- nanoseconds
- microseconds
- milliseconds
- seconds
- minutes
- hours
- days

```kotlin
val fiveHundredMilliseconds: Duration = 500.milliseconds
val zeroSeconds: Duration = 0.seconds
val tenMinutes: Duration = 10.minutes
val negativeNanosecond: Duration = (-1).nanoseconds
val infiniteDays: Duration = Double.POSITIVE_INFINITY.days
val negativeInfiniteDays: Duration = Double.NEGATIVE_INFINITY.days

println(fiveHundredMilliseconds) // 500ms
println(zeroSeconds)             // 0s
println(tenMinutes)              // 10m
println(negativeNanosecond)      // -1ns
println(infiniteDays)            // Infinity
println(negativeInfiniteDays)    // -Infinity
```

拡張プロパティには、以下のようなゲッターが定義されており、 Duration クラスの生成と、単位をナノ秒に変換した後の値の保持を行っています。

```kotlin
@kotlin.internal.InlineOnly
public inline val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)
```


### Duration 同士の計算

Durattion オブジェクト同士は、数値型のように計算を行うことができます。

```kotlin
val fiveSeconds: Duration = 5.seconds
val thirtySeconds: Duration = 30.seconds

println(fiveSeconds + thirtySeconds)
// 35s
println(thirtySeconds - fiveSeconds)
// 25s
println(fiveSeconds * 2)
// 10s
println(thirtySeconds / 2)
// 15s
println(thirtySeconds / fiveSeconds)
// 6.0
println(-thirtySeconds)
// -30s
println((-thirtySeconds).absoluteValue)
// 30s
```


### Duration を文字列として表現する

`toString()` 関数を使用することで、 Duration を文字列表現に変換することが可能です。

```kotlin
// 第一引数は表示したい単位
// 第二引数は表示したい小数点以下の桁数
println(5887.milliseconds.toString(DurationUnit.SECONDS, 2))
// 5.89s
```


### 単位の変換

Duration オブジェクトの単位を変換したい場合には、以下の関数を使用します。

- inWholeNanoseconds
- inWholeMicroseconds
- inWholeSeconds
- inWholeMinutes
- inWholeHours
- inWholeDays

```kotlin
val thirtyMinutes: Duration = 30.minutes
println(thirtyMinutes.inWholeSeconds)
// 1800
```

または、以下のように変換することもできます。

Duration の toInt() / toDouble() / toLong() 関数を実行し、その引数に変換後の単位を指定します。

```kotlin
println(270.seconds.toDouble(DurationUnit.MINUTES))
// 4.5
```


### Duration 同士の比較

Duration 同士が同じ期間を表しているかどうかを判定したい場合には、 `==` 演算子を使用します。

```kotlin
val thirtyMinutes: Duration = 30.minutes
val halfHour: Duration = 0.5.hours
println(thirtyMinutes == halfHour)
// true
```

Duration 同士の大小比較を行いたい場合には、不等号 ( `<` / `<=` / `>` / `>=` ) を使用します。

```kotlin
println(3.seconds < 2500.milliseconds)
// false
```


### 任意のフォーマットで文字列化する

Duration を任意のフォーマットで文字列化するには、 `toComponents(hours, minutes, seconds, nanoseconds)` 関数を使用します。

```kotlin
val thirtyMinutes: Duration = 30.minutes
println(thirtyMinutes.toComponents { hours, minutes, _, _ -> "${hours}h:${minutes}m" })
// 0h:30m
```


## 時間を計測する

時間の経過を追跡する方法を説明します。こられのライブラリを使用すると以下の処理が簡単に実装可能です。

- ある処理を実行するのにかかった時間の計測する
- ある瞬間を記録する
- 二つの瞬間の比較や差分を算出する
- ある瞬間からどれだけ時間が経過したかを確認する
- ある瞬間から指定した時間が経過したかどうかを確認する。


### ある処理を実行するのにかかった時間を計測する

ある処理を実行するのにかかった時間を計測する場合

```kotlin
val timeTaken = measureTime {
    Thread.sleep(100)
}
println(timeTaken) // (例) 100.642002ms
```

ある処理を実行するのにかかった時間を計測し、さらに、実行結果を受け取る場合

```kotlin
// この例では、結果を分解宣言で受け取っている。
val (value, timeTaken) = measureTimedValue {
    Thread.sleep(100)
    42
}
println(value) // 42
println(timeTaken) // (例) 100.642002ms
```

デフォルトでは、両方の関数はモノトニックタイムソースを使用します。モノトニックタイムソースとは、プラットフォームで利用可能な最も正確な時刻ソースです。


### ある瞬間を記録する

```kotlin
import kotlin.time.*

fun main() {
    val timeSource = TimeSource.Monotonic
    // ナノ秒 (マイナス 9 乗) 単位で現在の時間的記録を取得しているっぽい。
    val mark = timeSource.markNow()
}
```

返ってくる時間はそのままでは使えなさそう。二つの瞬間の差分を算出して、経過した時間を取得するのに使用するっぽい。


### 時間的差分を計算する

二つの同じタイムソースの `TimeMark` オブジェクトの差分を計測するには、差分演算子 ( `-` ) を使用します。

大小比較を行うには、比較演算子を使用します。 ( `<` , `>` )

```kotlin
val timeSource = TimeSource.Monotonic

val mark1 = timeSource.markNow()
// 0.5 秒のスリープ
Thread.sleep(500)
val mark2 = timeSource.markNow()

val elapsed = mark2 - mark1
println("$elapsed") // (例) 500.619831ms

// mark2 は mark1 より後に取得しているので、 true になります。
println(mark2 > mark1)
```


### 締め切りやタイムアウトに到達したかのチェック

締め切りやタイムアウトに到達したかのチェックを行うには、 `hasPassedNow()` 拡張関数、もしくは、 `hasNotPassedNow()` 拡張関数が使用できます。

```kotlin
val timeSource = TimeSource.Monotonic
val mark1 = timeSource.markNow()
val fiveSeconds: Duration = 5.seconds
val mark2 = mark1 + fiveSeconds

println(mark2.hasPassedNow())
// false

Thread.sleep(6000)
println(mark2.hasPassedNow())
// true
```


## Time Sources

デフォルトでは、時間や時刻は **モノトニックタイムソース** で計測されます。モノトニックタイムソースは、進むだけで戻ることはありません。そして、タイムゾーンなどのバリエーションの影響を受けません。モノトニックタイムソースとは別のタイムソースに、 **「経過実時間 ( Elapsed real time ) 」** があります。これは、 **「壁時計の時間 ( wall-clock time ) 」** としても知られています。経過実時間は、ある時間的なポイントからの相対的な値で算出されます。


### プラットフォームごとのデフォルトタイムソース

この表は、各プラットフォームでのモノトニックタイムのデフォルトソースです。

| プラットフォーム       | ソース                                                              |
| ---------------------- | ------------------------------------------------------------------- |
| Kotlin / JVM           | `System.nanoTime()`                                                 |
| Kotlin / JS (Node.js)  | `process.hrtime()`                                                  |
| Kotlin / JS (ブラウザ) | `window.performance.now()` or `Date.now()`                          |
| Kotlin / Native        | `std::chrono::high_resolution_clock` or `std::chrono::steady_clock` |
|                        |                                                                     |


### タイムソースを生成する

異なるタイムソースを使用したい場合もあるでしょう。例えば、 Android では、 `System.nanoTime()` は、デバイスがアクティブである間だけ時間をカウントします。もし、デバイスが深いスリープ状態に入ると時間の追跡は失われます。深いスリープ状態に入った場合も時間を追跡するには、 `SystemClock.elapsedRealtimeNanos()` 関数を使用するタイムソースを生成する方法があります。

```kotlin
// これは object 宣言です。
// 新しくクラスを宣言しているようなものです。
// Abstract～ クラスを継承しています。
object RealtimeMonotonicTimeSource : AbstractLongTimeSource(DurationUnit.NANOSECONDS) {
    override fun read(): Long = SystemClock.elapsedRealtimeNanos()
}
```

そして、時間計測を行うために、上記のタイムソースを使用します。

```kotlin
fun main() {
    val elapsed: Duration = RealtimeMonotonicTimeSource.measureTime {
        Thread.sleep(100)
    }
    println(elapsed) // (例) 103 ms
}
```


## 参考

`kotlin.time` パッケージについてより詳しい情報が必要な場合は、標準ライブラリ API リファレンスを参照してください。

[Package kotlin.time](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/)


