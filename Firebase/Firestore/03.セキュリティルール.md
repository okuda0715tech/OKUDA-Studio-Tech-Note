- [セキュリティルール](#セキュリティルール)
  - [サンプル：Firebase Authentication と連携して、自分のデータにだけアクセスできるようにする](#サンプルfirebase-authentication-と連携して自分のデータにだけアクセスできるようにする)
    - [🔐 Firestore セキュリティルール（ Firebase Console で設定）](#-firestore-セキュリティルール-firebase-console-で設定)
    - [Kotlin (Android) 側のコードサンプル](#kotlin-android-側のコードサンプル)
      - [ログイン処理（匿名ログインなどでも OK）](#ログイン処理匿名ログインなどでも-ok)
      - [Firestore への読み書き処理](#firestore-への読み書き処理)
    - [🔒 補足：認証されていないとどうなる？](#-補足認証されていないとどうなる)
  - [引用元資料](#引用元資料)


# セキュリティルール

## サンプル：Firebase Authentication と連携して、自分のデータにだけアクセスできるようにする

### 🔐 Firestore セキュリティルール（ Firebase Console で設定）

Firestore のセキュリティルールは、独自のドメイン固有言語（DSL: Domain Specific Language） で書かれています。この言語は、Firebase が提供するもので、 JavaScript に似た構文を持っていますが、専用に設計されています。

```js
rules_version = '2';
service cloud.firestore {
    match /databases/{database}/documents {
        match /users/{userId} {
            allow read, write: if request.auth != null && request.auth.uid == userId;
        }
    }
}
```

- `request.auth`
  - Android 側で Firebase Authentication にログインしていれば、 Firestore にアクセスする際、自動的に認証情報（ request.auth に相当する情報）がリクエストに含まれます。
    - あなたが Firebase.auth.signInWithEmailAndPassword() や signInAnonymously() などでログインすると…
    - Firebase SDK は、内部的に「認証トークン（IDトークン）」を保持します。
    - そのトークンは Firestore への通信時に 自動で HTTP リクエストのヘッダーに付与されます。
    - この仕組みのおかげで、Android 側で明示的にトークンを Firestore に渡す必要はないんです。
  - `request.auth` は、 Firebase が裏側で送ってくれた ID トークンから解析した「認証情報」です。
  - 例えば：
    - request.auth.uid → 現在ログイン中のユーザーの UID
    - request.auth.token.email → メールアドレス（メールログインの場合）
    - request.auth.token.admin → カスタムクレームを設定していればその値

具体的には：

```kotlin
val uid = Firebase.auth.currentUser?.uid ?: return
Firebase.firestore.collection("users").document(uid).get()
```

この `.get()` の裏で、 Firebase SDK が自動的にトークンを付けて Firestore にアクセスしており、 Firestore のセキュリティルール内の `request.auth` に反映されます。


### Kotlin (Android) 側のコードサンプル

#### ログイン処理（匿名ログインなどでも OK）

以下は匿名ログインの例ですが、メールアドレスとパスワードを使用したログインなど、他のログイン方法であっても、ログインすることで、 Firebase SDK 内部に、 `request.auth` に相当するデータが保持されます。このデータが、 Firestore アクセス時に、自動的にリクエストに含まれます。

```kotlin
Firebase.auth.signInAnonymously()
    .addOnSuccessListener {
        Log.d("Auth", "Signed in as ${it.user?.uid}")
    }
    .addOnFailureListener {
        Log.e("Auth", "Sign in failed", it)
    }
```


#### Firestore への読み書き処理

Firebase Authentication を使用していれば、ログイン情報は、自動的に付与されるため、 Firestore へのアクセス方法は、普段と変わりません。

```kotlin
val firestore = Firebase.firestore
// return は、この変数が、何かの関数内で定義されているとして、
// その関数を抜けるためのものです。
val uid = Firebase.auth.currentUser?.uid ?: return

// データの書き込み
val userDoc = firestore.collection("users").document(uid)
val userData = mapOf(
    "name" to "Taro",
    "age" to 25
)

userDoc.set(userData)
    .addOnSuccessListener { Log.d("Firestore", "Document written") }
    .addOnFailureListener { Log.e("Firestore", "Write failed", it) }

// データの読み取り
userDoc.get()
    .addOnSuccessListener { document ->
        if (document.exists()) {
            val name = document.getString("name")
            val age = document.getLong("age")
            Log.d("Firestore", "User: $name, Age: $age")
        } else {
            Log.d("Firestore", "No such document")
        }
    }
    .addOnFailureListener {
        Log.e("Firestore", "Read failed", it)
    }
```


### 🔒 補足：認証されていないとどうなる？

ログインしていない状態で Firestore の `.get()` や `.set()` を呼ぶと、リクエストにトークンがつかないので、 `request.auth == null` となり、セキュリティルールに引っかかってアクセス拒否されます。


## 引用元資料

- ChatGPT



