- [Firestore のサンプルコード集](#firestore-のサンプルコード集)
  - [コレクションとドキュメントへの参照の取得](#コレクションとドキュメントへの参照の取得)
  - [データの保存（新規保存 / 更新）](#データの保存新規保存--更新)
    - [保存系メソッド一覧](#保存系メソッド一覧)
    - [add() の使用例](#add-の使用例)
    - [set() の使用例](#set-の使用例)
    - [update() の使用例](#update-の使用例)
  - [データの読み込み](#データの読み込み)
    - [コレクション（複数ドキュメント）の読み込み](#コレクション複数ドキュメントの読み込み)
    - [単一ドキュメントの読み込み](#単一ドキュメントの読み込み)
  - [データの削除](#データの削除)
  - [サーバーからローカルへのリアルタイム同期](#サーバーからローカルへのリアルタイム同期)
    - [アプリがバックグラウンドでもリアルタイムで受け取りたい場合](#アプリがバックグラウンドでもリアルタイムで受け取りたい場合)
  - [ローカルからサーバーへのリアルタイム同期](#ローカルからサーバーへのリアルタイム同期)
    - [トランザクション](#トランザクション)
      - [🔸 Firestore のトランザクションとは？](#-firestore-のトランザクションとは)
      - [🔸 よくあるユースケース](#-よくあるユースケース)
      - [🔸 サンプル：ユーザーのポイントを加算](#-サンプルユーザーのポイントを加算)
  - [条件付きクエリ（Where）・順序指定クエリ（OrderBy）](#条件付きクエリwhere順序指定クエリorderby)
  - [引用元資料](#引用元資料)


# Firestore のサンプルコード集

## コレクションとドキュメントへの参照の取得

```kotlin
FirebaseFirestore.getInstance()
    // コレクションの取得
    .collection("users")
    // ドキュメントの取得
    .document("user1")
```

- 該当のコレクションとドキュメントが存在しない場合でも、 collection() や document() を呼び出しただけでは、例外は発生しません。
- コレクションやドキュメントが実際に存在するかどうかを確認したい場合は、非同期でデータを取得する操作（ get() や addSnapshotListener() など）を行う必要があります。

例えば、 `document().get()` を使って、ドキュメントへの参照を取得し、 exists() メソッドで存在チェックできます。

```kotlin
val docRef = FirebaseFirestore.getInstance().collection("users").document("userId123")
docRef.get().addOnSuccessListener { document ->
    if (document.exists()) {
        Log.d("Firestore", "ドキュメントが存在します: ${document.data}")
    } else {
        Log.d("Firestore", "ドキュメントは存在しません")
    }
}.addOnFailureListener { exception ->
    // ネットワークエラーやパーミッションエラーなど、取得不可能な場合
    Log.e("Firestore", "取得時にエラーが発生しました", exception)
}
```


## データの保存（新規保存 / 更新）

### 保存系メソッド一覧

- add()
  - ドキュメント単位で、常に新規作成します。
- set()
  - 該当のドキュメントが存在すれば、 **ドキュメント単位の上書き** or **項目単位の更新** を行い、ドキュメントが存在しなければ、 **新規作成** します。
    - ドキュメントが存在するかどうかは、ドキュメント ID で判定されます。
  - ドキュメントの上書きオプション
    - set() の第二引数に `SetOptions.merge()` を渡すと、渡された項目のみが上書きされ、渡されなかった項目は残ります。
    - `SetOptions.merge()` を渡さなかった場合、ドキュメントごと上書きされ、渡されなかった項目は削除されます。
- update
  - 項目単位で更新します。
  - ドキュメントが存在しなかった場合は、更新に失敗し、例外が発生します。


### add() の使用例

```kotlin
val db = FirebaseFirestore.getInstance()

// 新しいユーザーを作成
val user = hashMapOf(
    "name" to "Hanako",
    "age" to 28
)

db.collection("users")
    .add(user)  // 自動でドキュメント ID が設定される。
    .addOnSuccessListener { docRef ->
        // ドキュメント ID は、 docRef.id で取得可能
        Log.d("Firestore", "Document added with ID: ${docRef.id}")
    }
    .addOnFailureListener { e ->
        Log.w("Firestore", "Error adding document", e)
    }
```


### set() の使用例

```kotlin
db.collection("users")
    .document("user123")
    .set(user)  // 既存があれば上書き
```


### update() の使用例

```kotlin
db.collection("users")
    .document("user123")
    .update("age", 30)
    .addOnSuccessListener {
        Log.d("Firestore", "Document successfully updated!")
    }
    .addOnFailureListener { e ->
        Log.w("Firestore", "Error updating document", e)
    }
```


## データの読み込み

コレクションの読み込みも、ドキュメントの読み込みも、同じ get() メソッドで行うことができます。


### コレクション（複数ドキュメント）の読み込み

```kotlin
// すべてのユーザーを取得
db.collection("users")
    .get()
    .addOnSuccessListener { result ->
        for (document in result) {
            Log.d("Firestore", "${document.id} => ${document.data}")
        }
    }
    .addOnFailureListener { e ->
        // ネットワークエラーやパーミッションエラーなど、取得不可能な場合で発生
        Log.w("Firestore", "Error getting documents.", e)
    }
```


### 単一ドキュメントの読み込み

```kotlin
db.collection("users")
    .document("user123")
    .get()
    .addOnSuccessListener { document ->
        if (document.exists()) {
            val name = document.getString("name")
            val age = document.getLong("age")
            Log.d("Firestore", "Name: $name, Age: $age")
        } else {
            Log.d("Firestore", "No such document")
        }
    }.addOnFailureListener { exception ->
        // ネットワークエラーやパーミッションエラーなど、取得不可能な場合で発生
        Log.e("Firestore", "取得時にエラーが発生しました", exception)
    }
```


## データの削除

```kotlin
db.collection("users")
    .document("user123")
    .delete()
    .addOnSuccessListener {
        Log.d("Firestore", "Document successfully deleted!")
    }
```


## サーバーからローカルへのリアルタイム同期

サーバー上のデータが更新された場合、リアルタイムでアプリに通知が届きます。通知を受け取れるのは、アプリのプロセスが存在している間のみです。また、アプリのプロセスが存在していても、アプリがバックグラウンドになっている場合は、 OS によって、制限を受ける可能性があります。そのため、 onStop 等で、バックグラウンドになった際には、リスナーを解除することが推奨されます。

```kotlin
val listener = db.collection("users")
    .addSnapshotListener { snapshots, e ->
        if (e != null) {
            Log.w("Firestore", "Listen failed.", e)
            return@addSnapshotListener
        }

        for (doc in snapshots!!) {
            Log.d("Firestore", "Realtime: ${doc.id} => ${doc.data}")
        }
    }

// Activity/Fragment の onStop 等でリスナーを解除
listener.remove()
```


### アプリがバックグラウンドでもリアルタイムで受け取りたい場合

もしアプリが完全にバックグラウンド状態でも更新を受けたいなら、以下の方法が検討できます：

- Firestore の更新に応じて **Cloud Functions** を使って処理をフック
- Cloud Functions から **FCM** を使ってクライアントにプッシュ通知を送信
- アプリが起動されたら通知をタップして該当データを読み込む


## ローカルからサーバーへのリアルタイム同期

- 自動同期
  - 開発者は、 add(), set(), update() などを呼ぶだけで、後は Firebase SDK が自動的に、ローカルからサーバーへ同期してくれます。
- ローカルキャッシュ機能
  - add(), set(), update() を呼ぶと、即座にローカルキャッシュが更新されます。
  - その時点で、ネットワークに接続されていない場合は、接続が復旧したタイミングで、自動的にサーバーに反映されます。
- 即時同期
  - 基本的には、ローカルキャッシュを更新すれば、即座にサーバーへ同期します。
  - ただし、リクエストが多すぎと、サーバー側で一時的に制限される場合があります。
- 同期の実行条件
  - サーバーへの同期には、アプリのプロセスが起動している必要があります。
    - 例えば、オフライン時にローカルキャッシュを更新し、サーバーに同期する前にアプリプロセスが終了した場合は、次回、プロセスを起動、かつ、オンラインになった際に、サーバーへ自動的に同期されます。
- 大容量データの制限
  - アプリのキャッシュ容量には制限（デフォルト：40MB）があるため、膨大なデータをオフラインで変更するようなケースでは調整が必要な場合もあります。
- データの競合
  - ユーザー A とユーザー B により、サーバー上のデータの更新に同期が発生した場合には、基本的には「後勝ち」です。
  - 特に、 set() メソッドは、ドキュメント単位で上書きされる可能性があるため、項目単位の更新オプションを使用するか、 update() メソッドを使用する方法を検討すると良いでしょう。
  - トランザクションを使用することで、サーバー上のデータが他のユーザーによって更新されていた場合は、自分の更新をリトライすることも可能です。
    - 詳細は、 [トランザクション](#トランザクション) セクションを参照してください。


### トランザクション

Firestore の トランザクション（transaction） は、複数の読み書きを 安全に一貫性を保って行う ための仕組みです。特に複数人が同じドキュメントを編集するケースや、値の整合性が大事な場面で活躍します。


#### 🔸 Firestore のトランザクションとは？

- 「読み取り → 処理 → 書き込み」の一連の流れを、一つのトランザクションとして、まとめて実行
- すべて成功したときのみ書き込みを確定（失敗時は自動で再試行）
- 読み取ったドキュメントが途中で変更されたらリトライする。
- 基本は 単一ドキュメントの整合性確保に最適


#### 🔸 よくあるユースケース

- ユーザーのポイント加算
- 在庫の数量変更（購入時など）
- いいね／カウントの増減
- 誰かが更新したデータを上書きしたくないとき


#### 🔸 サンプル：ユーザーのポイントを加算

```kotlin
val db = FirebaseFirestore.getInstance()
val docRef = db.collection("users").document("user123")

db.runTransaction { transaction ->
    // ① 現在のドキュメントを取得
    val snapshot = transaction.get(docRef)

    // ② 値を読み取る
    val currentPoints = snapshot.getLong("points") ?: 0L

    // ③ 新しい値を計算して書き込み
    transaction.update(docRef, "points", currentPoints + 10)

    // ④ 任意の結果を返す（必要なら）
    currentPoints + 10
}.addOnSuccessListener { newPoints ->
    Log.d("Firestore", "ポイント更新成功。新しい値: $newPoints")
}.addOnFailureListener { e ->
    Log.w("Firestore", "トランザクション失敗", e)
}
```

- runTransaction ブロック内では get() と update() が使える
- 失敗時は最大5回くらいまで自動リトライ（ただし回数は保証されない）
- ネットワーク必須。オフラインでは使えない
  - オフラインで `runTransaction{}` が実行されると、即座に `addOnFailureListener{}` が実行されます。
- 他の人が先にそのドキュメントを変更していたら → 自動でやり直す
- set() も使えるが、 merge: true のようなオプションは使えないので注意
- 長時間かかる処理を入れるのは避ける（再試行時に問題になる）


## 条件付きクエリ（Where）・順序指定クエリ（OrderBy）

```kotlin
db.collection("users")
    .whereGreaterThan("age", 20)
    .orderBy("age")
    .get()
    .addOnSuccessListener { result ->
        for (doc in result) {
            Log.d("Firestore", "Filtered user: ${doc.id} => ${doc.data}")
        }
    }
```


## 引用元資料

- ChatGPT






