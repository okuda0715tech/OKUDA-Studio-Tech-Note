<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [ライフサイクル](#ライフサイクル)
	- [onCreate](#oncreate)
	- [onPause](#onpause)
	- [onStop](#onstop)
	- [onDestroy](#ondestroy)
	- [システムはメモリ不足の場合、アクティビティを直接強制終了するのではなく、アクティビティのプロセスを強制終了する。](#システムはメモリ不足の場合アクティビティを直接強制終了するのではなくアクティビティのプロセスを強制終了する)
<!-- TOC END -->


# ライフサイクル

## onCreate

- 特徴
	- Activityを生成する時に、一度だけ実行する必要のある処理を行います。
		- フィールドの初期化
		- ViewModelのバインド（ViewModelの生成 or 生成済みのViewModelの取得）


## onPause

- 特徴
  - マルチウィンドウでは、ユーザーはアプリを使用中である可能性が高く、UI関連の処理をここで停止するのは好ましくない。
  - 非常に負荷の小さい処理のみを実行できる。（データの保存は不可）
- 後続処理
  - 呼び出されるタイミングと逆の状態に戻った場合は、onResumeが呼び出される。
  - Activityが完全に非表示になった場合は、onStopが呼び出される。


## onStop

- 特徴
  - インスタンスは破棄されない
  - フィールドの値は破棄されない
  - EditTextなどウィジェットの状態は破棄されない
	- 負荷の大きいシャットダウン処理が可能です。（DBへの保存など）
- 後続処理
  - 呼び出されるタイミングと逆の状態に戻った場合は、onRestartが呼び出される。
  - Activityが破棄される場合は、onDestroyが呼び出される。
  - デバイスのメモリ不足によってシステムがプロセスを破棄した場合、onDestroyは呼ばれずActivityが破棄され、ユーザーがアクティビティに戻った時はonCreateが呼ばれる
	  - この時、onSaveInstanceStateで状態を保存していればonCreateやonRestoreInstanceStateで復元できる
	  - この時、EditTextの表示内容など、ウィジェットの状態は自動的に保存、復元される。
		  - ただし、レイアウトxmlでidを定義していないと保存・復元されない。
	  - ライフサイクルの図によると、システムによってプロセスがkillされた場合、onPauseまでしか呼ばれないことがあるらしいが、onPauseは非常に負荷の軽い処理しか実施できない。そのため、データの永続化はonStopで実施する必要がある。onPauseまでしか呼ばれない場合は永続化は諦めるしかない。
		  - ただし、フォアグラウンドのプロセスがkillされる可能性はかなり低いため、まず発生しない事象である。


## onDestroy

- 特徴
  - インスタンスが破棄される。
  - isFinishingメソッドでこの後インスタンスが再生成されるのかどうかを判定できる。
- 後続処理
  - 構成変更の場合は、onCreateが呼び出される

- 実行中の処理はキャンセルする必要がある。
- OSがライフサイクルを管理しているコンポーネントへの参照を保持している場合は、メモリリーク対策のために解放する必要がある。


## システムはメモリ不足の場合、アクティビティを直接強制終了するのではなく、アクティビティのプロセスを強制終了する。


```
システムがメモリを解放するためにアクティビティを直接強制終了することはありません。
代わりに、アクティビティが実行されているプロセスを強制終了します。
```

上記コメントの出所は以下の公式ドキュメント

[アクティビティの状態とメモリからの退避](https://developer.android.com/guide/components/activities/activity-lifecycle?hl=ja)

デバイスの設定アプリの開発者向けオプションにある「アクティビティを保持しない」は、  
プロセスの強制終了を疑似的に再現するために存在していると思われる。
