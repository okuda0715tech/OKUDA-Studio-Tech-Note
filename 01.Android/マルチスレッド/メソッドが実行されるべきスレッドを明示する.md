<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [メソッドが実行されるべきスレッドを明示する](#メソッドが実行されるべきスレッドを明示する)
  - [概要](#概要)
  - [サンプル](#サンプル)
  - [@UiThread と @MainThread の違い](#uithread-と-mainthread-の違い)
  - [@BinderThread とは](#binderthread-とは)
<!-- TOC END -->


# メソッドが実行されるべきスレッドを明示する

## 概要

`@UiThread` 、 `@MainThread` 、 `@WorkerThread` 、 `@BinderThread` という  
アノテーションを使用することによって、 「処理がどのスレッドで実行されるべきか」 を  
開発者に明示します。  
さらに、可能な範囲で、これを違反した場合にはビルドエラーを発生させてくれます。

アノテーションは、メソッドにも付与できますし、クラスにも付与できます。

View の拡張クラスのように、クラス全体が UI スレッドで動作することが要求される場面では  
クラスにアノテーションを付与するのが良いでしょう。


## サンプル

以下のようにメソッドにアノテーションを付与します。

```java
@WorkerThread
private void myWorkerMethod(TextView textView) {
    textView.setText("Worker Thread!");
}
```


## @UiThread と @MainThread の違い

ドキュメントによると、極めて稀なケースではあるがアプリが別ウインドウを実行するために  
メインスレッドとは別の UI スレッドを作ることがあるらしいです。  
そのような場合が生じるも考えて、普段は、 `@UiThread` を使用するようにすれば問題ないかと思います。


## @BinderThread とは

プロセス間通信で、あるアプリ A が、別のアプリ B のメソッドを実行するとします。  
アプリ B は、アプリ C からも呼び出される可能性があるとします。  
この場合、アプリ B は、アプリ A とアプリ C の両方から同時に呼び出される可能性があるため、  
マルチスレッドで処理を実行する必要があります。  
その場合に使用されるのが、 `@BinderThread` です。
