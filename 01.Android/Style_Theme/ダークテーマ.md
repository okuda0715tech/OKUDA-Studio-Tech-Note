<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [ダークテーマ](#ダークテーマ)
	- [ActivityがAppCompatActivityを継承していること](#activityがappcompatactivityを継承していること)
	- [DayNightテーマを継承する](#daynightテーマを継承する)
	- [どちらのテーマを使用するのかをOSに伝える](#どちらのテーマを使用するのかをosに伝える)
	- [テーマごとにリソースを別々のファイル分ける(Better)](#テーマごとにリソースを別々のファイル分けるbetter)
	- [テーマごとにテーマを別々のファイルに分ける(Best)](#テーマごとにテーマを別々のファイルに分けるbest)
	- [colorPrimaryを参照している部分は、colorPrimarySurfaceを使用すると便利](#colorprimaryを参照している部分はcolorprimarysurfaceを使用すると便利)
	- [Elevation Overlay](#elevation-overlay)
	- [アプリでダークテーマが有効になっているか確認する方法](#アプリでダークテーマが有効になっているか確認する方法)

<!-- /TOC -->


# ダークテーマ

## ActivityがAppCompatActivityを継承していること


## DayNightテーマを継承する

```
<style name="AppTheme" parent="Theme.AppCompat.DayNight">
```


## どちらのテーマを使用するのかをOSに伝える

**ダークテーマを設定する方法**

```Java
// アプリ全体にテーマを適用する場合
AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);

// 一つの Activity のみにテーマを適用する場合
// (ダイアログから呼び出した場合は、そのダイアログのホスト Activity のテーマも変更される)
getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES);
```

**ダークテーマの設定に使用するパラメータ**

```Java
// 常にダークモード
AppCompatDelegate.MODE_NIGHT_YES

// 常にライトモード
AppCompatDelegate.MODE_NIGHT_NO

// システム設定に従ったモードになる
// ( Android Q より古い端末の場合は、ライトテーマが適用されます)
// (この設定を初期値にすると良い)
AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM

// バッテリーセーバー機能が有効になる度にダークモードになる
AppCompatDelegate.MODE_NIGHT_AUTO_BATTERY
```

NightMode の設定は、プロセスを終了すると失われます。  
そのため、プロセスを起動する度に設定し直す必要があります。  
`Application` クラスで設定するのが良い方法です。


## テーマごとにリソースを別々のファイル分ける(Better)

通常のテーマのリソースを `xxx` フォルダに格納する場合、  
ダークテーマのリソースは、 `xxx-night` フォルダに格納します。  
こうすることで、 OS が自動的にテーマに沿ったリソースを取得します。  
もし、ダークテーマを適用しているにもかかわらず、  
`xxx-night` フォルダにリソースが存在しない場合は、 `xxx` フォルダのリソースを参照します。


**values/colors.xml**

```xml
<color name="color_blue">@color/blue_500</color>
```


**values-night/colors.xml**

```xml
<color name="color_blue">@color/blue_200</color>
```

ただし、このやり方の場合、属性名が必ずしも適切な名前になるとは限りません。上記の例の場合、ライトテーマでは青だったリソースが、ダークテーマでは黄色になるかもしれません。その場合に`color_blue`という名前は適切ではありません。  
かといって、`color_blue`から`color_primary`に変更した場合、セマンテック（意味）名になってしまい、テーマ属性が実際にどんな色を参照しているのかがわかりづらくなってしまいます。そのため、一番良い方法はリソースを別々のファイルに分けるのではなく、テーマ自体を別々のファイルに分けることです。


## テーマごとにテーマを別々のファイルに分ける(Best)

ベーステーマにライトテーマとダークテーマの共通部分を抜き出し、それを継承してライトテーマとダークテーマを定義する。


**values/themes.xml**

```xml
<!-- ライトテーマ、ダークテーマ共通部分 -->
<style name="Base.Theme.MyApp" parent="Theme.AppCompat.DayNight.NoActionBar">
	<item name="colorSecondary">@color/color_yellow</item>
</style>

<!-- ライトテーマ用のテーマカスタマイズ -->
<style name="Theme.MyApp" parent="Base.Theme.MyApp">
  <item name="colorPrimary">@color/color_blue_500</item>
</style>
```


**values-night/themes.xml**

```xml
<!-- ダークテーマ用のテーマカスタマイズ -->
<style name="Theme.MyApp" parent="Base.Theme.MyApp">
  <item name="colorPrimary">@color/color_blue_200</item>
</style>
```


**values/colors.xml**

```xml
<resources>
	<color name="color_yellow">...</color>
	<color name="color_blue_500">...</color>
	<color name="color_blue_200">...</color>
</resources>
```


## colorPrimaryを参照している部分は、colorPrimarySurfaceを使用すると便利

テーマ属性 `?attr/colorPrimarySurface` を参照すると、ライトテーマの時は `?attr/colorPrimary`  
を参照し、ダークテーマの時は `?attr/colorSurface` を参照するようになります。

この属性は、ライトテーマで `colorPrimary` を使用している部分について、  
ダークテーマでは黒色表示する場合に使用することを想定されています。


**values/themes.xml**

```xml
<!-- ライトテーマ、ダークテーマ共通部分 -->
<style name="Base.Theme.MyApp" parent="Theme.AppCompat.DayNight.NoActionBar">
</style>

<!-- ライトテーマ用のテーマカスタマイズ -->
<style name="Theme.MyApp" parent="Base.Theme.MyApp">
	<!-- colorPrimaryとcolorOnPrimaryのみPrimarySurfaceが使用できるっぽい -->
	<item name="colorPrimary">@color/color_blue_500</item>
	<item name="colorOnPrimary">@color/...</item>
</style>
```


**values-night/themes.xml**

```xml
<!-- ダークテーマ用のテーマカスタマイズ -->
<style name="Theme.MyApp" parent="Base.Theme.MyApp">
	<item name="colorSurface">@color/color_blue_200</item>
	<item name="colorOnSurface">@color/...</item>
</style>
```


ツールバー、背景、タブ用に便利なものが用意されています。

```xml
<!-- ライトテーマ、ダークテーマのテーマ属性で colorPrimary 属性と colorSurface 属性を定義する。 -->
<resources>
	<styles name="Base.Theme.MyAppName" parent="Theme.AppCompat.DayNight.NoActionBar">
		<item name="colorPrimary">?attr/colorPrimarySurface</item>
		<item name="bottomNavigationStyle">
			@style/Widget.MaterialComponents.bottomNavigationView.PrimarySurface
		</item>
		<item name="???(要調査)">
			@style/Widget.MaterialComponents.ActionBar.PrimarySurface
		</item>
		<item name="appBarLayoutStyle">
			@style/Widget.MaterialComponents.AppBarLayout.PrimarySurface
		</item>
		<item name="???(要調査)">
			@style/Widget.MaterialComponents.BottomAppBar.PrimarySurface
		</item>
		<item name="tabStyle">
			@style/Widget.MaterialComponents.TabLayout.PrimarySurface
		</item>
		<item name="toolbarStyle">
			@style/Widget.MaterialComponents.Toolbar.PrimarySurface
		</item>
	</style>
</resources>
```


## Elevation Overlay

ダークテーマでは、全体的に暗い画面であるため、エレベーションによる影が見えません。  
その場合、高い位置にある View は、同じ色でもより明るくなることでエレベーションを表現します。

Elevation Overlay に対応しているかどうかはコンポーネントごとに異なります。


## アプリでダークテーマが有効になっているか確認する方法

**Kotlin のサンプル**

```kotlin
when (context.resources?.configuration?.uiMode?.and(Configuration.UI_MODE_NIGHT_MASK)) {
	// ダークテーマが有効になっている場合
    Configuration.UI_MODE_NIGHT_YES -> {}

	// ダークテーマが無効になっている場合
    Configuration.UI_MODE_NIGHT_NO -> {}

	// 具体的にどういう場合に UNDEFINED になるのかは現時点では不明。
    Configuration.UI_MODE_NIGHT_UNDEFINED -> {}
}
```

**Java のサンプル**

```java
int nightModeFlags =
    getContext().getResources().getConfiguration().uiMode &
    Configuration.UI_MODE_NIGHT_MASK;
switch (nightModeFlags) {
    case Configuration.UI_MODE_NIGHT_YES:
         doStuff();
         break;

    case Configuration.UI_MODE_NIGHT_NO:
         doStuff();
         break;

    case Configuration.UI_MODE_NIGHT_UNDEFINED:
         doStuff();
         break;
}
```




