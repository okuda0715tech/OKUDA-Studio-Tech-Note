- [Android アプリのテストの基礎](#android-アプリのテストの基礎)
  - [テストのメリット](#テストのメリット)
  - [Android でのテストの種類](#android-でのテストの種類)
    - [対象](#対象)
    - [サポート範囲](#サポート範囲)
  - [インストルメンテーションテストとローカルテスト](#インストルメンテーションテストとローカルテスト)
    - [例](#例)
  - [テスト戦略の定義](#テスト戦略の定義)
    - [不安定なテスト](#不安定なテスト)
  - [テスト可能なアーキテクチャ](#テスト可能なアーキテクチャ)
    - [分離へのアプローチ](#分離へのアプローチ)
  - [次のステップ](#次のステップ)
  - [引用元資料](#引用元資料)


# Android アプリのテストの基礎

このページでは、Android アプリのテストにおける基本となるベスト プラクティスとその利点などについて概説します。


## テストのメリット

アプリの開発において、テストは非常に重要なプロセスです。アプリに対して一貫性のあるテストを実施することで、アプリの公開前に、その正確性、機能の動作、使いやすさを検証できます。

アプリでは、さまざまなデバイスやエミュレータを使用したり、システム言語を変更したり、すべてのユーザーエラーを生成したり、すべてのユーザーフローを走査したりすることがあります。

しかし、手動テストではスケーリングが難しく、アプリの動作の回帰を見落としがちです。自動テストでは、自動テストを行うツールを使用します。このツールは、より高速で再現性が高く、一般的に、開発プロセスの早い段階でアプリに関する実用的なフィードバックを提供できます。


## Android でのテストの種類

モバイルアプリは複雑で、多くの環境で適切に動作する必要があります。そのため、テストには多くの種類があります。


### 対象

たとえば、以下の種類のテストがあります。

- **機能テスト**: アプリは想定されたとおりに動作しているか？
- **パフォーマンステスト**: 迅速かつ効率的に実行するか。
- **ユーザー補助機能のテスト**: ユーザー補助サービスと連動するか。
- **互換性テスト**: すべてのデバイスと API レベルで適切に動作するか。


### サポート範囲

また、テストはサイズ、または、分離の度合いによって異なります。

単体テストや小規模なテストでは、メソッドやクラスなど、アプリのごく一部を検証します。エンドツーエンド テストや、大規模なテストでは、画面全体やユーザーフローなど、アプリの大きな部分を同時に検証します。中規模なテストが中間にあり、 2 つ以上のユニットの統合を確認します。

<img src="./画像/テストスコープ.png" width="600">

テストを分類する方法はたくさんあります。ただし、 **アプリデベロッパーにとって、最も重要な違いはテストを実行する場所です。**


## インストルメンテーションテストとローカルテスト

テストは Android デバイス、または、パソコンで実行できます。

- **インストルメンテーション ( instrumentation ) テスト** は、物理デバイス、または、エミュレートされた Android デバイスで実行されます。インストルメンテーションという言葉には、 「計器を使用した」 という意味があります。このアプリは、コマンドを挿入し、状態を読み取るテストアプリとともにビルドされ、インストールされます。インストルメンテーションテストは **通常、アプリを起動して操作する UI テストです。**
- **ローカルテスト** は、開発マシン ( PC ) 、または、サーバーで実行されるため、ホスト側のテストとも呼ばれます。通常は小さくて高速で、テスト対象をアプリの他の部分から分離します。

すべての単体テストがローカルであるわけではなく、すべてのエンドツーエンドテストが、デバイスで実行されるわけではありません。たとえば、以下の場合です。

- **大きなローカルテスト** : [Robolectric](http://robolectric.org/) など、ローカルで実行される Android シミュレータを使用できます。
- **小規模なインストルメンテーションテスト** : SQLite データベースなどのフレームワーク機能で、コードが正しく動作するかどうかを検証できます。このテストを複数のデバイスで実行して、複数のバージョンの SQLite との統合を確認できます。


### 例

次のスニペットは、インストルメンテーション UI テストで UI を操作し、要素をクリックして別の要素が表示されることを確認する方法を示しています。

```kotlin
//**********************
// Espresso の場合
//**********************
// When the Continue button is clicked
onView(withText("Continue"))
    .perform(click())

// Then the Welcome screen is displayed
onView(withText("Welcome"))
    .check(matches(isDisplayed()))

//**********************
// Compose UI の場合
//**********************
// When the Continue button is clicked
composeTestRule.onNodeWithText("Continue").performClick()

// Then the Welcome screen is displayed
composeTestRule.onNodeWithText("Welcome").assertIsDisplayed()
```

次のスニペットは、ViewModel の単体テスト（ローカル、ホスト側のテスト）の一部を示しています。

```kotlin
// Given an instance of MyViewModel
val viewModel = MyViewModel(myFakeDataRepository)

// When data is loaded
viewModel.loadData()

// Then it should be exposing data
assertTrue(viewModel.data != null)
```


## テスト戦略の定義

**アプリが対応しているすべてのデバイスで、アプリのすべてのコード行をテストするのが理想的です。残念ながら、この方法は時間がかかり、コストもかかるため、実用的ではありません。**

優れたテスト戦略では、テストの忠実度、速度、信頼性の間で適切なバランスを見つけます。テストの忠実度は、テスト環境と実際のデバイスとの類似性によって決まります。忠実度の高いテストは、エミュレートされたデバイス、または、実機自体で実行されます。ローカル ワークステーションの JVM で、低忠実度のテストが実行される場合があります。 **高忠実度テストは、多くの場合、処理に時間がかかり、より多くのリソースを必要とするため、すべてのテストを高忠実度テストにする必要はありません。**


### 不安定なテスト

正しく設計、および、実装されたテスト実行でもエラーは発生します。コード内の微妙な競合状態は、ごくわずかな割合で発生する可能性があります。100% の確率で合格しなかったテストは、不安定です。


## テスト可能なアーキテクチャ

テスト可能なアプリアーキテクチャでは、コードは、そのさまざまな部分を個別に、簡単にテストできる構造になっています。テスト可能なアーキテクチャには、読みやすさ、保守性、スケーラビリティ、再利用性など、他にもメリットがあります。

テスト不可のアーキテクチャは、以下のような状況につながります。

- テストの規模が大きくなり、速度が低下し、不安定になります。単体テストができないクラスは、大規模な統合テスト、または、 UI テストでカバーする必要があります。
- さまざまなシナリオをテストする機会が少ない。テストが長くなると実行時間が長くなるため、アプリのすべての状態をテストすることは現実的ではありません。

アーキテクチャガイドラインについて詳しくは、 [アプリアーキテクチャガイド](https://developer.android.com/jetpack/guide?hl=ja) をご覧ください。


### 分離へのアプローチ

関数、クラス、モジュールの一部を他の部分から抽出できると、テストはより簡単になり、より効果的です。この手法は分離と呼ばれ、テスト可能なアーキテクチャにとって最も重要な概念です。

一般的な分離手法には次のものがあります。

- アプリをプレゼンテーション、ドメイン、データなどのレイヤに分割する。アプリを機能ごとに 1 つのモジュールに分割することもできます。
- アクティビティやフラグメントなど、依存関係の大きいエンティティには、ロジックを追加しないでください。これらのクラスをフレームワークへのエントリーポイントとして使用し、 UI とビジネスロジックを別の場所（コンポーザブル、ViewModel、ドメインレイヤなど）に移動します。
- ビジネスロジックを含むクラスで、直接のフレームワーク依存関係を避けます。たとえば、 ViewModel では Android コンテキストを使用しないでください。 ( Activity などのコンテキストよりも、 ViewModle のライフサイクルの方が長いため、メモリリークが発生してしまうため。)
- 依存関係を簡単に置き換えられるようにします。たとえば、具体的な実装ではなく、インターフェースを使用します。 DI フレームワークを使用しない場合でも、 [依存関係インジェクション](https://developer.android.com/training/dependency-injection?hl=ja) を使用してください。


## 次のステップ

テストを行う理由と、この 2 つの主なテストの種類がわかったところで、 [テスト項目](./2.Android%20でのテスト項目.md) をご覧ください。

また、初めてのテストを作成して学習する場合は、 [テストの Codelab](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-basics?_gl=1*1z4qf3*_up*MQ..*_ga*MTMxNDc1MDcxNi4xNzIyOTk4MDY3*_ga_6HH9YJMN9M*MTcyMjk5ODA2Ni4xLjAuMTcyMjk5ODA2Ni4wLjAuMA..#0) をご覧ください。


## 引用元資料

- [Android アプリのテストの基礎](https://developer.android.com/training/testing/fundamentals?hl=ja)

