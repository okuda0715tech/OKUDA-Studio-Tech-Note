- [Robolectric 戦略](#robolectric-戦略)
  - [テスト戦略](#テスト戦略)
    - [単体テスト](#単体テスト)
    - [UI テスト](#ui-テスト)
  - [Robolectric テストとデバイステスト](#robolectric-テストとデバイステスト)


# Robolectric 戦略

[Robolectric](https://robolectric.org/) は Google が管理するオープンソースフレームワークです。エミュレータのオーバーヘッドや不安定さなしに、 JVM 内のシミュレートされた Android 環境で、テストを実行できます。 Lollipop（ API レベル 21 ）以降のすべてのバージョンの Android をサポートしています。

多くの大規模なプロジェクトでは、 Robolectric を使用してテストの速度と信頼性を高め、実際のデバイスやエミュレータで、テストを実行する費用を削減しています。これには、 Robolectric に大きく依存するほとんどの Google アプリが含まれます。

Robolectric は、すべての機能と API をサポートしているわけではないため、エミュレータの完全な代替手段ではありません。たとえば、 Robolectric には、エミュレータのような画面がなく、一部の API 、は部分的にしかサポートされていません。ただし、ほとんどの UI テストと単体テストを実行することが可能です。


## テスト戦略

Robolectric で実施できるテスト戦略には、単体テストと UI テストの 2 種類があります。


### 単体テスト

Robolectric は、 Android アプリで 「単体テスト」 を可能にするための方法として考案されました。たとえば、アクティビティの起動をシミュレートし、その中のロジックをテストして、すべてのライフサイクルメソッドを呼び出すことができます。

Robolectric のフェイク（シャドウ）をユニットテストの依存関係として使用することもできます。たとえば、クラスが Bundle を使用する場合や、 [Bluetooth](https://github.com/robolectric/robolectric/blob/ae831fccdc10b5808c274fbe519a5a8deae33424/shadows/framework/src/main/java/org/robolectric/shadows/BluetoothConnectionManager.java#L12) 接続を偽装する必要がある場合などです。

一般的に、 [テスト可能なアーキテクチャ](../2.基本/1.Android%20アプリのテストの基礎.md/#テスト可能なアーキテクチャ) を実装する場合、コードは Android フレームワークに依存せず、単体テストで個別にテストできるため、単体テストに Robolectric を使用する必要はありません。

**キーポイント** : ほとんどの場合、Robolectric は、レガシーコードや Android クラスに依存する API を使用する場合など、最後の手段としてのみ、単体テストに使用します。可能であれば、 Robolectric シャドーなしでテストできるようにコードをリファクタリングするか、 UI テストなど、別のタイプのテストを使用して機能をテストします。


### UI テスト

Robolectric では、 Espresso テストや Compose テストなどの [UI テスト](https://developer.android.com/training/testing/ui-tests?hl=ja) も実行できます。 [インストルメンテーションテスト](https://developer.android.com/training/testing/instrumented-tests?hl=ja) を Robolectric に変換するには、テストを test ソースセットに移動し、 Robolectric の依存関係を設定します。

```kotlin
android {
    testOptions {
        unitTests {
            isIncludeAndroidResources = true
        }
    }
}

dependencies {
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.robolectric:robolectric:4.13")
}
```

test ソースセットにある UI テストは、すべて Robolectric で実行されます。

```kotlin
import androidx.test.espresso.Espresso.onView

@RunWith(AndroidJUnit4::class)
class AddContactActivityTest {
    @Test
    fun inputTextShouldBeRetainedAfterActivityRecreation() {
        // GIVEN
        val contactName = "Test User"
        val scenario = ActivityScenario.launchActivity<AddContactActivity>()

        // WHEN
        // Enter contact name
        onView(withId(R.id.contact_name_text))
            .perform(typeText(contactName))
        // Destroy and recreate Activity
        scenario.recreate()

        // THEN
        // Check contact name was preserved.
        onView(withId(R.id.contact_name_text))
            .check(matches(withText(contactName)))
     }
}
```

ほとんどの UI テストは、フレームワークを操作しないため、 Robolectric で実行できます。必要な忠実度が十分に高いため、 Robolectric で動作テストを実行できます。たとえば、 Compose テストで、ボタンのクリック後に UI が変更されたことを確認する場合です。

Robolectric では、スクリーンショットテストなど、他の UI テストも実行できます。ただし、デバイスによって、画面のレンダリングが若干異なるため、忠実度は低くなります。

Robolectric の実装が、各ユースケースに適しているかどうかを判断する必要がありますが、推奨事項をいくつかご紹介します。

- コンポーネント、機能、アプリのテストで UI の動作を分離してテストする場合は、 Robolectric を使用します。一般に、これらのテストは UI の状態管理と動作をチェックし、外部依存関係を操作しません。
- ピクセル精度が重要でない場合は、 Robolectric を使用してスクリーンショットを撮影します。たとえば、コンポーネントが、さまざまなフォントサイズやテーマにどのように反応するかをテストする場合です。

**注** : Robolectric は、ネイティブでスクリーンショットを撮影できますが、スクリーンショットテストを実行するには、サードパーティライブラリが必要です。


## Robolectric テストとデバイステスト

まとめると、 Robolectric は、ほとんどの UI テストを実行するのに十分な忠実度を提供しますが、エッジ to エッジやピクチャー in ピクチャーなどのシステム UI に関連するものや、 WebView などのサポートされていない機能に依存している場合など、デバイステストが必要なケースもあります。




