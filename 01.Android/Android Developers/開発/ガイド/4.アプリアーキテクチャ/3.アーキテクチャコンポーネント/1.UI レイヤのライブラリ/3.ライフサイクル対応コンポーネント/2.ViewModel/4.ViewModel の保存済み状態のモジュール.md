- [ViewModel の保存済み状態のモジュール](#viewmodel-の保存済み状態のモジュール)
  - [セットアップ](#セットアップ)
  - [SavedStateHandle を使用する](#savedstatehandle-を使用する)
    - [LiveData](#livedata)
    - [StateFlow](#stateflow)
    - [試験運用版 Compose の State のサポート](#試験運用版-compose-の-state-のサポート)
  - [サポートされている型](#サポートされている型)
    - [直接サポートされている型](#直接サポートされている型)
    - [非 Parcelable クラスを保存する](#非-parcelable-クラスを保存する)
  - [テストで SavedStateHandle を使用する](#テストで-savedstatehandle-を使用する)


# ViewModel の保存済み状態のモジュール

UI の状態の保存で説明したように、ViewModel オブジェクトは構成の変更を処理できるため、ローテーションなどの状態を気にする必要はありません。ただし、システムによって開始されたプロセスの終了を処理する必要がある場合は、バックアップとして SavedStateHandle API を使用することをおすすめします。

UI の状態は通常、アクティビティではなく ViewModel オブジェクトに保存されるか、このオブジェクトで参照されます。そのため onSaveInstanceState() または rememberSaveable を使用するには、保存済み状態モジュール ( SavedState ) で処理できるボイラープレートが必要です。

このモジュールを使用する場合、ViewModel オブジェクトは、コンストラクタを介して [SavedStateHandle](https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle?_gl=1*otagx2*_up*MQ..*_ga*MTE3NjE0ODY1NC4xNzIxOTcyNjA1*_ga_6HH9YJMN9M*MTcyMjAwMTQzNC4yLjAuMTcyMjAwMTQzNC4wLjAuMA..) オブジェクトを受け取ります。このオブジェクトは、保存済み状態との間でオブジェクトの書き込みや取得を行えるようにする Key-Value マップです。これらの値は、システムによってプロセスが強制終了された後も保持され、同じオブジェクトを介して引き続き使用できます。

**保存済み状態はタスクスタックに関連付けられます。タスクスタックがなくなると、保存済みの状態もなくなります。** 具体的には次の場合にタスクスタックがなくなります。

- アプリを強制停止する
- バックグラウンドのアプリ一覧からアプリを削除する
- デバイスを再起動する
- activity.finish() 関数が実行される
 
これらの場合、タスクスタックが表示されなくなり、保存済みの状態の情報を復元できなくなります。ユーザーが開始する UI の状態の破棄シナリオでは、保存済みの状態は復元されません。

その一方で、システムが開始する UI の状態の破棄シナリオでは、保存済みの状態は復元されます。

**重要なポイント**: 通常、保存済みインスタンスの状態に保存されるデータは、ユーザーの入力またはナビゲーションに依存する **一時的な状態です。** 例としては、次のものがあげられます。

- リストのスクロール位置
- 画面に表示中のアイテムの ID
- ユーザーが選択中の設定の状態
- テキストフィールドへの入力

**重要**: 使用する API は、状態が保持される場所と、それに必要なロジックによって異なります。

- ビジネスロジックで使用される状態の場合は、ViewModel で SavedStateHandle を使用し保持
- UI ロジックで使用される状態の場合
  - Android View システムの場合は、 onSaveInstanceState API に保持
  - Jetpack Compose の場合は、 rememberSaveable で保持

**注**: 状態はシンプルかつ軽量であることが必要です。複雑なデータや大量のデータの場合は、永続ローカルストレージを使用する必要があります。


## セットアップ

Fragment 1.2.0 およびその推移的な依存関係 Activity 1.1.0 以降、ViewModel のコンストラクタ引数として SavedStateHandle を受け入れることができるようになりました。

```kotlin
class SavedStateViewModel(private val state: SavedStateHandle) : ViewModel() { ... }
```

その以外に追加の実装は必要なく、デフォルトの ViewModel ファクトリにより、 SavedStateHandle が付与された ViewModel のインスタンスを取得できます。

```kotlin
class MainFragment : Fragment() {

    // これで SavedStateHandle が付与された ViewModel が生成されます。
    val vm: SavedStateViewModel by viewModels()

}
```

カスタム ViewModelProvider.Factory インスタンスを提供する場合、AbstractSavedStateViewModelFactory を拡張することによって SavedStateHandle の使用を有効にできます。


## SavedStateHandle を使用する

SavedStateHandle クラスの構成は次の通りです。

- set() メソッドおよび get() メソッドを介して SavedStateHandle とデータのやり取りを行う
- Key - Value 形式でデータを保持する

データが保存されるタイミングを説明する前に注意してほしい点があります。それは、 SavedStateHandle オブジェクトと 「保存済み状態」 オブジェクトは別物だということです。アプリで SavedStateHandle に設定された値が、 「保存済み状態」 オブジェクトに書き込まれるまでは、データの保存は完了しておらず、後からデータを復元することはできません。

SavedStateHandle に設定された値が、 「保存済み状態」 オブジェクトに書き込まれるタイミングは、 Activity の onStop() が呼ばれるタイミングです。そのため、もし、 Activity の onStop() が呼ばれた後に値が SavedStateHandle へ設定された場合は、 Activity の onStart が呼ばれ、その後に再び onStop が呼ばれない限り保存されません。

SavedStateHandle では、Key-Value マップの操作で役立つ可能性のあるメソッドが他にも用意されています。

- contains(String key) - 指定されたキーの値の有無を確認します。
- remove(String key) - 指定されたキーの値を削除します。
- keys() - SavedStateHandle 内に含まれるすべてのキーを返します。

また、オブザーバブルなデータホルダーを使用して SavedStateHandle から値を取得できます。サポートされている型は次のとおりです。

- LiveData
- StateFlow
- Compose の State API。

公式ドキュメントでは、この位置に、 「警告」 が書かれているが、この警告は、単に、 「ユーザーの意思でアプリが終了すると、 SavedStateHandle に保存されたデータは復元できない」 という意味だと思われるので、理解しづらい文章だが、気にしなくてよいだろう。


### LiveData

SavedStateHandle.getLiveData(key, initailValue) を使用すると、 SavedStateHandle から指定したキーの値を取り出して LiveData に格納します。

キーに紐づく値が更新されると、 LiveData に新しい値が格納されます。

実際のアプリでは、この値はほとんどの場合、データのリストをフィルタリングするためのクエリ入力など、ユーザー操作により、キーに紐づく値が更新されます。データが更新された後に、 LiveData の switchMap() 関数を使用すれば、更新後のデータをインプットにして、データをクエリするような処理も実装できます。

```kotlin
class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {
    val filteredData: LiveData<List<String>> =
        savedStateHandle.getLiveData<String>("query").switchMap { query ->
        // 更新後の値を使用して、フィルターを行う。
        repository.getFilteredData(query)
    }

    // キーに紐づく値を更新する関数
    fun setQuery(query: String) {
        savedStateHandle["query"] = query
    }
}
```


### StateFlow

注: StateFlow のサポートは Lifecycle バージョン 2.5.0 で追加されました。

[LiveData セクション](#livedata) 同様に、 SavedStateHandle の値が更新された場合に、イベントを受け取る仕組みですが、こちらは StateFlow を使用しているため、様々な Flow 演算子が使用できるというメリットがあります。

```kotlin
class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {
    val filteredData: StateFlow<List<String>> =
        savedStateHandle.getStateFlow<String>("query")
            .flatMapLatest { query ->
                repository.getFilteredData(query)
            }

    fun setQuery(query: String) {
        savedStateHandle["query"] = query
    }
}
```


### 試験運用版 Compose の State のサポート

注: 試験運用版 Compose State のサポートは Lifecycle バージョン 2.5.0 で追加されました。 (現在は試験運用が終わり、実運用になっている模様)

rememberSaveable と SavedStateHandle.saveable の主な違いは、その状態を保持するスコープにあります。

rememberSaveable は、 Composeable 関数内で使用されるため、そのライフサイクルは、 Compose のライフサイクルに連動します。一方で、 SavedStateHandle.saveable は、 ViewModel 内で使用されるため、 ViewModel のライフサイクルに連動します。メモリ不足等によって、プロセスが終了された後に、状態を復元できる点はどちらも同じです。

```kotlin
class SavedStateViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {

    var filteredData: List<String> by savedStateHandle.saveable {
        mutableStateOf(emptyList())
    }

    fun setQuery(query: String) {
        withMutableSnapshot {
            filteredData += query
        }
    }
}
```

withMutableSnapshot は、スレッドセーフに状態を更新するブロックを形成します。ブロック内の処理が一つのアトミックな操作として扱われるため、これが実現します。


## サポートされている型

### 直接サポートされている型

[公式ドキュメント](https://developer.android.com/topic/libraries/architecture/viewmodel/viewmodel-savedstate?hl=ja&_gl=1*151oa1r*_up*MQ..*_ga*MTE3NjE0ODY1NC4xNzIxOTcyNjA1*_ga_6HH9YJMN9M*MTcyMTk3MjYwNC4xLjAuMTcyMTk3MjYwNC4wLjAuMA..#direct) 参照

クラスが上記のリストのいずれも拡張しない場合は、@Parcelize Kotlin アノテーションを追加するか、Parcelable を直接実装して、クラスを Parcelable にすることを検討してください。


### 非 Parcelable クラスを保存する

クラスが Parcelable や Serializable を実装しておらず、これらのインターフェースのいずれかを実装するように変更できない場合、そのクラスのインスタンスを SavedStateHandle に直接保存できません。

その場合は、 SavedStateRegistry.SavedStateProvider を使用して、オブジェクトを Bundle に保存できるようになるまで分解する方法と、それを組み立ててオブジェクトを再生成する仕組みを自分で実装します。

以下の例は、 File オブジェクトを Bundle に保存するために、その File のパスの文字列を Bundle に保存する例です。

```kotlin
// Bundle を生成して返します。
// 引数は、 Bundle に保存する際のキーと値です。
// absolutePath は、レシーバー ( File ) のプロパティです。
private fun File.saveTempFile() = bundleOf("path" to absolutePath)

// Bundle からオブジェクトを復元する方法を定義
private fun Bundle.restoreTempFile() = if (containsKey("path")) {
    File(getString("path"))
} else {
    null
}

class TempFileViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {
    private var tempFile: File? = null
    init {
        // temp_file という名前の Bundle を取得します。
        val tempFileBundle = savedStateHandle.get<Bundle>("temp_file")
        if (tempFileBundle != null) {
            tempFile = tempFileBundle.restoreTempFile()
        }

        // savedStateHandle に SavedStateProvider を設定します。
        // temp_file という名前の Bundle への保存方法を定義します。
        savedStateHandle.setSavedStateProvider("temp_file") {
            // このブロックは、 SavedStateProvider の
            // saveState() 関数の実装の詳細です。
            // プロセスが強制終了される前に OS によって呼ばれます。
            if (tempFile != null) {
                tempFile.saveTempFile()
            } else {
                Bundle()
            }
        }
    }

    fun createOrGetTempFile(): File {
        return tempFile ?: File.createTempFile("temp", null).also {
            tempFile = it
        }
    }
}
```


## テストで SavedStateHandle を使用する

SavedStateHandle を依存関係として受け取る ViewModel をテストするには、必要なテスト値で SavedStateHandle の新しいインスタンスを作成し、テストする ViewModel インスタンスに渡します。

```kotlin
class MyViewModelTest {

    private lateinit var viewModel: MyViewModel

    @Before
    fun setup() {
        val savedState = SavedStateHandle(mapOf("someIdArg" to testId))
        viewModel = MyViewModel(savedState = savedState)
    }
}
```



