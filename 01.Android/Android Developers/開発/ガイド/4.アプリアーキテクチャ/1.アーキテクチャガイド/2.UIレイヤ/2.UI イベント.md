- [UI イベント](#ui-イベント)
  - [UI イベントの決定木](#ui-イベントの決定木)
  - [ユーザー イベントを処理する](#ユーザー-イベントを処理する)
    - [RecyclerView でのユーザー イベント](#recyclerview-でのユーザー-イベント)
  - [ViewModel イベントを処理する](#viewmodel-イベントを処理する)
    - [イベントの消費によって状態の更新をトリガーする](#イベントの消費によって状態の更新をトリガーする)
  - [ナビゲーションイベント](#ナビゲーションイベント)
    - [宛先がバックスタックに保持されている場合のナビゲーションイベント](#宛先がバックスタックに保持されている場合のナビゲーションイベント)
  - [その他のユースケース](#その他のユースケース)


# UI イベント

UI イベントは、UI または ViewModel によって UI レイヤで処理する必要があるアクションです。最も一般的なタイプのイベントは、ユーザー イベントです。ユーザーは画面をタップすることで、またはジェスチャーを生成することで、アプリを操作してユーザー イベントを生成します。UI は、onClick() リスナーなどのコールバックを使用してこれらのイベントを消費します。

**重要な用語:**

- **UI**: ユーザー インターフェースを処理する Android View のコード、または、 Compose コード。
- **UI イベント**: UI レイヤで処理する必要があるアクション。
- **ユーザー イベント**: アプリを操作するときにユーザーが生成するイベント。

ViewModel は通常、特定のユーザー イベント（ユーザーがボタンをクリックしてデータを更新するなど）のビジネス ロジックを処理します。通常、ViewModel は UI が呼び出せる関数を公開することにより、この処理を行います。ユーザー イベントは、別の画面に移動する、Snackbar を表示するなど、UI が直接処理できる UI 動作ロジックを持つ場合もあります。

同じアプリを異なるモバイル プラットフォームやフォーム ファクタで使用してもビジネス ロジックは変わりませんが、UI の動作ロジックは実装の詳細であり、ケース間で異なる可能性があります。UI レイヤのページでは、このようなロジックを次のように定義しています。

- ビジネスロジック
  - 簡単に言うと、ドメインレイヤーやデータレイヤーで実施する処理のこと
  - データの取得や更新のほか、特定のユースケースのロジックを示します。
- UI 動作ロジック ( UI ロジック)
  - ナビゲーションロジックやユーザーへのメッセージ表示方法など、何かを表示することが目的のロジックです。


## UI イベントの決定木

次の図は、イベントをどのように処理するのが最適かを分類する決定木です。

<img src="./画像/UIイベントの決定木.png" width="600">

特に、 UI で発生したイベント (ボタンのタップなど) は、 UI 要素で直接処理するべきか、 UI 状態 ( ViewModel ) に委譲して処理するべきかは分かれるところです。単なる画面遷移など、 ViewModel の状態を更新する必要がないようなイベントの場合は、 UI で直接処理するのが良いです。逆に、 ViewModel の状態を更新する必要がある場合や、データ層へアクセスする必要がある処理の場合は、 ViewModel に委譲する必要があります。

このドキュメントでは、これらについて、詳しく見ていきます。


## ユーザー イベントを処理する

ユーザー イベントが UI 要素の状態（展開可能なアイテムの状態など）の変更に関連する場合、UI でユーザー イベントを直接処理できます。画面上のデータを更新するなど、イベントがビジネス ロジックを実施する必要がある場合は、ViewModel で処理する必要があります。

次の例は、さまざまなボタンを使用して、UI 要素を開く方法（UI ロジック）と、画面上のデータを更新する方法（ビジネス ロジック）を示しています。

```kotlin
@Composable
fun LatestNewsScreen(viewModel: LatestNewsViewModel = viewModel()) {

    // 詳細欄の表示状態
    var expanded by remember { mutableStateOf(false) }

    Column {
        Text("Some text")
        if (expanded) {
            Text("More details")
        }

        Button(
            onClick = { expanded = !expanded }
        ) {
            val expandText = if (expanded) "Collapse" else "Expand"
            Text("$expandText details")
        }

        // データの更新はビジネスロジックであるため、
        // ViewModel に委譲します。
        Button(onClick = { viewModel.refreshNews() }) {
            Text("Refresh data")
        }
    }
}
```


### RecyclerView でのユーザー イベント

RecyclerView アイテムやカスタム View のように、UI ツリーの下位でアクションが生成される場合であっても、ViewModel はユーザー イベントを処理する必要があります。

たとえば、NewsActivity のすべてのニュース アイテムにブックマーク ボタンがあるとします。ViewModel は、ブックマークされたニュース アイテムの ID を知る必要があります。ユーザーがニュース アイテムをブックマークしたとき、RecyclerView アダプターは ViewModel から公開されている addBookmark(newsId) 関数を呼び出しません（それには ViewModel の依存関係が必要です）。代わりに ViewModel は、イベントを処理するための実装が含まれる NewsItemUiState という状態オブジェクトを公開します。

```kotlin
data class NewsItemUiState(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    val publicationDate: String,
    val onBookmark: () -> Unit
)

class LatestNewsViewModel(
    private val formatDateUseCase: FormatDateUseCase,
    private val repository: NewsRepository
)
    val newsListUiItems = repository.latestNews.map { news ->
        NewsItemUiState(
            title = news.title,
            body = news.body,
            bookmarked = news.bookmarked,
            publicationDate = formatDateUseCase(news.publicationDate),
            onBookmark = {
                repository.addBookmark(news.id)
            }
        )
    }
}
```

この方法で、 RecyclerView アダプターは必要なデータ ( NewsItemUiState オブジェクトのリスト) のみを処理します。アダプターは ViewModel 全体にアクセスできるわけではないため、 ViewModel が公開する機能が悪用される可能性が低くなります。アクティビティクラスのみが ViewModel と連携できるようにすると、役割を分離できます。これにより、ビューや RecyclerView アダプターなどの UI 固有のオブジェクトが ViewModel を直接操作しないことが保証されます。

警告: ViewModel を RecyclerView アダプターに渡すことは、アダプターと ViewModel クラスを密結合させることになるため、おすすめしません。

注: もう 1 つの一般的なパターンは、 RecyclerView アダプターがユーザーアクションのための Callback インターフェースを持つことです。その場合、アクティビティまたはフラグメントがバインディングを処理し、 ViewModel 関数をコールバックインターフェースから直接呼び出すことができます。


## ViewModel イベントを処理する

ViewModel のイベント ( ViewModel の関数) は、多くの場合、 UI 状態を更新することを目的とします。状態が変更された結果、 UI を更新することを意識することが、単方向データフローを厳守することにつながります。また、 ViewModel で保持している UI 状態を更新すれば、構成変更後も UI 状態を復元することができるためです。

たとえば、ユーザーがログイン画面でログインし、ホーム画面に移動するケースについて考えてみましょう。 UI の状態は、次のようにモデル化できます。

```kotlin
data class LoginUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isUserLoggedIn: Boolean = false
)
```

この UI は isUserLoggedIn 状態の変化に反応し、必要に応じて適切な移動先に移動します。

```kotlin
class LoginViewModel : ViewModel() {
    var uiState by mutableStateOf(LoginUiState())
        private set
    /* ... */
}

@Composable
fun LoginScreen(
    viewModel: LoginViewModel = viewModel(),
    onUserLogIn: () -> Unit
) {
    val currentOnUserLogIn by rememberUpdatedState(onUserLogIn)

    // LoginUiState の状態が変化するたびに生成されるコルーチン
    LaunchedEffect(viewModel.uiState)  {
        if (viewModel.uiState.isUserLoggedIn) {
            currentOnUserLogIn()
        }
    }
}
```


### イベントの消費によって状態の更新をトリガーする

状態が更新されたら、 Snackbar を表示 ( UI でイベントを消費) し、それをトリガーにして、また状態を更新する方法を以下で説明します。この方法は、タイムアウトに応じて状態を更新するような場合にも使用できます。

次の例では、スナックバーに表示する文字列を状態として定義し、スナックバーを表示したら、その状態をクリアするコードです。

```kotlin
// Models the UI state for the Latest news screen.
data class LatestNewsUiState(
    val news: List<News> = emptyList(),
    val isLoading: Boolean = false,
    // スナックバーに表示する文字列
    val userMessage: String? = null
)
```

```kotlin
class LatestNewsViewModel(/* ... */) : ViewModel() {

    var uiState by mutableStateOf(LatestNewsUiState())
        private set

    fun refreshNews() {
        viewModelScope.launch {
            // インターネット接続がない場合のメッセージ
            if (!internetConnection()) {
                uiState = uiState.copy(userMessage = "No Internet connection")
                return@launch
            }

            // インターネット接続がある場合の処理
        }
    }

    fun userMessageShown() {
        uiState = uiState.copy(userMessage = null)
    }
}
```

```kotlin
@Composable
fun LatestNewsScreen(
    snackbarHostState: SnackbarHostState,
    viewModel: LatestNewsViewModel = viewModel(),
) {
    // 状態クリア後は、 null のため、ブロックが実行されません。
    viewModel.uiState.userMessage?.let { userMessage ->
        LaunchedEffect(userMessage) {
            snackbarHostState.showSnackbar(userMessage)
            // スナックバー表示後にメッセージの状態をクリア
            viewModel.userMessageShown()
        }
    }
}
```

UI 状態は、画面の状態を忠実に再現するべきです。そのため、スナックバーが非表示になったら、状態をそれにあった状態に更新するべきです。 (今回の場合、メッセージをクリアする必要があります。)


## ナビゲーションイベント

次のコードは、最もシンプルな例です。

```kotlin
@Composable
fun LoginScreen(
    onHelp: () -> Unit, // Caller navigates to the right screen
    viewModel: LoginViewModel = viewModel()
) {
    // Rest of the UI

    Button(onClick = onHelp) {
        Text("Get help")
    }
}
```

次のコードは、画面遷移の前に ViewModel でバリデーションチェックなどの追加の処理が必要な場合の例です。

```kotlin
@Composable
fun LoginScreen(
    onUserLogIn: () -> Unit, // Caller navigates to the right screen
    viewModel: LoginViewModel = viewModel()
) {
    Button(
        onClick = {
            // ViewModel validation is triggered
            viewModel.login()
        }
    ) {
        Text("Log in")
    }
    // Rest of the UI

    val lifecycle = LocalLifecycleOwner.current.lifecycle
    val currentOnUserLogIn by rememberUpdatedState(onUserLogIn)
    LaunchedEffect(viewModel, lifecycle)  {
        // uiState が変化するたびに、ユーザーがログインしているかどうかを確認し、
        // `lifecycle` が少なくとも STARTED のときに
        // `onUserLogin` イベントを呼び出します。
        snapshotFlow { viewModel.uiState }
            .filter { it.isUserLoggedIn }
            .flowWithLifecycle(lifecycle)
            .collect {
                currentOnUserLogIn()
            }
    }
}
```


### 宛先がバックスタックに保持されている場合のナビゲーションイベント

以下の例は、 DobValidationScreen 画面から、次の画面に遷移する例です ( Dob は Date of birth )の略です) 。その際に、 validationInProgress という状態を参照して、次の画面に遷移する UI を構成するかどうかを判定しています。この判定により、意図せず次の画面に自動的に遷移するのを防いでいます。

```kotlin
class DobValidationViewModel(/* ... */) : ViewModel() {
    var uiState by mutableStateOf(DobValidationUiState())
        private set
}

@Composable
fun DobValidationScreen(
    onNavigateToNextScreen: () -> Unit,
    viewModel: DobValidationViewModel = viewModel()
) {
    // 検証を実施中かどうかの状態
    var validationInProgress by rememberSaveable { mutableStateOf(false) }

    Button(
        onClick = {
            // ViewModel に検証を委譲します。
            viewModel.validateInput()
            validationInProgress = true
        }
    ) {
        Text("Continue")
    }

    /*
     * 次のコードは、有効な生年月日が入力され、
     * ユーザーが登録プロセスを続行したい場合に、
     * 次の画面に進むという処理です。
     */

    if (validationInProgress) {
        val lifecycle = LocalLifecycleOwner.current.lifecycle
        val currentNavigateToNextScreen by rememberUpdatedState(onNavigateToNextScreen)
        LaunchedEffect(viewModel, lifecycle) {
            snapshotFlow { viewModel.uiState }
                // 検証結果が有効の場合のみ処理を後続に流す。
                .filter { it.isDobValid }
                // lifecycle が STARTED 以上の場合のみ後続に流し、それ未満の場合は一時停止する。
                .flowWithLifecycle(lifecycle)
                .collect {
                    validationInProgress = false
                    // 次の画面に遷移する。
                    currentNavigateToNextScreen()
                }
        }
    }
}
```

生年月日の検証は、ViewModel が担うビジネス ロジックです。ほとんどの場合、ViewModel はそのロジックをデータレイヤ or ドメインレイヤーに委任します。なぜなら、生年月日の検証は、一つの画面に固有の処理ではなく、複数の画面で共通的に使用される可能性のある処理であるためです。一方、ユーザーを次の画面に移動させるための処理は UI ロジックです。


## その他のユースケース

UI イベントのユースケースを UI イベントの更新では解決できないと思われる場合は、アプリのデータフローを再検討する必要が生じることがあります。次の原則を考慮してください。

- **各クラスがそれぞれの役割だけを担い、それ以上は行わないようにします。** UI は、ナビゲーション呼び出し、クリック イベント、権限リクエストの取得など、画面固有の動作ロジックを担います。ViewModel にはビジネス ロジックが含まれており、階層の下位レイヤからの結果を UI の状態に変換します。
- **イベントの発生源を考えます。** このガイドの冒頭で示した決定木に沿って、各クラスが担うものを処理するようにします。たとえば、イベントが UI から発生し、ナビゲーション イベントとなる場合、そのイベントは UI で処理する必要があります。一部のロジックは ViewModel にデリゲートされますが、イベントの処理を完全に ViewModel にデリゲートすることはできません。
- **複数のコンシューマーが存在し、イベントが複数回消費されることが心配な場合、アプリのアーキテクチャを再検討する必要が生じることがあります。** 複数のコンシューマーが同時に存在すると、1 回だけ配信されるコントラクトを保証することが非常に難しくなるため、複雑さと微妙な動作が爆発的に増加します。この問題が発生した場合は、そうした事項を UI ツリーの上位に出すことを検討してください。階層の上位にスコープ設定された別のエンティティが必要になる場合があります。
- **状態を消費する必要が生じるタイミングを考えます。** 状況によっては、アプリがバックグラウンドにあるときに状態の消費を維持したくない場合があります（Toast を表示するなど）。そのような場合は、UI がフォアグラウンドにあるときに状態を消費することを検討してください。

注: 一部のアプリでは、 [Kotlin チャネル](https://kotlinlang.org/docs/channels.html) 、または、他のリアクティブ ストリームを使用して ViewModel イベントが UI に公開されていることがあります。プロデューサー（ViewModel）の生存期間がコンシューマー（UI - Compose または View）よりも長くなると、前述のソリューションでもイベントの配信と処理が保証されなくなります。これは、デベロッパーにとって今後問題となる可能性があります。また、アプリが一貫性のない状態になったり、バグが生じたり、ユーザーが重要な情報を見落としたりするおそれも生じるため、ほとんどのアプリのユーザー エクスペリエンスが非常に悪くなります。

こうした状況になってしまった場合は、単発の ViewModel イベントが UI にとって実際どのような意味を持つのかを再検討し、すぐに対処して、UI の状態に戻してください。UI の状態は、特定の時点での UI を適切に表すことができます。また、多くの配信と処理が保証され、通常はテストが容易になり、アプリの他の部分と一貫して統合されます。

前述の API と一部のコードサンプルについては、組み合わせて使用しないことをおすすめします。詳しくは、ブログ投稿「 [ViewModel: One-off event antipatterns](https://medium.com/androiddevelopers/viewmodel-one-off-event-antipatterns-16a1da869b95) 」をご覧ください。






