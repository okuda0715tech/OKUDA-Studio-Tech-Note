- [ナビゲーショングラフを設計する](#ナビゲーショングラフを設計する)
  - [デスティネーションのタイプ](#デスティネーションのタイプ)
    - [ホストされているデスティネーション](#ホストされているデスティネーション)
      - [説明](#説明)
      - [用途](#用途)
    - [ダイアログのデスティネーション](#ダイアログのデスティネーション)
      - [説明](#説明-1)
      - [用途](#用途-1)
    - [アクティビティのデスティネーション](#アクティビティのデスティネーション)
      - [説明](#説明-2)
      - [用途](#用途-2)
  - [フレームワーク](#フレームワーク)
  - [Compose](#compose)
    - [NavHost のラムダの仕組み（NavController.createGraph() を直接使用する方法）](#navhost-のラムダの仕組みnavcontrollercreategraph-を直接使用する方法)
    - [引数を渡す（ディスティネーションにデータを渡す）](#引数を渡すディスティネーションにデータを渡す)
    - [ルートインスタンスを取得する（渡されてきた引数を使用する）](#ルートインスタンスを取得する渡されてきた引数を使用する)
    - [最も簡単な例](#最も簡単な例)
  - [フラグメント](#フラグメント)
    - [プログラマティック](#プログラマティック)
    - [XML](#xml)
    - [エディタ](#エディタ)
  - [ネストされたグラフ](#ネストされたグラフ)


# ナビゲーショングラフを設計する

Navigation コンポーネントでは、ナビゲーション グラフを使用してアプリのナビゲーションを管理します。ナビゲーション グラフとは、アプリ内の各デスティネーションと、それらの間の接続を含むデータ構造です。

注: ナビゲーション グラフは、バックスタック（ユーザーが最近訪れたデスティネーションを保持する NavController 内のスタック）とは異なります。


## デスティネーションのタイプ

デスティネーションの一般的なタイプとしては、ホストされているデスティネーション、アクティビティのデスティネーション、ダイアログのデスティネーションの 3 つがあります。以下に、これら 3 つのデスティネーションタイプとその用途をまとめます。


### ホストされているデスティネーション

#### 説明

ナビゲーションホスト全体を埋めるデスティネーションです。ホストされたデスティネーションのサイズはナビゲーション ホストのサイズと同じとなり、それ以前のデスティネーションは表示されなくなります。

#### 用途

メイン画面や詳細画面で使用されます。


### ダイアログのデスティネーション

#### 説明

オーバーレイ UI コンポーネントを表すデスティネーションです。この UI は、ナビゲーション ホストの場所やサイズには関連付けられません。それ以前のデスティネーションは、このデスティネーションの下に表示されます。

#### 用途

アラート、多肢選択、フォームで使用されます。


### アクティビティのデスティネーション

#### 説明

アプリ内の固有の画面、または、機能を表すデスティネーションです。

ナビゲーション グラフの終了ポイントとして機能し、Navigation コンポーネントとは別に管理されている新しい Android アクティビティを開始します。

#### 用途

最新の Android 開発では、アプリを 1 つのアクティビティで構成します。アクティビティのデスティネーションは、サードパーティ アクティビティとやり取りする場合や、 Navigation コンポーネントを使用したアプリへの [移行プロセス](https://developer.android.com/guide/navigation/migrate?hl=ja&_gl=1*13r71rl*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzc5NDczMy4yLjAuMTczMzc5NDczMy4wLjAuNTg5MDkxMTY3) の一部として使用するのが最適です。

このドキュメントでは、最も一般的で基本的なデスティネーションである「ホストされているデスティネーション」の例を示します。それ以外のデスティネーションについては、以下のガイドをご覧ください。

- [ダイアログのデスティネーション](https://developer.android.com/guide/navigation/design/dialog-destinations?hl=ja&_gl=1*wz7ptf*_up*MQ..*_ga*ODE2OTg0MTAyLjE3MjM1NDg0MzM.*_ga_6HH9YJMN9M*MTcyMzYwMzc3MS4yLjAuMTcyMzYwMzc3MS4wLjAuMA..)
- [アクティビティのデスティネーション](https://developer.android.com/guide/navigation/design/activity-destinations?hl=ja&_gl=1*wz7ptf*_up*MQ..*_ga*ODE2OTg0MTAyLjE3MjM1NDg0MzM.*_ga_6HH9YJMN9M*MTcyMzYwMzc3MS4yLjAuMTcyMzYwMzc3MS4wLjAuMA..)


## フレームワーク

どの場合にも同じ一般的なワークフローが適用されますが、ナビゲーション ホストとグラフの作成方法は使用する UI フレームワークによって異なります。

- **Compose で作成する**: NavHost コンポーザブルを使用します。Kotlin DSL を使用して、NavGraph を追加します。グラフは次の 2 つの方法で作成できます。
  - NavHost の一部として作成する: NavHost を追加する際に、その一部としてナビゲーション グラフを直接作成します。
  - プログラマティックに作成する: [NavController.createGraph()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*uzwoj2*_up*MQ..*_ga*ODE2OTg0MTAyLjE3MjM1NDg0MzM.*_ga_6HH9YJMN9M*MTcyMzYwMzc3MS4yLjAuMTcyMzYwMzc3MS4wLjAuMA..#(androidx.navigation.NavController).createGraph(kotlin.Int,kotlin.Int,kotlin.Function1)) メソッドを使用して NavGraph を作成し、直接 NavHost に渡します。
- **フラグメントで作成する**: View UI フレームワークでフラグメントを使用する場合は、ホストとして NavHostFragment を使用します。ナビゲーション グラフはいくつかの方法で作成できます。
  - プログラマティックに作成する: Kotlin DSL を使用して NavGraph を作成し、NavHostFragment に直接適用します。
    - フラグメントと Compose の両方で Kotlin DSL で使用される createGraph() 関数は同じです。
  - XML で作成する: ナビゲーション ホストとグラフを XML で直接記述します。
  - Android Studio エディタ: Android Studio の GUI エディタを使用して、グラフを XML リソース ファイルとして作成、調整します。


## Compose

このセクションとほとんど重複した内容ですが、 「型安全なルートとパラメータの渡し方」 については、 [7.型安全性.md](./7.型安全性.md) のドキュメントも参考にできます。

Compose では、シリアル化可能なオブジェクトまたはクラスを使用してルートを定義します。ルートは、目的地への経路を記述し、目的地に必要なすべての情報を含みます。

@Serializable アノテーションを使用して、ルートタイプに必要なシリアル化メソッドとシリアル化解除メソッドを自動的に作成します。このアノテーションは、 [Kotlin シリアル化プラグイン](https://kotlinlang.org/docs/serialization.html) によって提供されます。 [こちらの手順に沿ってこのプラグインを追加します。](https://developer.android.com/guide/navigation?hl=ja&_gl=1*b3lb8g*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzc5NDczMy4yLjAuMTczMzc5NDczMy4wLjAuNTg5MDkxMTY3#set-up) (型安全な Navigation を使用するには、 Navigation のバージョンが 2.8.0 以降である必要があります。)

ルートを定義したら、NavHost コンポーザブルを使用してナビゲーション グラフを作成します。次の例を考えてみましょう。

```kotlin
// ルート (経路) の定義
@Serializable
object Profile
@Serializable
object FriendsList

// NavHostController.kt に用意されている関数を使用して NavController を取得
val navController = rememberNavController()

NavHost(navController = navController, startDestination = Profile) {
    // このラムダブロックは、
    // ブロック内に含まれるデスティネーションを含む NavGraph を返します。

    composable<Profile> {
        // デスティネーションに移動した際に、実際に表示される画面
        ProfileScreen( /* ... */ )
    }

    composable<FriendsList> {
        FriendsListScreen( /* ... */ )
    }

    // 同様に他のデスティネーションも追加します。
}
```

1. シリアル化可能なオブジェクトは、Profile と FriendsList の 2 つのルートのそれぞれを表します。

2. NavHost コンポーザブルを呼び出す際は、 NavController と開始デスティネーションを渡します。

3. NavHost に渡されたラムダにより、最終的に [NavController.createGraph()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*9j9e*_up*MQ..*_ga*MTc0OTYwNDU4MS4xNzIzNjE0MjU2*_ga_6HH9YJMN9M*MTcyMzYxNDI1Ni4xLjAuMTcyMzYxNDI1Ni4wLjAuMA..#(androidx.navigation.NavController).createGraph(kotlin.Int,kotlin.Int,kotlin.Function1)) が呼び出され、NavGraph が返されます。

4. 各ルートは [`NavGraphBuilder.composable<T>()`](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?hl=ja&_gl=1*2gjc3t*_up*MQ..*_ga*MTc0OTYwNDU4MS4xNzIzNjE0MjU2*_ga_6HH9YJMN9M*MTcyMzYxNDI1Ni4xLjAuMTcyMzYxNDI1Ni4wLjAuMA..#(androidx.navigation.NavGraphBuilder).composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2)) の型引数として指定します。 NavGraphBuilder.composable<T>() 関数は、生成される NavGraph にデスティネーションを追加します。

5. composable に渡されるラムダは、そのデスティネーションに対して NavHost が表示するものです。

**注意** : composable() に型を渡す代わりに、route 文字列または整数 id を渡すことができます。ただし、この方法では、デスティネーションに追加の引数を渡すことがはるかに難しくなります。


### NavHost のラムダの仕組み（NavController.createGraph() を直接使用する方法）

[NavController.createGraph()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*1o3uryz*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzc5NDczMy4yLjAuMTczMzc5NDczMy4wLjAuNTg5MDkxMTY3#(androidx.navigation.NavController).createGraph(kotlin.Int,kotlin.Int,kotlin.Function1)) を使用して個別に NavGraph を作成し、直接 NavHost に渡すことができます。

前の例の NavHost コンポーザブルのラムダブロックは、 NavController.createGraph() を使用した場合は、次のように記述することができます。

```kotlin
val navGraph by remember(navController) {
    navController.createGraph(startDestination = Profile)) {
        composable<Profile> { ProfileScreen( /* ... */ ) }
        composable<FriendsList> { FriendsListScreen( /* ... */ ) }
    }
}
NavHost(navController, navGraph)
```

重要: NavController は、単一の NavHost コンポーザブルに関連付けられます。 NavHost は、 NavController からナビゲーション グラフへのアクセスを提供します。 NavController を使用してデスティネーションに移動する場合、関連付けられている NavHost とのやり取りは NavController が行います。


### 引数を渡す（ディスティネーションにデータを渡す）

デスティネーションにデータを渡す必要がある場合は、パラメータを持つルートクラスを定義します。たとえば、 Profile ルートは name パラメータを持つデータクラスです。

```kotlin
@Serializable
data class Profile(val name: String)
```

デスティネーションに引数を渡す必要がある場合は、ルートクラスのインスタンスを作成して、 NavHost 関数の startDestination パラメータ等に渡します。

**注: 引数付きのルートには data class を使用し、引数のないルートには object または data object を使用します。**

オプションの引数には、 null を許容するフィールドを定義し、デフォルト値を null にします。

```kotlin
@Serializable
data class Profile(val nickname: String? = null)
```


### ルートインスタンスを取得する（渡されてきた引数を使用する）

ルート インスタンスは、NavBackStackEntry.toRoute() 、または、 SavedStateHandle.toRoute() で取得できます。 composable() 関数を使用してデスティネーションを作成する場合は、 NavBackStackEntry をパラメータとして使用できます。

```kotlin
@Serializable
data class Profile(val name: String)

val navController = rememberNavController()

NavHost(navController = navController, startDestination = Profile(name="John Smith")) {
    composable<Profile> { backStackEntry ->
        // ルートクラスを取得する。
        val profile: Profile = backStackEntry.toRoute()
        // ルートクラスに格納された値を取得して、
        // コンポーザブル関数 (実際の画面) に渡す。
        ProfileScreen(name = profile.name) }
}
```

このスニペットでは、次の点に注意してください。

- ナビゲーション グラフの開始デスティネーションには、 name パラメータに "John Smith" を指定した Profile ルートクラスを渡します。
- デスティネーション自体は `composable<Profile>{}` ブロックです。
- ProfileScreen コンポーザブルは、 name 引数に profile.name の値を受け取ります。
- そのため、値 "John Smith" は ProfileScreen に渡されます。


### 最も簡単な例

以下に、NavController と NavHost が連動する完全な例を示します。

```kotlin
@Serializable
data class Profile(val name: String)

@Serializable
object FriendsList

@Composable
fun ProfileScreen(
    profile: Profile,
    onNavigateToFriendsList: () -> Unit,
) {
    Column {
        Text("Profile for ${profile.name}")
        Button(onClick = { onNavigateToFriendsList() }) {
            Text("Go to Friends List")
        }
    }
}

@Composable
fun FriendsListScreen(onNavigateToProfile: () -> Unit) {
    Column {
        Text("Friends List")
        Button(onClick = { onNavigateToProfile() }) {
            Text("Go to Profile")
        }
    }
}

@Composable
fun MyApp() {
    val navController = rememberNavController()
    NavHost(navController, startDestination = Profile(name = "John Smith")) {
        composable<Profile> { backStackEntry ->
            val profile: Profile = backStackEntry.toRoute()
            ProfileScreen(
                profile = profile,
                onNavigateToFriendsList = {
                    navController.navigate(route = FriendsList)
                }
            )
        }
        composable<FriendsList> {
            FriendsListScreen(
                onNavigateToProfile = {
                    navController.navigate(
                        route = Profile(name = "Aisha Devi")
                    )
                }
            )
        }
    }
}
```

このスニペットでは、NavController をコンポーザブルに渡す代わりに、イベントを NavHost に公開しています。この場合、コンポーザブルには、NavHost で NavController.navigate() を呼び出すラムダを渡すための `() -> Unit` 型のパラメータが必要となります。

注: ルートクラスのパラメータを使用すると、完全な型安全性を確保したまま、指定されたデスティネーションにデータを渡すことができます。たとえば、前のコード Profile.name では、name が常に String であることが保証されます。


## フラグメント

### プログラマティック

### XML

### エディタ

## ネストされたグラフ

ネストされたグラフを使用することもできます。その場合は、グラフをナビゲーション デスティネーションとして使用します。詳しくは、 [ネストされたグラフ](./4.ネストされたグラフ.md) をご覧ください。



