- [ナビゲーションコードをカプセル化する](#ナビゲーションコードをカプセル化する)
  - [リンク先の抽出](#リンク先の抽出)
  - [例](#例)
    - [デスティネーションを作成する（ScreenとViewModelの連携）](#デスティネーションを作成するscreenとviewmodelの連携)
    - [ナビゲーションイベントをカプセル化する](#ナビゲーションイベントをカプセル化する)
    - [まとめ](#まとめ)
  - [まとめ](#まとめ-1)


# ナビゲーションコードをカプセル化する

Kotlin DSL を使用してグラフを作成する場合、デスティネーションとナビゲーション イベントを 1 つのファイル内に維持するのは難しいことがあります。これは、独立した機能が複数ある場合に特に当てはまります。


## リンク先の抽出

デスティネーションを [NavGraphBuilder](https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder?hl=ja&_gl=1*wj0trj*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzkxMDU2Mi4zLjAuMTczMzkxMDU2Mi4wLjAuOTc2MjEyMTgz) スコープに移動する必要があります。デスティネーションは、デスティネーションを定義するルートや、デスティネーションが表示される画面 ( XxxxScreen ) の近くに配置する必要があります。たとえば、連絡先のリストを表示するデスティネーションを作成する次のコードについて考えてみます。

```kotlin
// MyApp.kt

@Serializable
object Contacts

@Composable
fun MyApp() {
    NavHost(navController, startDestination = Contacts) {
        composable<Contacts> { ContactsScreen( /* ... */ ) }
    }
}
```

ナビゲーション固有のコードを別のファイルに移動する必要があります。

```kotlin
// ContactsNavigation.kt

@Serializable
object Contacts

fun NavGraphBuilder.contactsDestination() {
    composable<Contacts> { ContactsScreen( /* ... */ ) }
}

// MyApp.kt

@Composable
fun MyApp() {
    NavHost(navController, startDestination = Contacts) {
        contactsDestination()
    }
}
```

ルートとデスティネーションの定義がメインアプリから分離され、個別に更新できるようになりました。メインアプリは 1 つの拡張関数にのみ依存します。この場合は NavGraphBuilder.contactsDestination() です。

NavGraphBuilder 拡張関数は、ステートレスの画面レベルのコンポーズ可能な関数と Navigation 固有のロジック間のブリッジを形成します。このレイヤでは、状態の取得元とイベントの処理方法も定義できます。

注: これは、1 つのモノリシック コンポーズ可能な関数で画面を定義するのではなく、画面を別のコンポーズ可能な関数に移動する場合と基本的に同じアプローチです。 **要するに、一つの大きな NavHost() 関数があるよりは、画面部分を別の関数に切り出して、小さな NavHost() 関数にした方が、 「画面遷移に関する処理」 と 「画面表示の準備に関する処理」 が分離されて、管理しやすくなる可能性がある** という意味だと思われます。


## 例

連絡先リスト画面 ( ContactsScreen ) から、連絡先詳細画面 ( ContactDetailsScreen ) に遷移するためのナビゲーションイベントを公開します。

以下の例では、パッケージ直下の関数に internal 修飾子を付与することで、他のモジュールからはアクセスできないようにしています。

```kotlin
// ContactScreens.kt

// 連絡先の一覧画面
@Composable
internal fun ContactsScreen(
    uiState: ContactsUiState,
    onNavigateToContactDetails: (contactId: String) -> Unit
) { ... }

// 特定の連絡先の詳細画面
@Composable
internal fun ContactDetailsScreen(contact: ContactDetails) { ... }
```


### デスティネーションを作成する（ScreenとViewModelの連携）

次の NavGraphBuilder 拡張関数は、 ContactsScreen コンポーザブルを表示するデスティネーションを作成します。さらに、 ViewModel (画面 UI の状態を提供し、ビジネス ロジックを処理する) と Screen を接続できるようになりました。

連絡先詳細デスティネーションへの移動などのナビゲーション イベントは、 ViewModel で処理されず、呼び出し元に公開されます。

```kotlin
// ContactsNavigation.kt

@Serializable
object Contacts

// Contacts デスティネーションをこの NavGraphBuilder に追加します。
fun NavGraphBuilder.contactsDestination(
    // ナビゲーションイベントは、呼び出し元で管理できるように公開します。
    onNavigateToContactDetails: (contactId: String) -> Unit
) {
    composable<Contacts> {
        // 画面レベルの状態ホルダーである ViewModel は、
        // 画面 UI 状態を生成し、さらに、
        // ConversationScreen のビジネスロジックを処理します。
        val viewModel: ContactsViewModel = hiltViewModel()
        val uiState = viewModel.uiState.collectAsStateWithLifecycle()
        ContactsScreen(
            uiState,
            onNavigateToContactDetails
        )
    }
}
```

同じ方法で、 ContactDetailsScreen を表示するデスティネーションを作成できます。 ContactDetailsScreen の場合、 ViewModel から UI 状態を取得するのではなく、 NavBackStackEntry から直接取得できます。

```kotlin
// ContactsNavigation.kt

@Serializable
internal data class ContactDetails(val id: String)

fun NavGraphBuilder.contactDetailsScreen() {
    composable<ContactDetails> { navBackStackEntry ->
        // composable() 関数の型パラメータが ContactDetails であるため、
        // toRoute() 関数の結果は、 ContactDetails のインスタンスを返します。
        ContactDetailsScreen(contact = navBackStackEntry.toRoute())
    }
}
```


### ナビゲーションイベントをカプセル化する

デスティネーションをカプセル化する方法と同じ方法で、ナビゲーション イベントをカプセル化することができます。カプセル化することにより、ルートクラスへの不必要な依存関係を無くすことができます。次のように、 NavController の拡張関数を定義することで、カプセル化が行えます。

```kotlin
// ContactsNavigation.kt

fun NavController.navigateToContactDetails(id: String) {
    navigate(route = ContactDetails(id = id))
}
```

これにより、この関数 ( navigateToContactDetails ) の呼び出し元は、 ContactDetails クラスへの依存関係が消え、 `id: String` のみを知っていれば良いことになります。


### まとめ

連絡先を表示するためのナビゲーション コードが、アプリのナビゲーション グラフから明確に分離されました。アプリは次のことを行う必要があります。

- NavGraphBuilder 拡張関数を呼び出してデスティネーションを作成する
- ナビゲーション イベントに対して NavController 拡張関数を呼び出して、これらのデスティネーションを接続する

```kotlin
// MyApp.kt

@Composable
fun MyApp() {
    NavHost(navController, startDestination = Contacts) {
        // デスティネーションのカプセル化
        contactsDestination(onNavigateToContactDetails = { contactId ->
            // ナビゲーションイベントのカプセル化
            navController.navigateToContactDetails(id = contactId)
        })
        // デスティネーションのカプセル化
        contactDetailsDestination()
    }
}
```


## まとめ

- 関連する画面セットのナビゲーション コードを別のファイルに配置してカプセル化する
- NavGraphBuilder に拡張関数を作成してデスティネーションを公開する
- NavController で拡張関数を作成してナビゲーション イベントを公開する
- internal を使用して画面とルートタイプを非公開にする

