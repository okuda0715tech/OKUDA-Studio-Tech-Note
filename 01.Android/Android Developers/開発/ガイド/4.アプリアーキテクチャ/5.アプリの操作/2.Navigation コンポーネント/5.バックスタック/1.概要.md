- [ナビゲーションとバックスタック](#ナビゲーションとバックスタック)
  - [基本的な動作](#基本的な動作)
  - [popBackStack() の使用を避けるべき理由](#popbackstack-の使用を避けるべき理由)
  - [ポップバック](#ポップバック)
    - [特定のデスティネーションにポップバックする](#特定のデスティネーションにポップバックする)
    - [失敗したポップバックを処理する](#失敗したポップバックを処理する)
  - [別のデスティネーションに移動する際に、バックスタックからいくつかをポップアップする](#別のデスティネーションに移動する際にバックスタックからいくつかをポップアップする)
    - [ポップアップ時に状態を保存する](#ポップアップ時に状態を保存する)
    - [XML の例](#xml-の例)
    - [Compose の例](#compose-の例)
  - [アクションを使用してポップする](#アクションを使用してポップする)


# ナビゲーションとバックスタック 

NavController は、ユーザーがアクセスした目的地を含む「バック スタック」を保持します。ユーザーがアプリ内の画面を移動すると、NavController はバック スタックに目的地を追加したり、バック スタックから目的地を削除したりします。

スタックであるため、バック スタックは「後入れ先出し」のデータ構造です。したがって、NavController はスタックの先頭にアイテムをプッシュしたり、スタックの先頭からアイテムをポップしたりします。

重要: バック スタックは基本的に NavController クラスの一部であるため、どの UI フレームワークを使用しても、その動作は一貫しています。


## 基本的な動作

バックスタックの動作については、次の点に注意してください。

- **最初のデスティネーション**: ユーザーがアプリを開くと、NavController は最初のデスティネーションをバックスタックの一番上にプッシュします。
- **スタックへのプッシュ**: [NavController.navigate()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*tlxunv*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5#navigate(int)) が呼び出されるたびに、特定のデスティネーションがスタックの一番上にプッシュされます。
- **最上部のデスティネーションをポップする**: [上へ] をタップすると、 [NavController.navigateUp()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*9a7y8r*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5#navigateUp()) メソッドが呼び出され、 [戻る] をタップすると、 [NavController.popBackStack()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*9a7y8r*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5#popBackStack()) メソッドが呼び出され、スタックの最上部にあるデスティネーションがポップされます。
  - [上へ] と [戻る] の違いについて詳しくは、 [ナビゲーションの原則](../../1.ナビゲーションの原則.md/#上へ-と-戻る-の違い) ( [引用元はこちら](https://developer.android.com/guide/navigation/principles?hl=ja&_gl=1*104g9ro*_up*MQ..*_ga*MjE0Mzg5MDEyMy4xNzIzNjg5ODUz*_ga_6HH9YJMN9M*MTcyMzcxMjQyMy4zLjAuMTcyMzcxMjQyMy4wLjAuMA..#the_up_button_never_exits_your_app) ) のページをご覧ください。
  - **個人的に、 popBackStack() の使用はお勧めしません。 (同様に navigateUp() も避けるべきだと思われます。)** 詳細は後述します。


## popBackStack() の使用を避けるべき理由

`NavController.popBackStack()` 関数は、現在のバックスタックの一番上のデスティネーションをポップします。この動作によって、一部のユースケースで、問題が発生しました。

「 A という画面から、 B という画面に遷移し、その後すぐに popBackStack() 関数を使用して、 A に戻る」 というケースについて、問題が発生しました。

このユースケースでは、本来であれば、 B がポップされ、 A に戻ることが期待されます。しかし、実際には、バックスタック上に B が積まれる前に、ポップ処理が行われ、 A がポップされてしまい、バックスタックが空になってしまう。という現象が頻繁に発生します。

この問題を防ぐために、理論的に考えられる方法は以下の 2 つです。

- 現在のデスティネーションが B の場合 (つまり、バックスタックに B が積まれていることが確認できた場合) のみ、ポップ処理 ( popBackStack() ) を実施する。
- popBackStack() 関数は使用せず、明示的に、デスティネーション A への遷移を行う。

ただし、前者の方法は、実際に実装することが困難になります。なぜなら、型安全なルートでは、 「現在のデスティネーションが何か？」 を確認することが困難であるためです。 2025 年 1 月現在、私が調べた限りでは、これを実装する方法は見つかりませんでした。

となると、後者の方法で、前の画面に戻る方法が現実的で、適切だと言えます。実際の実装方法については、 [Compose の例](#compose-の例) セクションを参照してください。


## ポップバック

[NavController.popBackStack()](https://developer.android.com/reference/androidx/navigation/NavController?hl=ja&_gl=1*h1k5gz*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5#popBackStack()) メソッドでは、バックスタックから現在のデスティネーションがポップされ、前のデスティネーションへの移動が行われます。これにより、ユーザーは実質的にナビゲーション履歴内の 1 つ前のステップに戻ることができます。このメソッドでは、正常にポップされて、一つ前のデスティネーションに戻ったかどうかを示すブール値が返されます。


### 特定のデスティネーションにポップバックする

popBackStack() を使用して特定のデスティネーションに移動することもできます。これを行うには、そのオーバーロードの一つを使用します。整数の id や文字列の route など、識別子を渡すことができるものがいくつかあります。これらのオーバーロードにより、指定された識別子に関連付けられたデスティネーションにユーザーを誘導します。 **重要なのは、スタック内のそのデスティネーションの上にあるすべてのデスティネーションをポップすることです。**

これらのオーバーロードは、 Boolean 型の `inclusive` パラメータも受け取ります。これは、NavController が、指定されたデスティネーションに移動した後に、そのデスティネーションをバックスタックからポップするかどうかを決定します。

次の簡単なスニペットを例にとりましょう。

```kotlin
navController.popBackStack(R.id.destinationId, true)
```

ここでは、NavController により、整数 ID destinationId のデスティネーションにポップバックします。inclusive 引数の値が true であるため、NavController は指定されたデスティネーションもバックスタックからポップします。


### 失敗したポップバックを処理する

popBackStack() が false を返すと、その後の NavController.getCurrentDestination() の呼び出しでは null が返ります。これは、アプリがバックスタックから最後のデスティネーションをポップしたことを意味します。この場合 ユーザーは 空白の画面にのみ移動できます。

これは、次のような場合に発生することがあります。

- popBackStack() がスタックから何もポップしなかった場合
- popBackStack() がバックスタックからデスティネーションをポップし、スタックが空になった場合

この問題を解決するには、新しいデスティネーションに移動するか、アクティビティで finish() を呼び出して終了する必要があります。この手順を行うスニペットは以下のとおりです。

```kotlin
if (!navController.popBackStack()) {
    // Call finish() on your Activity
    finish()
}
```

注: popBackStack() が false を返す最も一般的なケースは、次のように、バックスタックに残る最後のデスティネーションであるはずの開始デスティネーションをバックスタックから手動でポップした場合です。


## 別のデスティネーションに移動する際に、バックスタックからいくつかをポップアップする

あるデスティネーションから別のデスティネーションに移動するときに、バックスタックからデスティネーションを削除するには、関連する navigate() 関数呼び出しに `popUpTo()` 引数を追加します。popUpTo() は、navigate() の呼び出しの一部として、バックスタックから一部のデスティネーションを削除するよう Navigation ライブラリに指示します。パラメータ値は、バックスタック上のデスティネーションの識別子です。識別子は、整数 id または文字列 route のいずれかです。

`inclusive` パラメータの引数に true を指定して、popUpTo() で指定したデスティネーションもバックスタックからポップするように指定することもできます。

これをプログラムで実装するには、inclusive を true に設定した [NavOptions](https://developer.android.com/guide/navigation/use-graph/navoptions?hl=ja&_gl=1*tedgae*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5) の一部として、popUpTo() を navigate() に渡します。これは Compose と Android View システムの両方で機能します。

注: Android View システムでは、関連する `<action>` 要素に `app:popUpTo` 属性を追加します。 inclusive パラメータには `app:popUpToInclusive="true"` 属性を設定します。


### ポップアップ時に状態を保存する

popUpTo() を使用してデスティネーションを移動する場合、オプションで、バックスタックと、バックスタックからポップされたすべてのデスティネーションの状態を保存できます。その後、後で、そのデスティネーションに移動するときに、バックスタックとデスティネーションを復元できます。これにより、特定のデスティネーションの状態を保存し、 [複数のバックスタック](https://developer.android.com/guide/navigation/backstack/multi-back-stacks?hl=ja&_gl=1*uwo6b6*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5) を持つことができます。

これをプログラムで実行するには、ナビゲーション オプションに popUpTo() を追加するときに `saveState = true` を指定します。

ナビゲーション オプションで `restoreState = true` を指定して、バックスタックとデスティネーションに関連付けられた状態を自動的に復元することもできます。

```kotlin
navController.navigate(
    route = route,
    navOptions =  navOptions {
        popUpTo<A>{ saveState = true }
        restoreState = true
    }
)
```

XML での状態の保存と復元を有効にするには、関連するアクションで popUpToSaveState を true に、restoreState を true にそれぞれ定義します。


### XML の例

以下は、 action を使用した XML での popUpTo の例です。

```xml
<action
    android:id="@+id/action_a_to_b"
    app:destination="@id/b"
    app:popUpTo="@+id/a"
    app:popUpToInclusive="true"
    app:restoreState=”true”
    app:popUpToSaveState="true"/>
```


### Compose の例

以下は、Compose での完全な例です。

```kotlin
@Composable
fun MyAppNavHost(
    modifier: Modifier = Modifier,
    navController: NavHostController = rememberNavController(),
    startDestination: Any = A
) {
    NavHost(
        modifier = modifier,
        navController = navController,
        startDestination = startDestination
    ) {
        composable<A> {
            DestinationA(
                onNavigateToB = {
                    // デスティネーション B に遷移します。
                    navController.navigate(route = B) {
                        // デスティネーション A を含み、 A より上のすべての
                        // デスティネーションをポップアップします。
                        popUpTo<A> {
                            inclusive = true
                            // ポップアップしたデスティネーションの状態を保持します。
                            saveState = true
                        }
                        // 以前、デスティネーション B をポップアップした際に保存された
                        // 全てのバックスタックの状態を復元します。
                        restoreState = true
                    }
                },
            )
        }
        composable<B> { DestinationB(/* ... */) }
    }
}

@Composable
fun DestinationA(onNavigateToB: () -> Unit) {
    Button(onClick = onNavigateToB) {
        Text("Go to B")
    }
}
```

`saveState = true` で保存できるデータは、 rememberSaveable() で保持されていたデータや、 LazyColumn のスクロール位置や、 TextField の入力文字列です。 remember() で保持されていたデータは、保存の対象外です。コンポーザブル関数内の状態のみが保存されるため、 ViewModel の状態や Repositoty のキャッシュなどは、保存の対象外です。

より細かく言えば、NavController.navigate() を呼び出す方法を次のように変更できます。

```
// "destination_b" デスティネーションに遷移する前に
// "destination_a" デスティネーションより上に積まれた
// 全てのデスティネーションをバックスタックからポップアップします。
navController.navigate("destination_b") {
    popUpTo("destination_a")
}

// "destination_b" デスティネーションに遷移する前に
// "destination_a" デスティネーションを含み、それより上に積まれた
// 全てのデスティネーションをバックスタックからポップアップします。
navController.navigate("destination_b") {
    popUpTo("destination_a") { inclusive = true }
}

// 現時点のバックスタックのトップが "search" デスティネーションでなければ、
// "search" デスティネーションに遷移します。
// バックスタックのトップに複数のコピーが生成されるのを避けます。
navController.navigate("search") {
    launchSingleTop = true
}
```

NavController.navigate() にオプションを渡す方法の一般的な情報については、 [「オプションを使用したナビゲート」ガイド](../4.ナビゲーショングラフを使用する/2.オプションを使用して移動する.md/#compose-のオプション) ( [引用元はこちら](https://developer.android.com/guide/navigation/use-graph/navoptions?hl=ja&_gl=1*1a81re5*_up*MQ..*_ga*MTU0NjM2NDc1Mi4xNzMzNzkyNDc4*_ga_6HH9YJMN9M*MTczMzk2ODExNi40LjAuMTczMzk2ODExNi4wLjAuNzA3MDg4ODI5#options-compose) ) を参照してください。


## アクションを使用してポップする

アクションを使用してナビゲートする場合、必要に応じてバックスタックから追加の宛先をポップできます。たとえば、アプリに最初のログインフローがある場合、ユーザーがログインしたら、戻るボタンでユーザーがログインフローに戻らないように、ログイン関連の宛先をすべてバックスタックからポップする必要があります。
