- [ファイルの共有](#ファイルの共有)
  - [ファイル要求の受信](#ファイル要求の受信)
  - [ファイル選択アクティビティを作成する](#ファイル選択アクティビティを作成する)
    - [コードでファイル選択アクティビティを定義する](#コードでファイル選択アクティビティを定義する)
  - [ファイル選択への応答](#ファイル選択への応答)
  - [ファイルの権限を付与する](#ファイルの権限を付与する)
  - [要求元のアプリとファイルを共有する](#要求元のアプリとファイルを共有する)
  - [引用元資料](#引用元資料)


# ファイルの共有

[ファイルを共有できるようにアプリを設定](./2.ファイル共有の設定.md) したら、他のアプリからのファイル要求に応答できます。これらの要求に応答する一つの方法は、ファイルを共有する側のアプリに、他のアプリケーションから呼び出すことができる 「ファイル選択インターフェース」 を実装することです。これにより、クライアントアプリは、ユーザーが選択したファイルの `content://` URI を受け取ることができるようになります。

このレッスンでは、ファイルの要求に応答する 「ファイル選択アクティビティ」 をアプリ内に作成する方法を説明します。


## ファイル要求の受信

クライアントアプリからファイルの要求を受け取り、コンテンツ URI を返すには、アプリで 「ファイル選択アクティビティ」 を提供する必要があります。クライアントアプリは、 [ACTION_PICK](https://developer.android.com/reference/android/content/Intent?hl=ja#ACTION_PICK) アクションを含むインテントを使用して [startActivityForResult()](https://developer.android.com/reference/android/app/Activity?hl=ja#startActivityForResult(android.content.Intent,%20int)) を呼び出すことで、このアクティビティを開始します。クライアントアプリが startActivityForResult() を呼び出すと、アプリは、ユーザーが選択したファイルの `content://` URI を、クライアントアプリに返すことができます。

クライアントアプリで、ファイルの要求を実装する方法については、 [共有ファイルのリクエスト](./4.共有ファイルのリクエスト.md) のレッスンをご覧ください。


## ファイル選択アクティビティを作成する

ファイル選択アクティビティを設定するには、まずマニフェストでアクティビティを指定し、 [ACTION_PICK](https://developer.android.com/reference/android/content/Intent?hl=ja#ACTION_PICK) アクションとカテゴリ [CATEGORY_DEFAULT](https://developer.android.com/reference/android/content/Intent?hl=ja#CATEGORY_DEFAULT) および [CATEGORY_OPENABLE](https://developer.android.com/reference/android/content/Intent?hl=ja#CATEGORY_OPENABLE) に一致するインテントフィルターを指定します。また、アプリが他のアプリに提供するファイルの MIME タイプフィルターも追加します。次のスニペットは、新しいアクティビティとインテントフィルターを指定する方法を示しています。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application>
        <activity
            android:name=".FileSelectActivity"
            android:label="@File Selector" >
            <intent-filter>
                <action
                    android:name="android.intent.action.PICK"/>
                <category
                    android:name="android.intent.category.DEFAULT"/>
                <category
                    android:name="android.intent.category.OPENABLE"/>
                <data android:mimeType="text/plain"/>
                <data android:mimeType="image/*"/>
            </intent-filter>
        </activity>
    </application>
</manifest>
```


### コードでファイル選択アクティビティを定義する

次に、アプリの内部ストレージ内の files/images/ ディレクトリから利用可能なファイルを表示し、ユーザーが目的のファイルを選択できるようにする Activity サブクラスを定義します。次のスニペットは、このアクティビティを定義し、ユーザーの選択に応答する方法を示しています。

```kotlin
class MainActivity : Activity() {

    // このアプリの内部ストレージのルートパス
    private lateinit var privateRootDir: File
    // "images" サブディレクトリへのパス
    private lateinit var imagesDir: File
    // "images" サブディレクトリ内のファイルの配列
    private lateinit var imageFiles: Array<File>
    // imageFiles に一致するファイル名の配列
    private lateinit var imageFilenames: Array<String>

    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        // ファイルをリクエストするアプリへ送り返す Intent をセットアップする
        // 最終的に、この Intent の data に URI を格納して結果を返す。
        // この Intent は、 onActivityResult() の引数にセットされて、結果が渡される。
        // onActivityResult() は、現在非推奨なので、代わりに registerForActivityResult を使用すること。
        resultIntent = Intent("com.example.myapp.ACTION_RETURN_FILE")
        // 内部ストレージの files/ ディレクトリを取得する
        privateRootDir = filesDir
        // files/images サブディレクトリを取得する
        imagesDir = File(privateRootDir, "images")
        // images サブディレクトリ内のファイルを取得する
        imageFiles = imagesDir.listFiles()
        // 結果の初期値として null を設定しておく
        setResult(Activity.RESULT_CANCELED, null)
        /*
         * ListView 内で、ファイル名のリストを表示します。
         * 
         * imageFiles を反復処理し、各 File に対して
         * File.getAbsolutePath() を呼び出すことで、
         * 各ファイルのファイル名を取得し、 imageFilenames 配列に格納します。
         *  imageFilenames 配列を ListView に表示してください。
         */
        ...
    }
    ...
}
```


## ファイル選択への応答

ユーザーが共有ファイルを選択すると、アプリケーションは選択されたファイルを判別し、そのファイルのコンテンツ URI を生成する必要があります。アクティビティは使用可能なファイルのリストを [ListView](https://developer.android.com/reference/android/widget/ListView?hl=ja) に表示するため、ユーザーがファイル名をクリックすると、システムはメソッド [onItemClick()](https://developer.android.com/reference/android/widget/AdapterView.OnItemClickListener?hl=ja#onItemClick(android.widget.AdapterView%3C?%3E,%20android.view.View,%20int,%20long)) を呼び出し、選択されたファイルを取得できます。

インテントを使用してあるアプリから別のアプリにファイルの URI を送信する場合、他のアプリが読み取れる URI を取得するように注意する必要があります。Android 6.0 (API レベル 23) 以降を実行しているデバイスでこれを行うには、そのバージョンの Android での権限モデルの変更、特に [READ_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission?hl=ja#READ_EXTERNAL_STORAGE) が [危険な権限](https://developer.android.com/guide/topics/permissions/requesting?hl=ja#normal-dangerous) になり、受信側アプリに不足している可能性があるため、特別な注意が必要です。

これらの考慮事項を念頭に置いて、いくつかの欠点がある [Uri.fromFile()](https://developer.android.com/reference/android/net/Uri?hl=ja#fromFile(java.io.File)) の使用を避けることをお勧めします。このメソッドでは、次のことが行われます。

- プロファイル間でのファイル共有は許可されません。
- Android 4.4 (API レベル 19) 以下を実行しているデバイスでは、アプリに [WRITE_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission?hl=ja#WRITE_EXTERNAL_STORAGE) 権限が必要です。
- 受信側アプリに [READ_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission?hl=ja#READ_EXTERNAL_STORAGE) 権限が必要ですが、この権限がない重要な共有ターゲット (Gmail など) では失敗します。

[Uri.fromFile()](https://developer.android.com/reference/android/net/Uri?hl=ja#fromFile(java.io.File)) を使用する代わりに、 [URI 権限](#ファイルの権限を付与する) を使用して他のアプリに特定の URI へのアクセスを許可できます。 URI 権限は、 Uri.fromFile() によって生成された `file://` URI では機能しませんが、コンテンツプロバイダーに関連付けられた URI では機能します。 FileProvider API を使用すると、このような URI を作成できます。この方法は、外部ストレージではなく、インテントを送信するアプリのローカル ストレージにあるファイルでも機能します。

[onItemClick()](https://developer.android.com/reference/android/widget/AdapterView.OnItemClickListener?hl=ja#onItemClick(android.widget.AdapterView%3C?%3E,%20android.view.View,%20int,%20long)) で、選択したファイルのファイル名の [File](https://developer.android.com/reference/java/io/File?hl=ja) オブジェクトを取得し、 [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider?hl=ja) の [`<provider>`](https://developer.android.com/guide/topics/manifest/provider-element?hl=ja) 要素で指定した権限とともに、 [getUriForFile()](https://developer.android.com/reference/androidx/core/content/FileProvider?hl=ja#getUriForFile(android.content.Context,%20java.lang.String,%20java.io.File)) に引数として渡します。結果のコンテンツ URI には、権限、ファイルのディレクトリに対応するパスセグメント (XML メタデータで指定)、および拡張子を含むファイル名が含まれます。 FileProvider が XML メタデータに基づいてディレクトリをパスセグメントにマップする方法については、 [共有可能なディレクトリを指定する](./2.ファイル共有の設定.md/#共有可能なディレクトリを指定する) セクションで説明しています。

次のスニペットは、選択したファイルを検出し、そのコンテンツ URI を取得する方法を示しています。

```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        // ListView 内のファイルのクリックに応答するリスナーを定義します。
        fileListView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ ->
            /*
             * 選択されたファイル名の File を取得します。
             * ファイル名は imageFilename 配列に格納されていると想定します。
             */
            val requestFile = File(imageFilenames[position])
            /*
             * ほとんどのファイル関連メソッドは、 try-catch ブロック内で呼び出される必要があります。
             */
            // コンテンツ URI を取得するために FileProvider を使用します。
            val fileUri: Uri? = try {
                FileProvider.getUriForFile(
                    this@MainActivity,
                    "com.example.myapp.fileprovider",
                    requestFile
                )
            } catch (e: IllegalArgumentException) {
                Log.e(
                    "File Selector",
                    "The selected file can't be shared: $requestFile"
                )
                null
            }
            ...
        }
        ...
    }
```

[共有可能なディレクトリを指定する](./2.ファイル共有の設定.md/#共有可能なディレクトリを指定する) セクションで説明されているように、 `<paths>` 要素を含むメタデータファイルで指定したディレクトリ内にあるファイルに対してのみ、コンテンツ URI を生成できることに注意してください。指定していないパスにあるファイルに対して getUriForFile() を呼び出すと、 IllegalArgumentException が発生します。


## ファイルの権限を付与する

別のアプリと共有するファイルのコンテンツ URI がわかったので、クライアントアプリがファイルにアクセスできるようにする必要があります。アクセスを許可するには、コンテンツ URI を [Intent](https://developer.android.com/reference/android/content/Intent) に追加し、 Intent に権限フラグを設定することで、クライアントアプリに権限を付与します。付与する権限は一時的なもので、受信側アプリのタスクスタックが終了すると自動的に期限切れになります。

次のコードスニペットは、ファイルの読み取り権限を設定する方法を示しています。

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    // ListView 内のファイルのクリックに応答するリスナーの定義
    fileListView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ ->
        ...
        if (fileUri != null) {
            // コンテンツ URI に一時的な読み取り権限を付与する
            resultIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            ...
        }
        ...
    }
    ...
}
```

**注意** : [setFlags()](https://developer.android.com/reference/android/content/Intent#setFlags(int)) を呼び出すことが、一時的なアクセス権限を使用してファイルへのアクセスを安全に許可する唯一の方法です。ファイルのコンテンツ URI に対して [Context.grantUriPermission()](https://developer.android.com/reference/android/content/Context#grantUriPermission(java.lang.String,%20android.net.Uri,%20int)) メソッドを呼び出すことは避けてください。このメソッドは、 [Context.revokeUriPermission()](https://developer.android.com/reference/android/content/Context#revokeUriPermission(android.net.Uri,%20int)) を呼び出すことによってのみ取り消すことができるアクセスを許可するためです。

[Uri.fromFile()](https://developer.android.com/reference/android/net/Uri#fromFile(java.io.File)) を使用しないでください。これは、受信側のアプリに [READ_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission#READ_EXTERNAL_STORAGE) 権限を強制するため、ユーザー間で共有しようとしている場合にはまったく機能しません。また、Android 4.4 (API レベル 19) より前のバージョンでは、アプリに [WRITE_EXTERNAL_STORAGE](https://developer.android.com/reference/android/Manifest.permission#WRITE_EXTERNAL_STORAGE) が必要になります。また、Gmail アプリなどの非常に重要な共有ターゲットには READ_EXTERNAL_STORAGE がないため、この呼び出しは失敗します。代わりに、URI 権限を使用して、他のアプリに特定の URI へのアクセスを許可できます。 URI 権限は、 Uri.fromFile() によって生成される `file://` URI では機能しませんが、コンテンツプロバイダーに関連付けられた URI では機能します。このためだけに独自の権限を実装するのではなく、 [ファイル共有](./1.ファイル共有について.md) で説明されているように、 [FileProvider](https://developer.android.com/reference/androidx/core/content/FileProvider) を使用でき、また、使用するべきです。


## 要求元のアプリとファイルを共有する

ファイルを要求元のアプリと共有するには、コンテンツ URI と権限を含む [Intent](https://developer.android.com/reference/android/content/Intent) を [setResult()](https://developer.android.com/reference/android/app/Activity#setResult(int)) に渡します。定義した [Activity](https://developer.android.com/reference/android/app/Activity) が終了すると、システムはコンテンツ URI を含むインテントをクライアントアプリに送信します。次のコードスニペットは、その方法を示しています。

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    // Define a listener that responds to clicks on a file in the ListView
    fileListView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ ->
        ...
        if (fileUri != null) {
            ...
            //  URI と MIME タイプを結果用の Intent に格納します。
            resultIntent.setDataAndType(fileUri, contentResolver.getType(fileUri))
            // 呼び出し元の Activity に結果を返します。
            setResult(Activity.RESULT_OK, resultIntent)
        } else {
            resultIntent.setDataAndType(null, "")
            setResult(RESULT_CANCELED, resultIntent)
        }
    }
}
```

ユーザーがファイルを選択するとすぐにクライアントアプリに戻ることができるようにします。これを行う 1 つの方法は、チェックマークまたは [完了] ボタンを提供することです。ボタンの [android:onClick](https://developer.android.com/reference/android/view/View#attr_android:onClick) 属性を使用して、ボタンにメソッドを関連付けます。メソッドで、 [finish()](https://developer.android.com/reference/android/app/Activity#finish()) を呼び出します。例:

```kotlin
fun onDoneClick(v: View) {
    // このメソッドを完了ボタンに紐づけます。
    finish()
}
```

呼び出し先の Activity で、 finish() を呼び出さない場合は、ユーザーが明示的にスワイプバックするまで、呼び出し元の Activity に結果が返されることはありません。

追加の関連情報については、以下を参照してください:

- [コンテンツ URI の設計](../12.コンテンツプロバイダ/3.コンテンツプロバイダの作成.md/#コンテンツ-uri-を設計する)
- [コンテンツプロバイダーの権限の実装](../12.コンテンツプロバイダ/3.コンテンツプロバイダの作成.md/#コンテンツプロバイダの権限を実装する)
- [権限](https://developer.android.com/guide/topics/permissions/overview?hl=ja)
- [インテントとインテントフィルター](https://developer.android.com/guide/components/intents-filters?hl=ja)


## 引用元資料

- [ファイルの共有](https://developer.android.com/training/secure-file-sharing/share-file?hl=ja)




