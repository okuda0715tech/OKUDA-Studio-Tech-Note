- [カスタムドキュメントプロバイダを作成する](#カスタムドキュメントプロバイダを作成する)
  - [マニフェスト](#マニフェスト)
    - [Android 4.3 以前を実行しているデバイスのサポート](#android-43-以前を実行しているデバイスのサポート)
  - [コントラクト](#コントラクト)
  - [DocumentsProvider のサブクラスを作成する](#documentsprovider-のサブクラスを作成する)
    - [ルートを定義する](#ルートを定義する)
    - [プロバイダー内のドキュメントを一覧表示します](#プロバイダー内のドキュメントを一覧表示します)
    - [ドキュメント情報を取得します](#ドキュメント情報を取得します)
    - [ドキュメントを開く](#ドキュメントを開く)
    - [最近のドキュメントと検索のサポート](#最近のドキュメントと検索のサポート)
    - [ドキュメント作成のサポート](#ドキュメント作成のサポート)
    - [ドキュメント管理機能のサポート](#ドキュメント管理機能のサポート)
    - [仮想ファイルと代替ファイル形式のサポート](#仮想ファイルと代替ファイル形式のサポート)
  - [セキュリティ](#セキュリティ)
  - [引用元資料](#引用元資料)


# カスタムドキュメントプロバイダを作成する 

ファイルのストレージ サービス (クラウド保存サービスなど) を提供するアプリを開発している場合は、カスタム ドキュメント プロバイダーを作成することで、ストレージ アクセス フレームワーク (SAF) を通じてファイルを利用できるようになります。このページでは、カスタム ドキュメント プロバイダーの作成方法について説明します。

ストレージアクセスフレームワークの仕組みの詳細については、ストレージアクセスフレームワークの概要をご覧ください。


## マニフェスト

カスタムドキュメントプロバイダーを実装するには、アプリケーションのマニフェストに次の項目を追加します。

- API レベル 19 以上のターゲット
- カスタムストレージプロバイダーを宣言する `<provider>` 要素。
- 属性 android:name を DocumentsProvider サブクラスの名前 (パッケージ名を含むクラス名) に設定します。
  - `com.example.android.storageprovider.MyCloudProvider`
- android:authority 属性。パッケージ名 (この例では com.example.android.storageprovider) とコンテンツ プロバイダーのタイプ (ドキュメント) を組み合わせたもの。
- 属性 android:exported を "true" に設定します。他のアプリがそれを見ることができるように、プロバイダーをエクスポートする必要があります。
- 属性 android:grantUriPermissions を「true」に設定します。この設定により、システムは他のアプリにプロバイダーのコンテンツへのアクセスを許可できます。これらの他のアプリがプロバイダーのコンテンツへのアクセスを永続化する方法の詳細については、「永続化権限」を参照してください。
- MANAGE_DOCUMENTS 権限。デフォルトでは、プロバイダーはすべてのユーザーが利用できます。この権限を追加すると、プロバイダーがシステムに制限されます。この制限はセキュリティ上重要です。
- android.content.action.DOCUMENTS_PROVIDER アクションを含むインテントフィルター。これにより、システムがプロバイダーを検索するときにプロバイダーがピッカーに表示されます。

以下は、プロバイダーを含むサンプルマニフェストからの抜粋です。

```kotlin
<manifest... >
    ...
    <uses-sdk
        android:minSdkVersion="19"
        android:targetSdkVersion="19" />
        ....
        <provider
            android:name="com.example.android.storageprovider.MyCloudProvider"
            android:authorities="com.example.android.storageprovider.documents"
            android:grantUriPermissions="true"
            android:exported="true"
            android:permission="android.permission.MANAGE_DOCUMENTS">
            <intent-filter>
                <action android:name="android.content.action.DOCUMENTS_PROVIDER" />
            </intent-filter>
        </provider>
    </application>

</manifest>
```


### Android 4.3 以前を実行しているデバイスのサポート

ACTION_OPEN_DOCUMENT インテントは、Android 4.4 以降を実行しているデバイスでのみ使用できます。Android 4.3 以前を実行しているデバイスに対応するためにアプリケーションで ACTION_GET_CONTENT をサポートする場合は、Android 4.4 以降を実行しているデバイスのマニフェストで ACTION_GET_CONTENT インテント フィルターを無効にする必要があります。ドキュメント プロバイダーと ACTION_GET_CONTENT は相互に排他的であると考える必要があります。両方を同時にサポートすると、システム ピッカー UI にアプリが 2 回表示され、保存されたデータにアクセスする方法が 2 つ提供されます。これはユーザーにとって混乱を招きます。

Android バージョン 4.4 以降を実行しているデバイスで ACTION_GET_CONTENT インテント フィルターを無効にする推奨方法は次のとおりです。

```xml
<bool name="atMostJellyBeanMR2">true</bool>
```

res/values-v19/の下のbool.xmlリソースファイルに次の行を追加します。

```xml
<bool name="atMostJellyBeanMR2">false</bool>
```

バージョン 4.4 (API レベル 19) 以降で ACTION_GET_CONTENT インテント フィルターを無効にするには、アクティビティ エイリアスを追加します。例:

```xml
<!-- This activity alias is added so that GET_CONTENT intent-filter
     can be disabled for builds on API level 19 and higher. -->
<activity-alias android:name="com.android.example.app.MyPicker"
        android:targetActivity="com.android.example.app.MyActivity"
        ...
        android:enabled="@bool/atMostJellyBeanMR2">
    <intent-filter>
        <action android:name="android.intent.action.GET_CONTENT" />
        <category android:name="android.intent.category.OPENABLE" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:mimeType="image/*" />
        <data android:mimeType="video/*" />
    </intent-filter>
</activity-alias>
```


## コントラクト

通常、カスタム コンテンツ プロバイダーを作成する場合、タスクの 1 つは、コンテンツ プロバイダー開発者ガイドで説明されているように、コントラクト クラスの実装です。コントラクト クラスは、プロバイダーに関連する URI、列名、MIME タイプ、およびその他のメタデータの定数定義を含むパブリック最終クラスです。SA​​F はこれらのコントラクト クラスを提供するため、独自のコントラクト クラスを作成する必要はありません。

- DocumentsContract.Document
- DocumentsContract.Root

たとえば、ドキュメント プロバイダーに対してドキュメントまたはルートのクエリが実行されたときにカーソルで返される可能性のある列は次のとおりです。

```kotlin
private val DEFAULT_ROOT_PROJECTION: Array<String> = arrayOf(
        DocumentsContract.Root.COLUMN_ROOT_ID,
        DocumentsContract.Root.COLUMN_MIME_TYPES,
        DocumentsContract.Root.COLUMN_FLAGS,
        DocumentsContract.Root.COLUMN_ICON,
        DocumentsContract.Root.COLUMN_TITLE,
        DocumentsContract.Root.COLUMN_SUMMARY,
        DocumentsContract.Root.COLUMN_DOCUMENT_ID,
        DocumentsContract.Root.COLUMN_AVAILABLE_BYTES
)
private val DEFAULT_DOCUMENT_PROJECTION: Array<String> = arrayOf(
        DocumentsContract.Document.COLUMN_DOCUMENT_ID,
        DocumentsContract.Document.COLUMN_MIME_TYPE,
        DocumentsContract.Document.COLUMN_DISPLAY_NAME,
        DocumentsContract.Document.COLUMN_LAST_MODIFIED,
        DocumentsContract.Document.COLUMN_FLAGS,
        DocumentsContract.Document.COLUMN_SIZE
)
```

ルートのカーソルには、特定の必須列を含める必要があります。これらの列は次のとおりです:

- COLUMN_ROOT_ID
- COLUMN_ICON
- COLUMN_TITLE
- COLUMN_FLAGS
- COLUMN_DOCUMENT_ID

ドキュメントのカーソルには、次の必須列を含める必要があります:

- COLUMN_DOCUMENT_ID
- COLUMN_DISPLAY_NAME
- COLUMN_MIME_TYPE
- COLUMN_FLAGS
- COLUMN_SIZE
- COLUMN_LAST_MODIFIED


## DocumentsProvider のサブクラスを作成する

カスタムドキュメントプロバイダーを作成する次の手順は、抽象クラス DocumentsProvider をサブクラス化することです。少なくとも、次のメソッドを実装する必要があります:

- queryRoots()
- queryChildDocuments()
- queryDocument()
- openDocument()

実装が厳密に必要なメソッドはこれだけですが、他にも実装したいメソッドはたくさんあります。詳細については、DocumentsProvider を参照してください。


### ルートを定義する

queryRoots() の実装では、DocumentsContract.Root で定義された列を使用して、ドキュメント プロバイダーのすべてのルート ディレクトリを指す Cursor を返す必要があります。

次のスニペットでは、projection パラメーターは、呼び出し元が取得したい特定のフィールドを表します。スニペットは新しいカーソルを作成し、それに 1 つの行 (1 つのルート、ダウンロードやイメージなどの最上位ディレクトリ) を追加します。ほとんどのプロバイダーには 1 つのルートしかありません。複数のユーザー アカウントがある場合など、複数のルートがある場合があります。その場合は、カーソルに 2 行目を追加するだけです。

```kotliin
override fun queryRoots(projection: Array<out String>?): Cursor {
    // Use a MatrixCursor to build a cursor
    // with either the requested fields, or the default
    // projection if "projection" is null.
    val result = MatrixCursor(resolveRootProjection(projection))

    // If user is not logged in, return an empty root cursor.  This removes our
    // provider from the list entirely.
    if (!isUserLoggedIn()) {
        return result
    }

    // It's possible to have multiple roots (e.g. for multiple accounts in the
    // same app) -- just add multiple cursor rows.
    result.newRow().apply {
        add(DocumentsContract.Root.COLUMN_ROOT_ID, ROOT)

        // You can provide an optional summary, which helps distinguish roots
        // with the same title. You can also use this field for displaying an
        // user account name.
        add(DocumentsContract.Root.COLUMN_SUMMARY, context.getString(R.string.root_summary))

        // FLAG_SUPPORTS_CREATE means at least one directory under the root supports
        // creating documents. FLAG_SUPPORTS_RECENTS means your application's most
        // recently used documents will show up in the "Recents" category.
        // FLAG_SUPPORTS_SEARCH allows users to search all documents the application
        // shares.
        add(
            DocumentsContract.Root.COLUMN_FLAGS,
            DocumentsContract.Root.FLAG_SUPPORTS_CREATE or
                DocumentsContract.Root.FLAG_SUPPORTS_RECENTS or
                DocumentsContract.Root.FLAG_SUPPORTS_SEARCH
        )

        // COLUMN_TITLE is the root title (e.g. Gallery, Drive).
        add(DocumentsContract.Root.COLUMN_TITLE, context.getString(R.string.title))

        // This document id cannot change after it's shared.
        add(DocumentsContract.Root.COLUMN_DOCUMENT_ID, getDocIdForFile(baseDir))

        // The child MIME types are used to filter the roots and only present to the
        // user those roots that contain the desired type somewhere in their file hierarchy.
        add(DocumentsContract.Root.COLUMN_MIME_TYPES, getChildMimeTypes(baseDir))
        add(DocumentsContract.Root.COLUMN_AVAILABLE_BYTES, baseDir.freeSpace)
        add(DocumentsContract.Root.COLUMN_ICON, R.drawable.ic_launcher)
    }

    return result
}
```

ドキュメント プロバイダーが動的なルート セット (たとえば、切断される可能性のある USB デバイスや、ユーザーがサインアウトできるアカウント) に接続する場合は、次のコード スニペットに示すように、ContentResolver.notifyChange() メソッドを使用してドキュメント UI を更新し、それらの変更と同期を保つことができます。

```kotlin
val rootsUri: Uri = DocumentsContract.buildRootsUri(BuildConfig.DOCUMENTS_AUTHORITY)
context.contentResolver.notifyChange(rootsUri, null)
```


### プロバイダー内のドキュメントを一覧表示します

queryChildDocuments() の実装では、DocumentsContract.Document で定義された列を使用して、指定されたディレクトリ内のすべてのファイルを指すカーソルを返す必要があります。

このメソッドは、ユーザーがピッカー UI でルートを選択すると呼び出されます。このメソッドは、COLUMN_DOCUMENT_ID で指定されたドキュメント ID の子を取得します。その後、ユーザーがドキュメント プロバイダー内のサブディレクトリを選択するたびに、システムによってこのメソッドが呼び出されます。

このスニペットは、要求された列で新しいカーソルを作成し、親ディレクトリ内のすべての直下の子に関する情報をカーソルに追加します。子は、画像、別のディレクトリ、または任意のファイルになります。

```kotlin
override fun queryChildDocuments(
        parentDocumentId: String?,
        projection: Array<out String>?,
        sortOrder: String?
): Cursor {
    return MatrixCursor(resolveDocumentProjection(projection)).apply {
        val parent: File = getFileForDocId(parentDocumentId)
        parent.listFiles()
                .forEach { file ->
                    includeFile(this, null, file)
                }
    }
}
```


### ドキュメント情報を取得します

queryDocument() の実装では、DocumentsContract.Document で定義された列を使用して、指定されたファイルを指す Cursor を返す必要があります。

queryDocument() メソッドは、queryChildDocuments() で渡されたものと同じ情報を、特定のファイルに対して返します。

```kotlin
override fun queryDocument(documentId: String?, projection: Array<out String>?): Cursor {
    // Create a cursor with the requested projection, or the default projection.
    return MatrixCursor(resolveDocumentProjection(projection)).apply {
        includeFile(this, documentId, null)
    }
}
```

ドキュメント プロバイダーは、DocumentsProvider.openDocumentThumbnail() メソッドをオーバーライドし、サポートされているファイルに FLAG_SUPPORTS_THUMBNAIL フラグを追加することで、ドキュメントのサムネイルを提供することもできます。次のコード スニペットは、DocumentsProvider.openDocumentThumbnail() を実装する方法の例を示しています。

```kotlin
override fun openDocumentThumbnail(
        documentId: String?,
        sizeHint: Point?,
        signal: CancellationSignal?
): AssetFileDescriptor {
    val file = getThumbnailFileForDocId(documentId)
    val pfd = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
    return AssetFileDescriptor(pfd, 0, AssetFileDescriptor.UNKNOWN_LENGTH)
}
```

**注意** : ドキュメントプロバイダーは、 sizeHint パラメータで指定されたサイズの 2 倍を超えるサムネイル画像を返さないでください。


### ドキュメントを開く

指定されたファイルを表す ParcelFileDescriptor を返すには、openDocument() を実装する必要があります。他のアプリは、返された ParcelFileDescriptor を使用してデータをストリーミングできます。ユーザーがファイルを選択した後、システムはこのメソッドを呼び出し、クライアント アプリは openFileDescriptor() を呼び出してファイルへのアクセスを要求します。例:

```kotlin
override fun openDocument(
        documentId: String,
        mode: String,
        signal: CancellationSignal
): ParcelFileDescriptor {
    Log.v(TAG, "openDocument, mode: $mode")
    // It's OK to do network operations in this method to download the document,
    // as long as you periodically check the CancellationSignal. If you have an
    // extremely large file to transfer from the network, a better solution may
    // be pipes or sockets (see ParcelFileDescriptor for helper methods).

    val file: File = getFileForDocId(documentId)
    val accessMode: Int = ParcelFileDescriptor.parseMode(mode)

    val isWrite: Boolean = mode.contains("w")
    return if (isWrite) {
        val handler = Handler(context.mainLooper)
        // Attach a close listener if the document is opened in write mode.
        try {
            ParcelFileDescriptor.open(file, accessMode, handler) {
                // Update the file with the cloud server. The client is done writing.
                Log.i(TAG, "A file with id $documentId has been closed! Time to update the server.")
            }
        } catch (e: IOException) {
            throw FileNotFoundException(
                    "Failed to open document with id $documentId and mode $mode"
            )
        }
    } else {
        ParcelFileDescriptor.open(file, accessMode)
    }
}
```

ドキュメント プロバイダーがファイルをストリーミングしたり、複雑なデータ構造を処理したりする場合は、createReliablePipe() メソッドまたは createReliableSocketPair() メソッドの実装を検討してください。これらのメソッドを使用すると、ParcelFileDescriptor オブジェクトのペアを作成できます。このペアでは、1 つを返して、もう 1 つを ParcelFileDescriptor.AutoCloseOutputStream または ParcelFileDescriptor.AutoCloseInputStream 経由で送信できます。


### 最近のドキュメントと検索のサポート

queryRecentDocuments() メソッドをオーバーライドして FLAG_SUPPORTS_RECENTS を返すことで、ドキュメント プロバイダーのルートで最近変更されたドキュメントのリストを提供できます。次のコード スニペットは、queryRecentDocuments() メソッドを実装する方法の例を示しています。

```kotlin
override fun queryRecentDocuments(rootId: String?, projection: Array<out String>?): Cursor {
    // This example implementation walks a
    // local file structure to find the most recently
    // modified files.  Other implementations might
    // include making a network call to query a
    // server.

    // Create a cursor with the requested projection, or the default projection.
    val result = MatrixCursor(resolveDocumentProjection(projection))

    val parent: File = getFileForDocId(rootId)

    // Create a queue to store the most recent documents,
    // which orders by last modified.
    val lastModifiedFiles = PriorityQueue(
            5,
            Comparator<File> { i, j ->
                Long.compare(i.lastModified(), j.lastModified())
            }
    )

    // Iterate through all files and directories
    // in the file structure under the root.  If
    // the file is more recent than the least
    // recently modified, add it to the queue,
    // limiting the number of results.
    val pending : MutableList<File> = mutableListOf()

    // Start by adding the parent to the list of files to be processed
    pending.add(parent)

    // Do while we still have unexamined files
    while (pending.isNotEmpty()) {
        // Take a file from the list of unprocessed files
        val file: File = pending.removeAt(0)
        if (file.isDirectory) {
            // If it's a directory, add all its children to the unprocessed list
            pending += file.listFiles()
        } else {
            // If it's a file, add it to the ordered queue.
            lastModifiedFiles.add(file)
        }
    }

    // Add the most recent files to the cursor,
    // not exceeding the max number of results.
    for (i in 0 until Math.min(MAX_LAST_MODIFIED + 1, lastModifiedFiles.size)) {
        val file: File = lastModifiedFiles.remove()
        includeFile(result, null, file)
    }
    return result
}
```

上記のスニペットの完全なコードは、StorageProvider コード サンプルをダウンロードすることで入手できます。


### ドキュメント作成のサポート

クライアントアプリがドキュメント プロバイダー内でファイルを作成できるようにすることができます。クライアント アプリが ACTION_CREATE_DOCUMENT インテントを送信すると、ドキュメント プロバイダーは、そのクライアント アプリがドキュメント プロバイダー内で新しいドキュメントを作成できるようにすることができます。

ドキュメント作成をサポートするには、ルートに FLAG_SUPPORTS_CREATE フラグが必要です。新しいファイルの作成を許可するディレクトリには、FLAG_DIR_SUPPORTS_CREATE フラグが必要です。

ドキュメント プロバイダーは、createDocument() メソッドも実装する必要があります。ユーザーがドキュメント プロバイダー内でディレクトリを選択して新しいファイルを保存すると、ドキュメント プロバイダーは createDocument() の呼び出しを受け取ります。createDocument() メソッドの実装内で、ファイルの新しい COLUMN_DOCUMENT_ID を返します。クライアント アプリはその ID を使用してファイルのハンドルを取得し、最終的に openDocument() を呼び出して新しいファイルに書き込むことができます。

次のコード スニペットは、ドキュメント プロバイダー内で新しいファイルを作成する方法を示しています。

```kotlin
override fun createDocument(documentId: String?, mimeType: String?, displayName: String?): String {
    val parent: File = getFileForDocId(documentId)
    val file: File = try {
        File(parent.path, displayName).apply {
            createNewFile()
            setWritable(true)
            setReadable(true)
        }
    } catch (e: IOException) {
        throw FileNotFoundException(
                "Failed to create document with name $displayName and documentId $documentId"
        )
    }

    return getDocIdForFile(file)
}
```

上記のスニペットの完全なコードは、StorageProvider コード サンプルをダウンロードすることで入手できます。


### ドキュメント管理機能のサポート

ドキュメントプロバイダーは、ファイルを開く、作成する、表示するだけでなく、クライアントアプリにファイルの名前変更、コピー、移動、削除の機能も提供できます。ドキュメントプロバイダーにドキュメント管理機能を追加するには、ドキュメントの COLUMN_FLAGS 列にフラグを追加して、サポートされている機能を示します。また、 DocumentsProvider クラスの対応するメソッドを実装する必要もあります。

次の表は、ドキュメントプロバイダーが特定の機能を公開するために実装する必要がある COLUMN_FLAGS フラグと DocumentsProvider メソッドを示しています。

| 機能                                                                   | フラグ               | メソッド         |
| ---------------------------------------------------------------------- | -------------------- | ---------------- |
| ファイルを削除する                                                     | FLAG_SUPPORTS_DELETE | deleteDocument() |
| ファイルの名前を変更する                                               | FLAG_SUPPORTS_RENAME | renameDocument() |
| ドキュメントプロバイダー内の新しい親ディレクトリにファイルをコピーする | FLAG_SUPPORTS_COPY   | copyDocument()   |
| ドキュメントプロバイダー内のディレクトリ間でファイルを移動する         | FLAG_SUPPORTS_MOVE   | moveDocument()   |
| 親ディレクトリからファイルを削除する                                   | FLAG_SUPPORTS_REMOVE | removeDocument() |


### 仮想ファイルと代替ファイル形式のサポート

Android 7.0 (API レベル 24) で導入された機能である仮想ファイルを使用すると、ドキュメント プロバイダーは、直接バイトコード表現を持たないファイルへの表示アクセスを提供できます。他のアプリが仮想ファイルを表示できるようにするには、ドキュメント プロバイダーが仮想ファイルの代替の開くことができるファイル表現を生成する必要があります。

たとえば、ドキュメント プロバイダーに、他のアプリが直接開くことができないファイル形式 (基本的には仮想ファイル) が含まれているとします。クライアント アプリが CATEGORY_OPENABLE カテゴリなしで ACTION_VIEW インテントを送信すると、ユーザーはドキュメント プロバイダー内でこれらの仮想ファイルを選択して表示できます。ドキュメント プロバイダーは、画像などの異なる (ただし開くことができる) ファイル形式で仮想ファイルを返します。クライアント アプリは、ユーザーが表示できるように仮想ファイルを開くことができます。

プロバイダー内のドキュメントが仮想であることを宣言するには、queryDocument() メソッドによって返されるファイルに FLAG_VIRTUAL_DOCUMENT フラグを追加する必要があります。このフラグは、ファイルに直接バイトコード表現がなく、直接開くことができないことをクライアント アプリに通知します。

ドキュメント プロバイダー内のファイルが仮想であると宣言する場合は、画像や PDF などの別の MIME タイプでそのファイルを利用できるようにすることを強くお勧めします。ドキュメント プロバイダーは、getDocumentStreamTypes() メソッドをオーバーライドして、仮想ファイルの表示をサポートする代替 MIME タイプを宣言します。クライアント アプリが getStreamTypes(android.net.Uri, java.lang.String) メソッドを呼び出すと、システムはドキュメント プロバイダーの getDocumentStreamTypes() メソッドを呼び出します。次に、getDocumentStreamTypes() メソッドは、ドキュメント プロバイダーがファイルに対してサポートする代替 MIME タイプの配列を返します。

クライアントがドキュメント プロバイダーが表示可能なファイル形式でドキュメントを生成できると判断すると、クライアント アプリは openTypedAssetFileDescriptor() メソッドを呼び出します。このメソッドは、内部でドキュメント プロバイダーの openTypedDocument() メソッドを呼び出します。ドキュメント プロバイダーは、要求されたファイル形式でファイルをクライアント アプリに返します。

次のコード スニペットは、getDocumentStreamTypes() メソッドと openTypedDocument() メソッドの簡単な実装を示しています。

```kotlin
var SUPPORTED_MIME_TYPES : Array<String> = arrayOf("image/png", "image/jpg")
override fun openTypedDocument(
        documentId: String?,
        mimeTypeFilter: String,
        opts: Bundle?,
        signal: CancellationSignal?
): AssetFileDescriptor? {
    return try {
        // Determine which supported MIME type the client app requested.
        when(mimeTypeFilter) {
            "image/jpg" -> openJpgDocument(documentId)
            "image/png", "image/*", "*/*" -> openPngDocument(documentId)
            else -> throw IllegalArgumentException("Invalid mimeTypeFilter $mimeTypeFilter")
        }
    } catch (ex: Exception) {
        Log.e(TAG, ex.message)
        null
    }
}

override fun getDocumentStreamTypes(documentId: String, mimeTypeFilter: String): Array<String> {
    return when (mimeTypeFilter) {
        "*/*", "image/*" -> {
            // Return all supported MIME types if the client app
            // passes in '*/*' or 'image/*'.
            SUPPORTED_MIME_TYPES
        }
        else -> {
            // Filter the list of supported mime types to find a match.
            SUPPORTED_MIME_TYPES.filter { it == mimeTypeFilter }.toTypedArray()
        }
    }
}
```


## セキュリティ

ドキュメント プロバイダーがパスワードで保護されたクラウド ストレージ サービスであり、ファイルの共有を開始する前にユーザーがログインしていることを確認したいとします。ユーザーがログインしていない場合、アプリは何をすべきでしょうか。解決策は、queryRoots() の実装でルートを 0 個返すことです。つまり、ルート カーソルは空です。

```kotlin
override fun queryRoots(projection: Array<out String>): Cursor {
...
    // If user is not logged in, return an empty root cursor.  This removes our
    // provider from the list entirely.
    if (!isUserLoggedIn()) {
        return result
    }
```

もう一つのステップは、getContentResolver().notifyChange() を呼び出すことです。DocumentsContract を覚えていますか? この URI を作成するために使用しています。次のスニペットは、ユーザーのログイン ステータスが変わるたびに、システムにドキュメント プロバイダーのルートを照会するように指示します。ユーザーがログインしていない場合、queryRoots() を呼び出すと、上記のように空のカーソルが返されます。これにより、プロバイダーのドキュメントは、ユーザーがプロバイダーにログインしている場合にのみ利用可能になります。

```kotlin
private fun onLoginButtonClick() {
    loginOrLogout()
    getContentResolver().notifyChange(
        DocumentsContract.buildRootsUri(AUTHORITY),
        null
    )
}
```

このページに関連するサンプルコードについては、以下を参照してください:

- StorageProvider
- StorageClient

このページに関連するビデオについては、以下を参照してください:

- DevBytes: Android 4.4 ストレージアクセスフレームワーク: プロバイダー
- ストレージアクセスフレームワーク: DocumentsProvider の構築
- ストレージアクセスフレームワークの仮想ファイル

その他の関連情報については、以下を参照してください:

- DocumentsProvider の構築
- ストレージアクセスフレームワークを使用してファイルを開く
- コンテンツプロバイダーの基本


## 引用元資料

- [カスタムドキュメントプロバイダを作成する](https://developer.android.com/guide/topics/providers/create-document-provider?hl=ja)


