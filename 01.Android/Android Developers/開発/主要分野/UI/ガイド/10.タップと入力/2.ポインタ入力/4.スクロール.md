- [スクロール](#スクロール)
  - [Scroll 修飾子](#scroll-修飾子)
  - [Scrollable 修飾子](#scrollable-修飾子)
  - [ネストされたスクロール](#ネストされたスクロール)
    - [自動的に適用されるネストスクロール](#自動的に適用されるネストスクロール)
    - [nestedScroll 修飾子の使用](#nestedscroll-修飾子の使用)
    - [ネストされたスクロールサイクル](#ネストされたスクロールサイクル)
      - [ネストされたスクロールサイクルのフェーズ](#ネストされたスクロールサイクルのフェーズ)
      - [ネストされたスクロールサイクルに参加する](#ネストされたスクロールサイクルに参加する)
  - [ネストされたスクロールの相互運用](#ネストされたスクロールの相互運用)
    - [子 ComposeView を含む、協力的な親 View](#子-composeview-を含む協力的な親-view)
    - [子 AndroidView を含む親コンポーザブル](#子-androidview-を含む親コンポーザブル)
    - [子 ComposeView を持つ非協力的な親 View](#子-composeview-を持つ非協力的な親-view)


# スクロール

注: アイテムのリストを表示する場合は、これらの API の代わりに LazyColumn と LazyRow の使用を検討してください。LazyColumn と LazyRow はスクロール機能を備えており、必要なときにのみアイテムを作成するため、スクロール修飾子よりもはるかに効率的です。詳細については、 [リストとグリッドのドキュメント](../../4.マテリアルコンポーネント/19.リストとグリッド.md) を参照してください。


## Scroll 修飾子

[verticalScroll](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*188d527*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)) および [horizo​​nScroll](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*188d527*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)) 修飾子は、コンテンツの境界が最大サイズ制約より大きい場合に、ユーザーが要素をスクロールできるようにする最も簡単な方法を提供します。verticalScroll および horizo​​nScroll 修飾子を使用すると、コンテンツを移動またはオフセットする必要がありません。

```kotlin
@Composable
private fun ScrollBoxes() {
    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .verticalScroll(rememberScrollState())
    ) {
        repeat(10) {
            Text("Item $it", modifier = Modifier.padding(2.dp))
        }
    }
}
```

<img src="./画像/verticalScroll 修飾子の最も簡単な例.gif" width="200">

ScrollState を使用すると、スクロールの位置を変更したり、現在の状態を取得したりできます。デフォルトのパラメータで作成するには、rememberScrollState() を使用します。

```kotlin
@Composable
private fun ScrollBoxesSmooth() {
    val state = rememberScrollState()

    // 最初のコンポーズ時にスムーズに 100px にスクロールします。
    LaunchedEffect(Unit) { state.animateScrollTo(100) }

    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .padding(horizontal = 8.dp)
            .verticalScroll(state)
    ) {
        repeat(10) {
            Text("Item $it", modifier = Modifier.padding(2.dp))
        }
    }
}
```


## Scrollable 修飾子

[scrollable](https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary?_gl=1*133zz2r*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource)) 修飾子は、スクロール ジェスチャを検出して差分をキャプチャしますが、そのコンテンツを自動的にオフセットしないという点で、scroll 修飾子とは異なります。これは、この修飾子が正しく機能するために必要な [ScrollableState](https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/ScrollableState?_gl=1*133zz2r*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..) を通じてユーザーに委任されます。

ScrollableState を構築するときは、各スクロール ステップ (ジェスチャ入力、スムーズ スクロール、またはフリングによる) で呼び出される、ピクセル単位の差分を持つ、consumeScrollDelta 関数を提供する必要があります。この関数は、スクロール可能修飾子を持つネストされた要素がある場合にイベントが適切に伝播されるように、消費されたスクロール距離を返す必要があります。

注: scrollable 修飾子は、適用先の要素のレイアウトには影響しません。つまり、要素レイアウトまたはその子に対する変更は、ScrollableState によって提供される差分を通じて処理する必要があります。また、scrollable は子のレイアウトについてこだわりがないため、スクロール差分を伝播するために子を測定する必要がないことにも注意してください。

次のスニペットはジェスチャを検出し、オフセットの数値を表示しますが、要素をオフセットしません。

```kotlin
@Composable
private fun ScrollableSample() {
    var offset by remember { mutableStateOf(0f) }
    Box(
        Modifier
            .size(150.dp)
            .scrollable(
                orientation = Orientation.Vertical,
                // state パラメータは、スクロール差分をどのように消費するかを定義します。
                state = rememberScrollableState { delta ->
                    offset += delta
                    delta
                }
            )
            .background(Color.LightGray),
        contentAlignment = Alignment.Center
    ) {
        Text(offset.toString())
    }
}
```

<img src="./画像/scrollable の使用例.gif" width="200">


## ネストされたスクロール

ネストされたスクロールとは、複数のスクロール コンポーネントが互いに連携して、単一のスクロール ジェスチャに反応し、スクロール デルタ (変更) を伝達するシステムです。

ネストされたスクロール システムでは、スクロール可能で階層的にリンクされている (多くの場合、同じ親を共有することによって) コンポーネント間の調整が可能です。このシステムはスクロール コンテナーをリンクし、伝播および共有されているスクロール デルタとのやり取りを可能にします。

Compose では、コンポーザブル間のネストされたスクロールを処理する複数の方法が用意されています。ネストされたスクロールの一般的な例は、別のリスト内のリストであり、より複雑なケースは、折りたたまれるツールバーです。


###  自動的に適用されるネストスクロール

単純なネストされたスクロールでは、ユーザー側での操作は必要ありません。スクロール アクションを開始するジェスチャーは、子から親に自動的に伝播されます。そのため、 **子がそれ以上スクロールできない場合、ジェスチャーは親要素によって処理されます。**

自動ネストされたスクロールは、Compose のコンポーネントと修飾子の一部 ( [verticalScroll](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*h21odv*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)) 、 [horizo​​ntalScroll](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*h21odv*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)) 、 [scrollable](https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary?_gl=1*z2wdf6*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource)) 、 Lazy API 、 TextField ) によってサポートされ、すぐに使用できます。つまり、ユーザーがネストされたコンポーネントの内部の子をスクロールすると、前の修飾子によって、ネストされたスクロールをサポートする親にスクロール デルタが伝播されます。

次の例は、 [verticalScroll](https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary?_gl=1*z2wdf6*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)) 修飾子が適用されたコンテナー内の要素に verticalScroll 修飾子が適用されていることを示しています。このコンテナーにも verticalScroll 修飾子が適用されています。

```kotlin
@Composable
private fun AutomaticNestedScroll() {
    val gradient = Brush.verticalGradient(0f to Color.Gray, 1000f to Color.White)
    Box(
        modifier = Modifier
            .background(Color.LightGray)
            .verticalScroll(rememberScrollState())
            .padding(32.dp)
    ) {
        Column {
            repeat(6) {
                Box(
                    modifier = Modifier
                        .height(128.dp)
                        .verticalScroll(rememberScrollState())
                ) {
                    Text(
                        "Scroll here",
                        modifier = Modifier
                            .border(12.dp, Color.DarkGray)
                            .background(brush = gradient)
                            .padding(24.dp)
                            .height(150.dp)
                    )
                }
            }
        }
    }
}
```

<img src="./画像" width="400">


### nestedScroll 修飾子の使用

複数の要素間で高度な協調スクロールを作成する必要がある場合、 [nestedScroll](https://developer.android.com/reference/kotlin/androidx/compose/ui/input/nestedscroll/package-summary?_gl=1*kt224g*_up*MQ..*_ga*MjA3NTExNzk4Ny4xNzI3MTczOTI5*_ga_6HH9YJMN9M*MTcyNzMxNjg0OC40LjAuMTcyNzMxNjg0OC4wLjAuMTQ3OTE3MjcwMg..#(androidx.compose.ui.Modifier).nestedScroll(androidx.compose.ui.input.nestedscroll.NestedScrollConnection,androidx.compose.ui.input.nestedscroll.NestedScrollDispatcher)) 修飾子を使用すると、ネストされたスクロール階層を定義することで柔軟性が向上します。前のセクションで説明したように、一部のコンポーネントにはネストされたスクロールのサポートが組み込まれています。ただし、Box や Column など、自動的にスクロールできないコンポーザブルの場合、そのようなコンポーネントのスクロール デルタはネストされたスクロール システムに伝播せず、デルタは NestedScrollConnection にも親コンポーネントにも到達しません。これを解決するには、nestedScroll を使用して、カスタム コンポーネントを含む他のコンポーネントにそのようなサポートを付与します。


### ネストされたスクロールサイクル

ネストされたスクロール サイクルとは、スクロール可能なコンポーネントと修飾子、または nestedScroll などを使用して、ネストされたスクロール システムの一部であるすべてのコンポーネント (またはノード) を介して階層ツリーの上下にディスパッチされるスクロール デルタのフローです。


#### ネストされたスクロールサイクルのフェーズ
#### ネストされたスクロールサイクルに参加する
## ネストされたスクロールの相互運用
### 子 ComposeView を含む、協力的な親 View
### 子 AndroidView を含む親コンポーザブル
### 子 ComposeView を持つ非協力的な親 View


