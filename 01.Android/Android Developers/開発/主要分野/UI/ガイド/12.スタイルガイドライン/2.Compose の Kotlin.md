- [Jetpack Compose の Kotlin](#jetpack-compose-の-kotlin)
  - [デフォルトの引数](#デフォルトの引数)
  - [高階関数とラムダ式](#高階関数とラムダ式)
    - [末尾のラムダ](#末尾のラムダ)
  - [スコープとレシーバー](#スコープとレシーバー)
  - [委譲プロパティ](#委譲プロパティ)
  - [データクラスの分解](#データクラスの分解)
  - [シングルトンオブジェクト](#シングルトンオブジェクト)
  - [タイプセーフビルダーと DSL](#タイプセーフビルダーと-dsl)
  - [Kotlin コルーチン](#kotlin-コルーチン)


# Jetpack Compose の Kotlin

## デフォルトの引数
## 高階関数とラムダ式
### 末尾のラムダ
## スコープとレシーバー

一部のメソッドとプロパティは、特定のスコープでしか利用できません。スコープを制限することで、必要な機能を提供し、適切でない機能を誤って使用しないようにできます。

Compose で使用されている例を考えてみましょう。Row レイアウト コンポーザブルを呼び出すと、コンテンツ ラムダが自動的に RowScope 内で呼び出されます。これにより、Row は Row 内でのみ有効な機能を公開できます。下記の例は、Row が align 修飾子の Row 固有の値をどのように公開しているかを示しています。

```kotlin
Row {
    Text(
        text = "Hello world",
        // この Text は RowScope 内にあるため、
        // Alignment.CenterVertically にはアクセスできますが、
        // ColumnScope で使用できる Alignment.CenterHorizo​​ntally には
        //アクセスできません。
        modifier = Modifier.align(Alignment.CenterVertically)
    )
}
```

API によっては、レシーバー スコープで呼び出されるラムダを受け入れるものもあります。こうしたラムダは、パラメータ宣言に基づき、他の場所で定義されているプロパティと関数にアクセスできます。

```kotlin
Box(
    modifier = Modifier.drawBehind {
        // このメソッドは、DrawScope.() -> Unit 型のラムダを受け入れるため、
        // このラムダでは、 `drawRectangle` 関数など、
        // DrawScope で使用できるプロパティと関数にアクセスできます。
        drawRect(
            /*...*/
            /* ...
        )
    }
)
```

詳細については、Kotlin ドキュメントの [レシーバー付き関数リテラル](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) をご覧ください。



## 委譲プロパティ

Kotlin は、委譲プロパティをサポートしています。こうしたプロパティはあたかもフィールドであるかのように呼び出されますが、その値は、式を評価することで動的に決定されます。こうしたプロパティは、by 構文を使用することで認識できます。

```kotlin
class DelegatingClass {
    var name: String by nameGetterFunction()

    // ...
}
```

他のコードでは、次のようなコードを使用してプロパティにアクセスできます。

```kotlin
val myDC = DelegatingClass()
println("The name property is: " + myDC.name)
```

println() が実行されると、nameGetterFunction() が呼び出され、文字列の値が返されます。

委譲プロパティは、状態に基づくプロパティを扱う場合に特に有用です。

```kotlin
var showDialog by remember { mutableStateOf(false) }

// プロパティを更新すると、状態の更新を自動的にトリガーしてくれます。
showDialog = true
```

注 : [状態と Jetpack Compose のドキュメント](../2.UIアーキテクチャ/4.状態の管理/1.概要.md) で remember、mutableStateOfについて詳しく説明します。


## データクラスの分解
## シングルトンオブジェクト

Kotlin を使用すると、シングルトン（インスタンスを常に 1 つだけ持つクラス）を簡単に宣言できます。シングルトンは object キーワードで宣言されます。Compose では、このようなオブジェクトをよく利用します。たとえば、 [MaterialTheme](https://developer.android.com/reference/kotlin/androidx/compose/material/MaterialTheme?hl=ja&_gl=1*guirkf*_up*MQ..*_ga*MjExMDE2NTk5NS4xNzI3MzM1MzI5*_ga_6HH9YJMN9M*MTcyNzQxNTU3Mi40LjAuMTcyNzQxNTU3Mi4wLjAuMTg3MDIxNjI5OA..) はシングルトン オブジェクトとして定義されます。MaterialTheme.colors、shapes、typography の各プロパティには、現在のテーマの値が含まれています。


## タイプセーフビルダーと DSL
## Kotlin コルーチン

コルーチンを使用すると、Kotlin 言語レベルで非同期プログラミングが可能になります。コルーチンは、スレッドをブロックせずに実行を停止できます。レスポンシブ UI は本質的に非同期なものですが、Jetpack Compose は、コールバックの代わりに API レベルでコルーチンを使用することによりこれを実現しています。

Jetpack Compose には、UI レイヤ内でコルーチンを安全に使用するための API が用意されています。rememberCoroutineScope 関数から返される CoroutineScope を使用することで、イベント ハンドラ内でコルーチンを作成し、Compose の suspend API を呼び出せます。次の例では、ScrollState の animateScrollTo を使用しています。

```kotlin
// Create a CoroutineScope that follows this composable's lifecycle
val composableScope = rememberCoroutineScope()
Button(
    // ...
    onClick = {
        // Create a new coroutine that scrolls to the top of the list
        // and call the ViewModel to load data
        composableScope.launch {
            scrollState.animateScrollTo(0) // This is a suspend function
            viewModel.loadData()
        }
    }
) { /* ... */ }
```

コルーチンは、デフォルトでコードブロックを順次実行します。suspend 関数を呼び出している実行中のコルーチンは、suspend 関数が戻るまでその実行を停止します。これは、suspend 関数が実行を別の CoroutineDispatcher に移動した場合にも当てはまります。上記の例では、loadData は suspend 関数 animateScrollTo が返されるまで実行されません。

コードを同時に実行するには、新しいコルーチンを作成する必要があります。上記の例で、画面の一番上までスクロールしながら viewModel からデータを読み込むには、2 つのコルーチンが必要です。

```kotlin
// Create a CoroutineScope that follows this composable's lifecycle
val composableScope = rememberCoroutineScope()
Button( // ...
    onClick = {
        // Scroll to the top and load data in parallel by creating a new
        // coroutine per independent work to do
        composableScope.launch {
            scrollState.animateScrollTo(0)
        }
        composableScope.launch {
            viewModel.loadData()
        }
    }
) { /* ... */ }
```

コルーチンを使用すると、非同期 API を簡単に組み合わせることができます。次の例では、pointerInput 修飾子とアニメーション API を組み合わせて、ユーザーが画面をタップしたときに、要素の位置にアニメーション効果を表示します。

```kotlin
@Composable
fun MoveBoxWhereTapped() {
    // Creates an `Animatable` to animate Offset and `remember` it.
    val animatedOffset = remember {
        Animatable(Offset(0f, 0f), Offset.VectorConverter)
    }

    Box(
        // The pointerInput modifier takes a suspend block of code
        Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                // Create a new CoroutineScope to be able to create new
                // coroutines inside a suspend function
                coroutineScope {
                    while (true) {
                        // Wait for the user to tap on the screen
                        val offset = awaitPointerEventScope {
                            awaitFirstDown().position
                        }
                        // Launch a new coroutine to asynchronously animate to
                        // where the user tapped on the screen
                        launch {
                            // Animate to the pressed position
                            animatedOffset.animateTo(offset)
                        }
                    }
                }
            }
    ) {
        Text("Tap anywhere", Modifier.align(Alignment.Center))
        Box(
            Modifier
                .offset {
                    // Use the animated offset as the offset of this Box
                    IntOffset(
                        animatedOffset.value.x.roundToInt(),
                        animatedOffset.value.y.roundToInt()
                    )
                }
                .size(40.dp)
                .background(Color(0xff3c1361), CircleShape)
        )
    }
```

コルーチンについて詳しくは、 [Android での Kotlin コルーチンガイド](https://developer.android.com/kotlin/coroutines?hl=ja&_gl=1*4m1eqj*_up*MQ..*_ga*MjExMDE2NTk5NS4xNzI3MzM1MzI5*_ga_6HH9YJMN9M*MTcyNzQxNTU3Mi40LjAuMTcyNzQxNTU3Mi4wLjAuMTg3MDIxNjI5OA..) をご覧ください。

