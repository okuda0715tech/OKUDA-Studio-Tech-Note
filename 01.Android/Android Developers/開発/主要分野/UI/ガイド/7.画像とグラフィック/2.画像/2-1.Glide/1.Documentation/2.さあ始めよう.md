- [さあ始めよう](#さあ始めよう)
  - [基本的な使用方法](#基本的な使用方法)
  - [リクエストのカスタマイズ](#リクエストのカスタマイズ)
  - [ListView と RecyclerView](#listview-と-recyclerview)
  - [ビュー以外のターゲット](#ビュー以外のターゲット)
  - [バックグラウンド スレッド](#バックグラウンド-スレッド)


# さあ始めよう

## 基本的な使用方法

Glide で画像を読み込むのは簡単で、多くの場合、1 行だけが必要です:

```java
Glide.with(fragment)
    .load(myUrl)
    .into(imageView);
```

不要になった読み込みをキャンセルするのも簡単です:

```java
Glide.with(fragment).clear(imageView);
```

不要になった読み込みをクリアすることは良い習慣ですが、そうする必要はありません。実際、Glide.with() に渡した Activity または Fragment が破棄されると、Glide は自動的に読み込みをクリアし、読み込みで使用されたリソースをリサイクルします。


## リクエストのカスタマイズ

Glide には、変換、遷移、キャッシュ オプションなど、個々のリクエストに適用できるさまざまなオプションがあります。

デフォルトのオプションは、リクエストに直接適用できます:

```java
Glide.with(fragment)
    .load(myUrl)
    .placeholder(placeholder) // オプション 1
    .fitCenter() // オプション 2
    .into(imageView);
```

オプションは、RequestOptions クラスを使用してリクエスト間で共有できます。

```java
RequestOptions sharedOptions = 
    new RequestOptions()
        .placeholder(placeholder)
        .fitCenter();

Glide.with(fragment)
    .load(myUrl)
    .apply(sharedOptions)
    .into(imageView1);

Glide.with(fragment)
    .load(myUrl)
    .apply(sharedOptions)
    .into(imageView2);
```

Glide の API は、高度なユースケース向けに [Glide が生成した API](https://bumptech.github.io/glide/doc/generatedapi.html) を使用してカスタム オプションを含めるようにさらに拡張できます。


## ListView と RecyclerView

ListView または RecyclerView に画像を読み込む場合、単一の View に読み込む場合と同じ読み込み行が使用されます。Glide は View の再利用とリクエストのキャンセルを自動的に処理します。

```java
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    String url = urls.get(position);
    Glide.with(fragment)
        .load(url)
        .into(holder.imageView);
}
```

URL を null チェックする必要もありません。URL が null の場合、Glide はビューをクリアするか、指定したプレースホルダー Drawable またはフォールバック Drawable を設定します。

Glide の唯一の要件は、以前の位置で読み込みを開始した再利用可能なビューまたはターゲットに新しい読み込みが開始されるか、clear() API によって明示的にクリアされることです。

```java
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    if (isImagePosition(position)) {
        String url = urls.get(position);
        Glide.with(fragment)
            .load(url)
            .into(holder.imageView);
    } else {
        Glide.with(fragment).clear(holder.imageView);
        holder.imageView.setImageDrawable(specialDrawable);
    }
}
```

ビューで clear() または into(View) を呼び出すと、読み込みがキャンセルされ、呼び出しが完了した後に Glide がビューの内容を変更しないことが保証されます。clear() の呼び出しを忘れて新しい読み込みを開始しない場合は、特別な Drawable を設定してビューの内容を古い画像に変更した後、以前の位置で同じビューに開始した読み込みが完了する可能性があります。

ここで示した例は RecyclerView 用ですが、同じ原則が ListView にも適用されます。


## ビュー以外のターゲット

ビットマップとドローアブルをビューに読み込むだけでなく、独自のカスタム ターゲットへの非同期読み込みを開始することもできます。

```java
Glide.with(context)
    .load(url)
    .into(new CustomTarget<Drawable>() {
    
        @Override
        public void onResourceReady(Drawable resource, Transition<Drawable> transition) {
            // Do something with the Drawable here.
        }

        @Override
        public void onLoadCleared(@Nullable Drawable placeholder) {
            // Remove the Drawable provided in onResourceReady from any Views and ensure 
            // no references to it remain.
        }
    });
```

カスタム ターゲットの使用には注意点がいくつかありますので、詳細についてはターゲットのドキュメント ページを確認してください。


## バックグラウンド スレッド

バックグラウンド スレッドで画像を読み込むことも、submit(int, int) を使用すると簡単です。

```java
FutureTarget<Bitmap> futureTarget =
    Glide.with(context)
        .asBitmap()
        .load(url)
        .submit(width, height);

Bitmap bitmap = futureTarget.get();

// Do something with the Bitmap and then when you're done with it:
Glide.with(context).clear(futureTarget);
```

バックグラウンド スレッド自体に Bitmap または Drawable が必要ない場合は、フォアグラウンド スレッドと同じ方法で、バックグラウンド スレッドで非同期読み込みを開始することもできます。

```java
Glide.with(context)
    .asBitmap()
    .load(url)
    .into(new Target<Bitmap>() {
        // ...
    });
```



