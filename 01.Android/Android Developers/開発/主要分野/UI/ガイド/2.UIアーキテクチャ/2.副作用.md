- [Compose における副作用](#compose-における副作用)
  - [状態と作用のユースケース](#状態と作用のユースケース)
  - [LaunchedEffect : コンポーザブルのスコープ内で suspend 関数を実行する](#launchedeffect--コンポーザブルのスコープ内で-suspend-関数を実行する)
    - [LaunchedEffect のラムダブロックが実行されるタイミング](#launchedeffect-のラムダブロックが実行されるタイミング)
  - [rememberCoroutineScope : コンポーザブルのライフサイクルに連動しつつ、非コンポーザブルコンテキストでコルーチンを起動する](#remembercoroutinescope--コンポーザブルのライフサイクルに連動しつつ非コンポーザブルコンテキストでコルーチンを起動する)
  - [LaunchedEffect と rememberCoroutineScope の違い](#launchedeffect-と-remembercoroutinescope-の違い)
  - [rememberUpdatedState : 再コンポーズされない作用から、最新の値を参照する](#rememberupdatedstate--再コンポーズされない作用から最新の値を参照する)
    - [【注意】再コンポーズ時の挙動](#注意再コンポーズ時の挙動)
    - [別のサンプルコード](#別のサンプルコード)
  - [DisposableEffect : クリーンアップが必要な作用](#disposableeffect--クリーンアップが必要な作用)
    - [例１：リスナーの登録と解除などを行う](#例１リスナーの登録と解除などを行う)
    - [例２：ViewModel でコンポーズ固有の状態を保持しており、コンポーズが破棄されるタイミングで状態をクリアする必要がある場合](#例２viewmodel-でコンポーズ固有の状態を保持しておりコンポーズが破棄されるタイミングで状態をクリアする必要がある場合)
    - [注意点](#注意点)
    - [DisposableEffect のラムダ内で suspend 関数を実行したい場合](#disposableeffect-のラムダ内で-suspend-関数を実行したい場合)
  - [SideEffect : Compose の状態を非 Compose コードに公開する](#sideeffect--compose-の状態を非-compose-コードに公開する)
    - [FirebaseAnalytics の例](#firebaseanalytics-の例)
      - [ポイント1：State オブジェクトでラップしていない](#ポイント1state-オブジェクトでラップしていない)
      - [具体的な使用例](#具体的な使用例)
    - [基本的な使い方](#基本的な使い方)
    - [外部状態の更新](#外部状態の更新)
    - [複数の SideEffect](#複数の-sideeffect)
    - [SideEffect の注意点](#sideeffect-の注意点)
  - [produceState : Compose 以外の状態を Compose の状態に変換する](#producestate--compose-以外の状態を-compose-の状態に変換する)
    - [例1 : ネットワークから画像を読み込む例（公式ドキュメントの例）](#例1--ネットワークから画像を読み込む例公式ドキュメントの例)
    - [例2 : ユーザー ID からユーザーデータを取得する例](#例2--ユーザー-id-からユーザーデータを取得する例)
    - [awaitDispose の使用例](#awaitdispose-の使用例)
  - [derivedStateOf : 1 つ以上の状態オブジェクトを別の状態に変換する](#derivedstateof--1-つ以上の状態オブジェクトを別の状態に変換する)
    - [基本的な使い方](#基本的な使い方-1)
    - [ポイント](#ポイント)
    - [リストのスクロールを検出する例](#リストのスクロールを検出する例)
    - [誤った使用方法](#誤った使用方法)
  - [snapshotFlow : Compose の State を Flow に変換する](#snapshotflow--compose-の-state-を-flow-に変換する)
  - [作用を再起動する](#作用を再起動する)
    - [キーとしての定数](#キーとしての定数)
  - [引用元資料](#引用元資料)


# Compose における副作用

副作用とは、コンポーズ可能な関数の範囲外で発生するアプリの状態の変化を指します。コンポーザブルのライフサイクルとプロパティ（予測できない再コンポジション、異なる順序でのコンポーザブルの再コンポジション、破棄可能な再コンポジションなど）により、コンポーザブルは副作用がないようにするのが理想的 ( 詳しくは、 [Compose における考え方](../1.はじめに/Compose%20における考え方.md) を参照 ) です。

ただし、スナックバーを表示するなどの 1 回限りのイベントをトリガーする場合や、特定の状態で別の画面に移動する場合などに、副作用が必要になることがあります。これらのアクションは、コンポーザブルのライフサイクルを認識している制御された環境から呼び出す必要があります。このページでは、Jetpack Compose が提供する各種の副作用 API について学習します。


## 状態と作用のユースケース

[Compose における考え方](../1.はじめに/Compose%20における考え方.md) のドキュメントで説明されているように、コンポーザブルは副作用なしであるべきです。アプリの状態を変更する必要がある場合は（ [状態の管理に関するドキュメント](./4.状態の管理/1.概要.md) を参照）、作用 API を使用して、副作用が予測可能な方法で実行されるようにする必要があります。

**重要な用語**: **「作用」** とは、 UI を出力せず、コンポジションの完了時に副作用の実行を引き起こすコンポーズ可能な関数です。

作用はさまざまな機会に Compose で起動できるため、過剰に使われがちです。作用で行う処理が UI に関連していることと、 **単方向のデータフロー** を中断しないことを確認してください。これについては、 [状態の管理に関するドキュメント](./4.状態の管理/1.概要.md) で説明されています。

**注**: レスポンシブ UI は、長時間の処理実行時にも UI が応答する必要があるため、基本的に非同期である必要があります。 Jetpack Compose はコールバックの代わりに API レベルでコルーチンを利用することにより、レスポンシブ UI を実現しています。コルーチンについて詳しくは、 [Android での Kotlin コルーチン](https://developer.android.com/kotlin/coroutines?hl=ja&_gl=1*qw7o8z*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..) ガイドをご覧ください。



## LaunchedEffect : コンポーザブルのスコープ内で suspend 関数を実行する

LaunchedEffect コンポーザブルを使用すると、そのラムダ式がコルーチンスコープになって、 suspend 関数を実行したり、 launch 関数で子コルーチンを起動することが可能です。

```kotlin
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import kotlinx.coroutines.delay

@Composable
fun LaunchedEffectExample() {
    // LaunchedEffect は、 key が変更される度に再起動します。
    // key が不要な場合は Unit を渡します。
    LaunchedEffect(Unit) {
        // ここに非同期処理を記述します。
        // 例として、3秒の遅延後にログを出力します。
        delay(3000L)
        println("LaunchedEffect is executed!")
    }
}
```

引数にキーを渡すことも可能です。指定されたキーが変化したときに、既存のコルーチンはキャンセルされ、新しいコルーチン内で、 LaunchedEffect のコードブロックが一度だけ実行されます。

```kotlin
LaunchedEffect(key1 = someKey) {
    // suspend 関数等の処理
}
```

LaunchedEffect で開始したコルーチンは、 LaunchedEffect がコンポジションから退場するまで存在し続け、退場した際にキャンセルされます。

次の例は、変更可能な遅延で、アルファ値を 0 - 1 間で繰り返し変更するアニメーションです。

```kotlin
// 遅延時間を設定できるようにして、
// 時間切れになりそうな場合に、パルスを速めて
// ユーザーに対して強調表示ることができます。
var pulseRateMs by remember { mutableStateOf(3000L) }
val alpha = remember { Animatable(1f) }

// パルスレートが変更される度に再起動する作用です。
LaunchedEffect(pulseRateMs) {
    while (isActive) {
        delay(pulseRateMs)
        alpha.animateTo(0f)
        alpha.animateTo(1f)
    }
}
```

上記のコードでは、アニメーションは suspend 関数 delay を使用して、設定された時間待機します。次に、 [animateTo](https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable?hl=ja&_gl=1*r1iuln*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1)) を使用して、アルファを 0 にアニメーション化してから元に戻します。これはコンポーザブルの存続期間中繰り返されます。


### LaunchedEffect のラムダブロックが実行されるタイミング

LaunchedEffect のラムダブロックは、キーが変更されるか、 LaunchedEffect がコンポーズに入場する時にのみ実行されます。

```kotlin
@Composable
fun MyComposable(b: Boolean) {
    Log.v("test", "enter MyComposable")

    // MyComposable のパラメータ b の状態が変更された場合の
    // 各コンポーザブルの再実行の様子

    // 【1】実行されない
    LaunchedEffect(Unit) {
        Log.v("test", "enter LaunchedEffect")
    }
    // 【2】実行されない
    LaunchedEffect(Unit) {
        Log.v("test", "state = $b in LaunchedEffect")
    }
    // 【3】実行される
    Text(text = "state = $b")
}
```

上記の例では、 MyComposable 関数のパラメータ b の状態が変更され、 MyComposable 関数が再コンポーズされる場合の、 LaunchedEffect の挙動を実験するものです。実験結果は次の通りです。

- 1 のラムダブロックは実行されません。
  - 親のコンポーザブル関数が再コンポーズされても、 LaunchedEffct のラムダブロックは再実行されません。
- 2 のラムダブロックは実行されません。
  - ラムダブロック内で、状態 b を参照しており、 b の状態が変更しても、ラムダブロックは再実行されません。
- 3 の Text コンポーザブルは再コンポーズされます。
  - 通常のコンポーザブル関数は、状態 b が変更されれば、再コンポーズが実施されます。

つまり、 LaunchedEffect のラムダブロックが実行されるタイミングは、 remember 関数のラムダブロックが実行されるタイミングと同じです。


## rememberCoroutineScope : コンポーザブルのライフサイクルに連動しつつ、非コンポーザブルコンテキストでコルーチンを起動する

前のセクションで説明した LaunchedEffect はコンポーズ可能な関数であるため、他のコンポーズ可能な関数内でのみ、使用できます。

例えば、以下のように、 Button の onClick パラメータの型は、 `() -> Unit` であり、 ( @Composable アノテーションが付与されていないため) コンポーザブルコンテキストではありません。そのため、 onClick パラメータに渡すラムダ内で、 LaunchedEffect 関数は使用できません。

```kotlin
Button(
    onClick = {
        // 【NG】コンポーザブルコンテキストではないため、呼び出せない。
        LaunchedEffect(Unit) {

        }
    }
) {
    Text(text = "ボタン")
}
```

コンポーザブルのライフサイクルに連動しつつ、 **非** コンポーザブルコンテキストで、コルーチンを起動するには、 rememberCoroutineScope を使用します。また、コルーチンのライフサイクルを、手動で制御する必要がある場合（たとえば、ユーザー イベントが発生したときにアニメーションをキャンセルする場合 ( onClick で、 scope.cancel() を実行したい場合のことだと思う) ）も、常に rememberCoroutineScope を使用します。

次の例では、ユーザーが Button をタップしたときに、次のコードを使用して Snackbar を表示できます。

```kotlin
@Composable
fun MoviesScreen(snackbarHostState: SnackbarHostState) {

    // MovieScreen's ライフサイクルにバインドされたコルーチンスコープを取得します。
    val scope = rememberCoroutineScope()

    Scaffold(
        snackbarHost = {
            SnackbarHost(hostState = snackbarHostState)
        }
    ) { contentPadding ->
        Column(Modifier.padding(contentPadding)) {
            Button(
                onClick = {
                    // ボタンがタップされた時にコルーチンを開始します。
                    scope.launch {
                        snackbarHostState.showSnackbar("Something happened!")
                    }
                }
            ) {
                Text("Press me")
            }
        }
    }
}
```

**注意** : 上記の例では、 MoviesScreen コンポーザブルが、コンポジションから退場すると、 scope はキャンセルされます。そのため、 rememberCoroutineScope は、 rememberCoroutineScope を呼び出した親コンポーザブルのライフサイクルに連動するように思えますが、実は、厳密には、そうではありません。 rememberCoroutineScope 関数自体がコンポーザブル関数です。 rememberCoroutineScope 関数がコンポジションから退場した時点で、そのスコープはキャンセルされます。次の例を見てください。

```kotlin
// isButtonShown が false になった際に
// 【1】キャンセルされない
val scope = rememberCoroutineScope()

if (isButtonShown) {

    // isButtonShown が false になった際に
    // 【2】キャンセルされる
    val scope = rememberCoroutineScope()

    Button(
        onClick = {
            scope.launch {
                repeat(100) {
                    delay(1000)
                    Log.d("test", "current repeat = $it")
                }
            }
        }
    ) {
        Text(text = "ログ出力")
    }
}
```

上記のコードでは、 2 箇所で、 rememberCoroutineScope 関数を呼び出しています。 (その結果を同じ名前の変数に代入しているため、実際には、片方を削除しないと動作しません。)

どちらでスコープを生成するかによって、動作が異なります。具体的には、次のような動作になります。

- 【1】 の部分で rememberCoroutineScope を呼び出した場合
  -  isButtonShown が false になっても、生成されたスコープは、キャンセルされません。
- 【2】 の部分で rememberCoroutineScope を呼び出した場合
  -  isButtonShown が false になると、生成されたスコープは、キャンセルされます。

つまり、 rememberCoroutineScope 関数の呼び出しが、 Composition から退場すると、スコープはキャンセルされます。

remember 系の関数であるため、コンポーザブルの再コンポーズ時には破棄されず、コンポーザブルが完全に破棄される際にコルーチンも破棄されます。


## LaunchedEffect と rememberCoroutineScope の違い

- LaunchedEffect
  - LaunchedEffect に渡されたブロックの処理が終了すると、コルーチンスコープは破棄される。
- rememberCoroutineScope
  - rememberCoroutineScope で生成されたスコープは、 rememberCoroutineScope コンポーザブルがコンポジションから退場するまで存続する。


## rememberUpdatedState : 再コンポーズされない作用から、最新の値を参照する

rememberUpdatedState は、主に LaunchedEffect や DisposableEffect のラムダブロック内で、それらの作用を再起動せずに、最新の値を参照するのに使われます。

たとえば、次のコードは、表示されてしばらくすると消えるスプラッシュ画面 ( LandingScreen ) を実装しようとしています。

onTimeout を更新しても、 LaunchedEffect で起動したコルーチンは古い onTimeout を参照してしまいます。そのため、新しい onTimeout を呼び出せないという問題が発生します。

```kotlin
@Composable
fun LandingScreen(onTimeout: () -> Unit) {

    LaunchedEffect(true) {
        delay(SplashWaitTimeMillis)
        onTimeout()
    }
}
```

LaunchedEffect のキーに onTimeout() を渡せば良い、と思うかもしれません。しかし、そうすると、 onTimeout() が更新される度に delay が実行されます。 delay を何度も実行したい場合は、それで問題ありません。ただし、今回は、 delay は一度だけ実行したいとします。つまり、 delay は、 LandingScreen がコンポーズに入場した際に一度だけ実行したいとします。    

そのような場合に、 rememberUpdatedState が役立ちます。以下のように rememberUpdatedState を利用すると、常に、最新の onTimeout を参照するようになります。 LaunchedEffect で起動したコルーチンは、この rememberUpdatedState で保持された onTimeout を利用するので、必ず新しい onTimeout を呼び出すようになります。

```kotlin
@Composable
fun LandingScreen(onTimeout: () -> Unit) {

    // onTimeout が更新される度に、 currentOnTimeout を更新します。
    val currentOnTimeout by rememberUpdatedState(onTimeout)

    LaunchedEffect(true) {
        delay(SplashWaitTimeMillis)

        // LaunchedEffect 関数開始時の onTime ではなく、
        // その後、 onTime が更新されていれば、
        // その最新の onTime を参照します。
        currentOnTimeout()

        // ここでは、 currentOnTimeout を参照 (キャプチャ) することしかできず、
        // currentOnTimeout を更新することは、できません。
        // これは、 rememberUpdatedState 関数は、
        // 不変な State<T> オブジェクトを返すためです。
    }
}
```

このアプローチは、再作成、または、再起動が高コストであるか、現実的ではない長期的なオペレーションを含む作用で役立ちます。

警告: LaunchedEffect(true) と LaunchedEffect(Unit) は、どちらも同じ挙動をしますが、一般的には、 LaunchedEffect(Unit) を使用します。 true は、何かそれ自体に意味があるのかと、疑うことにつながるため、できる限り避けてください。

rememberUpdatedState 関数で生成したプロパティの名前は、 current で始まる名前が付けられることが多いです。この current には、 「最新の」 という意味があります。 rememberUpdatedState は、古い値を参照せず、常に最新の値を参照することから、この接頭辞がつけられることが多いです。 current の代わりに updated が使用されることもあります。


### 【注意】再コンポーズ時の挙動

rememberUpdatedState() 関数は、 remember～ という名前であるため、再コンポーズ時には、実行されないイメージを持つかもしれませんが、実行されます。

そもそも、 remember(){} 関数も、再コンポーズ時には、ラムダブロックが実行されないだけで、 remember() 関数の本体は、実行されているはずです。

rememberUpdatedState() 関数の本体は、以下のようになっているため、 apply 関数で、 rememberUpdatedState() 関数の引数で渡されてきた値が、 State にセットされています。

```kotlin
@Composable
fun <T> rememberUpdatedState(newValue: T): State<T> =
    remember { mutableStateOf(newValue) }.apply { value = newValue }
```


### 別のサンプルコード

```kotlin
@Composable
fun MyComposable(
    onClick: () -> Unit
) {
    // updatedOnClick には、「更新された onClick 」という意味が
    // 込められていると思われる。
    // つまり、「最新の onClick 」という意味だと思う。
    val updatedOnClick by rememberUpdatedState(onClick)

    Button(onClick = { updatedOnClick() }) {
        Text("Click me")
    }
}
```

rememberUpdatedState は最新の onClick の値を保持する State オブジェクトを返します。これにより、 onClick の値が変更されたときに Button の再コンポーズが実施されていなくても、最新の onClick の値を使用できます。

上記の例の場合は、別に rememberUpdatedState を使用しなくても、 MyComposable の onClick が変化した場合は、 Button が再コンポーズされるため、最新の状態は適用されます。そのため、 rememberUpdatedState を使用する意味はあまりないと思われます。 onClick パラメータを渡す相手が、再コンポーズされると困る場合は、 rememberUpdatedState を使用すると効果的だと思われます。


## DisposableEffect : クリーンアップが必要な作用

DisposableEffect は、コンポジションが破棄される際にクリーンアップ処理を行うための関数です。

キーが変化した後、または、コンポーザブルが Composition から退場したときにクリーンアップする必要がある副作用については、 [DisposableEffect](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja&_gl=1*1anquuv*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..#DisposableEffect(kotlin.Any,kotlin.Function1)) を使用します。 DisposableEffect のキーが変化した場合、コンポーザブルは、その現在の作用を破棄（クリーンアップ）して、作用を再度呼び出して、リセット (再起動・再作成) する必要があります。

たとえば、 [LifecycleObserver](https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver?hl=ja&_gl=1*1anquuv*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..) を使用し、 [Lifecycle](https://developer.android.com/topic/libraries/architecture/lifecycle?hl=ja&_gl=1*1anquuv*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..#lc) イベントに基づいて、アナリティクスイベントを送信する場合を考えます。 Compose で、 Lifecycle のイベントをリッスンするには、 DisposableEffect を使用し、必要に応じて、オブザーバーの登録と登録解除を行います。

DisposableEffect のラムダブロックは、コルーチンスコープではありません。そのため、単純に LaunchedEffect にクリーンアップ機能がついたわけではないため、注意してください。


### 例１：リスナーの登録と解除などを行う

```kotlin
@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -> Unit, // "開始" のアナリティクスイベントを送信する処理
    onStop: () -> Unit // "終了" のアナリティクスイベントを送信する処理
) {
    // 再コンポーズが発生し、新しいコールバックが渡されてきたら
    // 安全に更新します。詳細は、 rememberUpdatedState の
    // セクションを参照してください。
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    // もし lifecycleOwner が変更されたら、 DisposableEffect を
    // 破棄して、リセット(再起動・再作成)します。
    DisposableEffect(lifecycleOwner) {

        // 保持されたコールバックをトリガーするオブザーバーを生成します。
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_START) {
                currentOnStart()
            } else if (event == Lifecycle.Event.ON_STOP) {
                currentOnStop()
            }
        }

        // オブザーバーをライフサイクルに連携します。
        lifecycleOwner.lifecycle.addObserver(observer)

        onDispose {
            // DisposableEffect がコンポジションを退場する際に実行されます。
            // オブザーバーを解除します。
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    /* HomeScreen のコンテンツが続きます。 */
}
```

上記のコードでは、作用は observer を lifecycleOwner に追加します。lifecycleOwner が変化すると、作用は破棄されて新しい lifecycleOwner で再起動されます。

DisposableEffect は、コンポーザブル関数です。この関数が、コンポジションから退場するときに、 onDispose のラムダが実行されます。 DisposableEffect コンポーザブル単体で、コンポジションから退場するということは、あまりやらない気がするので、実際には、 DisposableEffect の直接の親コンポーザブルが退場するのに合わせて、何らかのクリーンアップ処理を実施する場合が多いと思われます。


### 例２：ViewModel でコンポーズ固有の状態を保持しており、コンポーズが破棄されるタイミングで状態をクリアする必要がある場合

この使用方法は、公式ドキュメントには記載されていないため、実際に、このような使用方法をする場合があるのかは、不明です。参考程度にしてください。

もし、 ViewModel に Compose 固有のリソースや状態を渡す必要がある場合、 DisposableEffect を使用して、 Composable のライフサイクルに応じてリソースを適切にクリーンアップすることができます。これにより、ライフサイクルの不一致によるメモリリークを防げます。 (クリアしなかった場合、コンポーズよりも ViewModel の方がライフサイクルが長いために、メモリリークが発生します。)

```kotlin
@Composable
fun SomeComposable(viewModel: SomeViewModel) {
    DisposableEffect(Unit) {
        // ViewModelに必要なリソースを渡す
        onDispose {
            // Composeが破棄されたときにクリーンアップ
        }
    }
}
```


### 注意点

DisposableEffect は、コードブロックの **最後のステートメント** として onDispose 句を含んでいる必要があります。含んでいない場合、IDE はビルド時にエラーを表示します。

注: onDispose に空のブロックを含めることはおすすめしません。ユースケースに適した作用があるかどうかを常に検討してください。

DisposableEffect のラムダブロックは、コルーチンスコープではないため、 suspend 関数を実行することはできません。もし、 suspend 関数を実行したい場合は、次のセクション [DisposableEffect のラムダ内で suspend 関数を実行したい場合](#disposableeffect-のラムダ内で-suspend-関数を実行したい場合) を参照してください。


### DisposableEffect のラムダ内で suspend 関数を実行したい場合

LaunchedEffect と DisposableEffect を組み合わせて使用することで、 suspend 関数を実行しつつ、クリーンアップ処理を実行することが可能だそうです。 ChatGPT の回答であるため、問題なく使用できる方法なのかの保証はありません。

```kotlin
@Composable
fun MyComposable(someKey: Any) {

    LaunchedEffect(someKey) {
        // suspend 関数をここで実行
    }

    // リソースのクリーンアップ処理
    DisposableEffect(someKey) {
        // 初期化処理
        println("Effect started with $someKey")

        // クリーンアップ処理
        onDispose {
            println("Effect disposed with $someKey")
        }
    }
}
```


## SideEffect : Compose の状態を非 Compose コードに公開する

SideEffect は呼び出し元のコンポーザブルが、コンポーズされる度 (初回コンポーズも再コンポーズも全て含む) に、毎回実行されるブロックを引数に持ちます。例えば、ログの記録など、コンポーズが実行されるたびに更新が必要な外部状態の更新に使用されます。

SideEffect を使用すると、再コンポーズが成功するたびに、 SideEffect のラムダブロックが実行されます。なぜ、 SideEffect のラムダは、再コンポーズが成功した後のタイミングで実行されるのでしょうか？そもそも、再コンポーズが、成功したかどうかが保証されていない状態で、副作用を実行することは正しくありません。なぜなら、 Compose の内部状態と外部オブジェクトとの間で、状態が不一致になる可能性があるためです。コンポーザブルの処理が、途中で失敗した場合は、コンポーザブルの状態と外部状態が、不一致になる可能性があるため、外部状態の更新は、コンポーザブルの成功が確認されてから実行するのが良いです。

以下に SideEffect の具体的な使用方法を示します。


### FirebaseAnalytics の例

分析ライブラリを使用すると、カスタム メタデータ（この例では「ユーザー プロパティ」）を後続のすべての分析イベントにアタッチすることで、ユーザー全体をセグメント化できます。現在のユーザーのユーザータイプを分析ライブラリに伝えるには、SideEffect を使用してその値を更新します。

```kotlin
@Composable
fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
    val analytics: FirebaseAnalytics = remember {
        FirebaseAnalytics()
    }

    // コンポーズが成功する度に、アナリティクスの
    // 現在のユーザーの userType が更新されます。
    // 将来のアナリティクスイベントは、
    // このメタデータが付与されいることが確信できます。
    SideEffect {
        analytics.setUserProperty("userType", user.userType)
    }
    return analytics
}
```


#### ポイント1：State オブジェクトでラップしていない

FirebaseAnalytics インスタンスは、 State オブジェクトでラップしていません。

FirebaseAnalytics オブジェクトは、 Compose の UI に直接影響を与えるデータではないため、状態を追跡する必要がなく、 State オブジェクトでラップする必要はありません。


#### 具体的な使用例

上記の FirebaseAnalytics のサンプルでは、コンポーザブル関数が、戻り値を持っているなど、不思議な点がありました。このサンプルの使用側の例も載せてくれていると思われるサンプルがあったため、以下に載せておきます。

```kotlin
class Logger {
    var user: String = "UNKNOWN"
    fun write(message: String) {
        println("$message $user")
    }
}

@Composable
fun rememberLogger(userName: String): Logger {

    // 以下のどちらでも正しく動きます。    
    // 【1】引用元の記述はこちら
    val logger: Logger by remember { mutableStateOf(Logger()) }
    // 【2】公式の FirebaseAnalytics サンプルに近づけるならこちら
    val logger: Logger = remember { Logger() }

    SideEffect {
        logger.user = userName
    }
    return logger
}

@Composable
fun Sample(userName: String) {
    val logger = rememberLogger(userName = userName)
    Box {
        Button(onClick = { logger.write("Click Button!!") }) {
           Text(text = "Click")
        }
    }
}
```


### 基本的な使い方

SideEffect は再コンポーズのたびに実行される処理を定義するために使用します。これにより、Compose の状態が変化するたびに外部の副作用を処理できます。

```kotlin
@Composable
fun MyComposable(state: Int) {
    // 副作用を実行
    SideEffect {
        println("State has changed to $state")
    }

    // 他の Compose UI コンポーネント
    Text(text = "Current state: $state")
}
```

上記のコードでは、 state が変更されるたびに SideEffect 内の処理が実行され、状態の変更がコンソールに出力されます。


### 外部状態の更新

SideEffect は、 Compose の状態に基づいて外部の非 Compose 状態を更新するのにも役立ちます。例えば、 ViewModel のプロパティを更新する場合などです。

```kotlin
class MyViewModel : ViewModel() {
    var externalState by mutableStateOf(0)
}

@Composable
fun MyComposable(viewModel: MyViewModel, state: Int) {
    // ViewModel の状態を更新
    SideEffect {
        viewModel.externalState = state
    }

    // 他の Compose UI コンポーネント
    Text(text = "Current state: ${viewModel.externalState}")
}
```

ここでは、 state が変更されるたびに viewModel.externalState が更新されます。


### 複数の SideEffect

複数の SideEffect を使用することもできます。それぞれの SideEffect ブロックは再コンポーズのたびに独立して実行されます。

```kotlin
@Composable
fun MyComposable(state1: Int, state2: Int) {
    // 最初の副作用
    SideEffect {
        println("State1 has changed to $state1")
    }

    // 二番目の副作用
    SideEffect {
        println("State2 has changed to $state2")
    }

    // 他の Compose UI コンポーネント
    Text(text = "State1: $state1, State2: $state2")
}
```

ここでは、 state1 および state2 の変更ごとに、 2 つの SideEffect が実行されます。 state1 のみ状態が変更されたとしても、 state2 の SideEffect のラムダも実行されます。 SideEffect には、キーパラメータが存在しないため、親が再コンポーズされると、スキップされずに、必ずラムダブロックが実行されます。


### SideEffect の注意点

SideEffect は再コンポーズのたびに実行されるため、重い処理を行うことは避けるべきです。重い処理は LaunchedEffect や rememberCoroutineScope を使用して非同期に行う方が適しています。

SideEffect のラムダブロックは、コルーチンスコープではないため、直接コルーチンを起動することはできません。


## produceState : Compose 以外の状態を Compose の状態に変換する

[produceState](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja&_gl=1*2rnjn8*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1)) は、 produceState コンポーザブルをスコープとするコルーチンを起動します。つまり、 produceState コンポーザブルが、コンポジションに入場すると、コルーチンが起動し、退場すると、コルーチンがキャンセルされます。

produceState により、返される [State](https://developer.android.com/reference/kotlin/androidx/compose/runtime/State?hl=ja&_gl=1*ksg4tx*_up*MQ..*_ga*NzU5NjYwOTAuMTczMTkwMDk4Ng..*_ga_6HH9YJMN9M*MTczMTkwMDk4NS4xLjAuMTczMTkwMDk4NS4wLjAuMTIzMTQyOTU2NQ..) に値をプッシュできます。値をプッシュするには、 produceState のラムダブロック内で、 value プロパティに対して、値を代入します。

prodeceState を使用すると Compose 外の状態を Compose の状態に変換できます。たとえば、外部のサブスクリプションに基づく状態（ Flow / LiveData / RxJava など）をコンポーザブルの内部状態に取り込みます。

value ( produceState から返される State ) に、同じ値を設定しても、再コンポーズはトリガーされません。異なる値が設定されると、再コンポーズがトリガーされます。


### 例1 : ネットワークから画像を読み込む例（公式ドキュメントの例）

次の例は、produceState を使用してネットワークから画像を読み込む方法を示しています。 loadNetworkImage コンポーザブルは、他のコンポーザブルで使用できる State を返します。

```kotlin
@Composable
fun loadNetworkImage(
    url: String,
    imageRepository: ImageRepository = ImageRepository()
): State<Result<Image>> {
    // 初期値として Result.Loading を State に設定します。
    // `url` か `imageRepository` のどちらかが変更された場合、
    // コルーチンはキャンセルされ、新しい値で再起動されます。
    return produceState<Result<Image>>(
        initialValue = Result.Loading,
        url,
        imageRepository
    ) {
        // ここはコルーチンスコープなので、 suspend 関数が実行できます。
        val image = imageRepository.load(url)

        // Error か Success を value に代入することで、状態を更新します。
        // 状態が更新されたら、この状態を参照している部分が
        // 再コンポーズされます。
        value = if (image == null) {
            Result.Error
        } else {
            Result.Success(image)
        }
    }
}
```

**注**: 戻り値の型を持つコンポーザブルは、通常の Kotlin 関数と同様の名前（ただし、先頭は小文字）にする必要があります。

**キーポイント**: 内部的には、 produceState は他の作用を使用します。既存の API を利用して、独自の作用を簡単に作成できます。

上記のサンプルでは、全体像が見えないため、全体像がイメージできる、類似サンプルを以下に記載します。

```kotlin
@Composable
fun MyScreen() {

    var baseString by remember {
        mutableStateOf("Base String")
    }

    val state = getState(baseString)

    Scaffold { innerPadding ->
        Column(modifier = Modifier.padding(innerPadding)) {
            TextField(value = baseString, onValueChange = { baseString = it })
            Text(text = state.value)
        }
    }
}

@Composable
fun getState(baseString: String): State<String> {
    return produceState(initialValue = "", baseString) {
        value = suspendJoin(baseString)
    }
}

// 引数で与えられた文字列の後ろに suffix を付与して返す関数
suspend fun suspendJoin(baseString: String): String {
    // 何らかの処理に代わる疑似的な遅延
    delay(1000)
    return "$baseString suffix"
}
```

上記を実行すると、 1 秒後に以下のように表示されます。 TextField の値を変更すれば、それが Text に反映されます。

<img src="./画像/produceState のサンプル.png" width="400">


### 例2 : ユーザー ID からユーザーデータを取得する例

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyComposable("001")
        }
    }
}

@Composable
fun MyComposable(userId: String) {

    Log.v("test", "Enter MyComposable")

    // 非同期でユーザーデータを取得する。
    // 結果は State 型で返される。
    val user by produceState<User?>(initialValue = null, key1 = userId) {
        Log.v("test", "実行順序-2")
        val fetchedUser = fetchUser(userId) // サスペンド関数でユーザーを取得
        Log.v("test", "実行順序-5")
        value = fetchedUser
    }

    Log.v("test", "Middle of MyComposable")

    // UI コンポーネント
    if (user == null) {
        Log.v("test", "実行順序-1")
        Text(text = "Loading...")
    } else {
        Log.v("test", "実行順序-6")
        Text(text = "User name: ${user?.name}")
    }
}

// サスペンド関数の例
suspend fun fetchUser(userId: String): User {
    // 非同期処理でユーザー情報を取得する
    Log.v("test", "実行順序-3")
    delay(2000) // 疑似的なネットワーク遅延
    Log.v("test", "実行順序-4")
    return User(userId, "Taro")
}

data class User(val id: String, val name: String)
```

```
実行結果 (ログ出力)

Enter MyComposable
Middle of MyComposable
実行順序-1
実行順序-2
実行順序-3
実行順序-4
実行順序-5
Enter MyComposable
Middle of MyComposable
実行順序-6
```

```
実行結果 (画面)

Loading...
( 2 秒の遅延)
User name: Taro
```


### awaitDispose の使用例

produceState は、コルーチンを作成しますが、一時停止しないデータソースを監視するために使用することもできます。該当するソースのサブスクリプションを削除するには、 [awaitDispose](https://developer.android.com/reference/kotlin/androidx/compose/runtime/ProduceStateScope?_gl=1*1n5xkro*_up*MQ..*_ga*NTAyMzc3MjIxLjE3MTk0OTY0MjM.*_ga_6HH9YJMN9M*MTcxOTQ5NjQyMy4xLjAuMTcxOTQ5NjQyMy4wLjAuMA..#awaitDispose(kotlin.Function0)) 関数を使用します。

```kotlin
suspend fun awaitDispose(onDispose: () -> Unit): Nothing
```

プロデューサーの破棄理由に関わらず (コンポジションから退場したか、ソースが変更されたか、エラーが発生したかに関係なく) 、この **プロデューサーが破棄される直前に、 awaitDisposable のラムダブロック ( `onDispose: () -> Unit` ) を実行してから、プロデューサーを破棄します。**

awaitDispose 関数は、 suspend 関数ではなく、コールバックを使用した状態プロデューサーを作成するときに、役立ちます。例:

```kotlin
import androidx.compose.runtime.produceState

val currentPerson by produceState<Person?>(null, viewModel) {
    val disposable = viewModel.registerPersonObserver { person ->
        // コールバックで状態を更新する例
        value = person
    }

    awaitDispose { disposable.dispose() }
}
```


## derivedStateOf : 1 つ以上の状態オブジェクトを別の状態に変換する

詳しい情報は、 [【ブログ】derivedStateOf を使用すべき状況](./4.状態の管理/【ブログ】derivedStateOf%20を使用すべき状況.md) を参照してください。

derivedStateOf は、 Jetpack Compose で特定の状態が変化したときにのみ再計算される派生状態 (計算された状態) を作成するための API です。これにより、パフォーマンスの最適化や、無駄な再コンポーズを防ぐことができます。

**注意**: derivedStateOf はコストがかかるため、結果が変わらない場合に不必要な再コンポジションを回避する目的でのみ使用します。


### 基本的な使い方

derivedStateOf は、他の状態に基づいて計算される状態 (派生状態) を定義するために使用します。以下に基本的な例を示します。

```kotlin
@Composable
fun MyComposable() {
    // 基本的な状態
    var counter by remember { mutableStateOf(0) }

    // derivedStateOf を使用して派生状態を作成
    val isMultipleOf3 by remember {
        derivedStateOf {
            // 3 の倍数なら true を返す。
            counter % 3 == 0
        }
    }

    // UI コンポーネント
    Column {
        Text(text = "Counter: $counter")
        Text(text = "Is even: $isMultipleOf3")
        Button(onClick = { counter++ }) {
            Text(text = "Increment")
        }
    }
}
```

この例では、 counter が変化するたびに derivedStateOf {} ブロックが再計算されます。 isMultipleOf3 は counter が 3 の倍数かどうかを示す派生状態です。 derivedStateOf 関数を使用することによって、余計な再コンポーズが実施されなくなることがこの関数のメリットです。例えば、 counter が 4 から 5 に変更された場合は、 isMultipleOf3 は false のままであるため、それを参照している `Text(text = "Is even: $isMultipleOf3")` は再コンポーズが実行されません。


### ポイント

- derivedStateOf は、依存する状態が変更されたときにのみ再計算されるため、無駄な再計算を防ぐのに役立ちます。
- パフォーマンスの最適化が必要な場合に使用すると効果的です。
  - 例えば、派生元の状態は頻繁に変化するが、派生先の状態はあまり変化しない場合に使用すると効果的です。
- derivedStateOf の内部で副作用を持つ操作を行わないように注意してください。副作用は SideEffect や LaunchedEffect で処理するのが適切です。
- mutableStateOf() 関数は、引数に値を受け取るため、丸カッコが続きますが、 derivedStateOf{} は、引数に関数型を受け取るため、中カッコが続きます。混同しないように注意してください。


### リストのスクロールを検出する例

```kotlin
@Composable
// messages パラメータが変化した際に、 MessageList は再コンポーズされます。
// その際、 showButton パラメータが変化しなければ、
// AnimatedVisibility は再コンポーズされません。
fun MessageList(messages: List<Message>) {
    Box {
        val listState = rememberLazyListState()

        LazyColumn(state = listState) {
            // ...
        }

        // ボタンの表示 / 非表示制御用の状態
        val showButton by remember {
            derivedStateOf {
                // 画面の一番上に表示されているアイテムが
                // リストの 2 番目以降のアイテムなら true を返す
                listState.firstVisibleItemIndex > 0
            }
        }

        // リストのトップまでスクロールするボタン
        AnimatedVisibility(visible = showButton) {
            ScrollToTopButton()
        }
    }
}
```

このスニペットでは、firstVisibleItemIndex は最初に表示されるアイテムが変更されるたびに変更されます。スクロールすると、値は 0、1、2、3、4、5 などになります。ただし、再コンポジションが必要なのは値が 0 より大きくなった場合のみです。このような更新の頻度が一致しない場合は、derivedStateOf の使用が適したユースケースです。


### 誤った使用方法

以下の例は、 derivedStateOf 関数の誤った使用方法です。不要な derivedStateOf 関数の使用によって、逆にパフォーマンスが低下してしまっています。

```kotlin
var firstName by remember { mutableStateOf("") }
var lastName by remember { mutableStateOf("") }

// 間違った実装
val fullNameBad by remember { derivedStateOf { "$firstName $lastName" } }
// 正しい実装
val fullNameCorrect = "$firstName $lastName"
```

この例の正しい実装では、 fullName を firstName および lastName と同じ頻度で更新します。そのため、過度な再コンポジションは発生せず、 derivedStateOf を使用する必要はありません。


## snapshotFlow : Compose の State を Flow に変換する

snapshotFlow は、 `State<T>` オブジェクトをコールド Flow に変換します。 State オブジェクトは、ある時点の状態 (スナップショット) を表します。 State (スナップショット) を Flow に変換することから、 snapshotFlow という名前になっているようです。

**参考** : StateFlow という似たような名前のオブジェクトも存在しています。 StateFlow は、 Flow を継承しており、型としては Flow の子孫だけど、中身 (機能) としては、 State とほぼ同じです。 StateFlow は、最新の状態のみを保持しており、コレクターに最新の状態のみを放出する Flow の一種です。

snapshotFlow{} は、収集される際に、そのブロックを実行し、その中で読み取られた State オブジェクトの結果を出力します。

snapshotFlow{} ブロック内で読み取られた State オブジェクトのいずれかが変化したとき、ラムダブロック内の処理を再実行します。その結果が新しい値と ( equal 関数で) 異なる場合、 Flow はコレクタに対して、新しい値を放出します (この動作は [Flow.distinctUntilChanged](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html) の動作と似ています) 。

次のコードは、画面に表示されているリストを、ユーザーがスクロールした際、一番上に表示されているリストアイテムが見えなくなったタイミングで、アナリティクス ( Firebase Analytics 等) を送信する例です。

```kotlin
// リストの状態やリストを操作する関数を保持したオブジェクト
val listState = rememberLazyListState()

LazyColumn(state = listState) {
    // ...
}

LaunchedEffect(listState) {
    snapshotFlow {
        // ラムダブロック内のいずれかの状態が変化したら、
        // ラムダブロック内の処理が再実行されます。
        //
        // ラムダブロック内の結果が、前回と異なる場合、
        // コレクターに対して、新しいデータを放出します。
        listState.firstVisibleItemIndex
    }
        // index = 0 の要素が表示されている時はアナリティクスを送信しない。
        // map のラムダ式の結果は、後続の filter の引数に渡される。
        .map { index -> index > 0 }
        // 同一の値が流れてきたときは、それを後続の処理 ( filter ) に流さないようにする役割がある。
        .distinctUntilChanged()
        .filter { it == true }
        .collect {
            MyAnalyticsService.sendScrolledPastFirstItemEvent()
        }
}
```

上記のコードでは listState.firstVisibleItemIndex が Flow に変換され、それにより Flow の演算子が持つ利点を活用できます。


## 作用を再起動する

Compose の一部の作用 ( LaunchedEffect、produceState、DisposableEffect など) は、実行中の作用をキャンセルして、新しいキーで、新しい作用を開始するために使用する引数 (キー) の変数番号を受け取ります。

これらの API の一般的な形式は次のとおりです。

```kotlin
EffectName(restartIfThisKeyChanges, orThisKey, orThisKey, ...) { block }
```

キーが一つでも変更されれば、作用は再起動されます。

作用 API にキーを渡した際に、どのように動作するのかをきちんと理解している必要があります。そうでないと、次のいずれかの問題が発生する可能性があります。

- 再起動する作用が必要な数より少ない場合は、アプリの不具合を引き起こすことがあります。
- 再起動する作用が必要な数より多い場合は、効率が低下します。

経験則上、コードの作用ブロックで使用される変数は、 (可変であれ、不変であれ、) 作用コンポーザブルに、パラメータとして追加する必要があります。

作用ブロック内で使用されない変数でも、作用の再起動を強制したい場合は、キーとして追加することができます。

変数の変化が、作用の再起動を発生させるべきでない場合は、変数を rememberUpdatedState でラップします。ただし、変数が、キーのない remember にラップされている場合は、親のコンポーザブルがコンポジションから退場するまで、値が決して変化しないため、変数をキーとして作用に渡す必要はありません。

**キーポイント**: 作用で使用される変数を作用コンポーザブルのキーパラメータとして追加するか、 rememberUpdatedState を使用する必要があります。キーなしの remember でラップされている場合は、 rememberUpdatedState に変更する必要があるかもしれません。

DisposableEffect セクションで取り上げたサンプルコードを、ここで再度取り上げて説明していきます。作用は、ブロックで使用されている lifecycleOwner をパラメータとして受け取ります。これが変化した場合に、作用を再起動する必要があるからです。一方で、 onStart と onStop が変化した場合に、作用を再起動する必要はないため、これらは、 rememberUpdatedState でラップすることで、作用の内部では、常に最新の値を使用することができます。

```kotlin
@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -> Unit, // "開始" のアナリティクスイベントを送信する処理
    onStop: () -> Unit // "終了" のアナリティクスイベントを送信する処理
) {
    // 再コンポーズが発生し、新しいコールバックが渡されてきたら
    // 安全に更新します。詳細は、 rememberUpdatedState の
    // セクションを参照してください。
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    // もし lifecycleOwner が変更されたら、 DisposableEffect を
    // 破棄して、リセット(再起動・再作成)します。
    DisposableEffect(lifecycleOwner) {

        // 保持されたコールバックをトリガーするオブザーバーを生成します。
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_START) {
                currentOnStart()
            } else if (event == Lifecycle.Event.ON_STOP) {
                currentOnStop()
            }
        }

        // オブザーバーをライフサイクルに連携します。
        lifecycleOwner.lifecycle.addObserver(observer)

        onDispose {
            // DisposableEffect がコンポジションを退場する際に実行されます。
            // オブザーバーを解除します。
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    /* HomeScreen のコンテンツが続きます。 */
}
```

currentOnStart と currentOnStop は、 rememberUpdatedState の使用により、常に最新の値が DisposableEffect ラムダブロック内で参照されるため、 DisposableEffect のキーに渡す必要ありません。

もし、 lifecycleOwner が、 DisposableEffect のキーとして渡されなかった場合、 lifecycleOwner が変化した際に、 HomeScreen は再コンポーズされますが、 DisposableEffect は、再起動しません。これにより、それ以降も古い lifecycleOwner が使用されることになり、不具合が発生します。


### キーとしての定数

キーとして true のような定数を使用すると、親のコンポーザブル関数のライフサイクルに従うようになります。次の例では、 LandingScreen が再コンポーズされようとも、 LaunchedEffect が再コンポーズされることはありません。 LandingScreen がコンポジションに再入場した場合に一回だけ起動し、自身 ( LaunchedEffect ) がコンポジションから退場した場合に、コルーチンはキャンセルされます。

```kotlin
@Composable
fun LandingScreen(onTimeout: () -> Unit) {

    LaunchedEffect(true) {
        //
    }

}
```

ただし、いったん立ち止まって、キーに true などの定数を使用することが、本当に必要かどうかを確認してください。そもそも、 ( Unit を含め) true などの定数を使用する必要がない場合もあります。定数が必要なケースももちろんあるため、その場合は、定数を使って問題ありません。ただし、その場合は、 true のような、何か意味がありそうな定数を使用するのではなく、 Unit を使用するのがベストです。


## 引用元資料

- [Compose における副作用](https://developer.android.com/develop/ui/compose/side-effects?hl=ja)


