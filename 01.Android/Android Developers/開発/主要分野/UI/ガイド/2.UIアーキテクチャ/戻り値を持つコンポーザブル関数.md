- [戻り値を持つコンポーザブル関数](#戻り値を持つコンポーザブル関数)
  - [簡単な例](#簡単な例)
  - [戻り値を持つコンポーザブル関数の特徴](#戻り値を持つコンポーザブル関数の特徴)
  - [具体的な使用例](#具体的な使用例)
    - [カラーピッカーダイアログ](#カラーピッカーダイアログ)
    - [ビジネスロジックを共通化する](#ビジネスロジックを共通化する)
    - [独自の状態管理を共通化する](#独自の状態管理を共通化する)
    - [多用する UI 要素を共通化する](#多用する-ui-要素を共通化する)


# 戻り値を持つコンポーザブル関数

コンポーザブル関数は、一般的には戻り値を持ちませんが、場合によっては、戻り値を持つものを定義した方が良い場合もあります。


## 簡単な例

```kotlin
@Composable
fun MyScreen() {
    Column {
        val count = rememberCounter()
        // ボタンが押されると、 count が更新され
        // それにより Text コンポーザブルが再コンポーズされ、
        // Text に状態が反映されます。
        Text(text = "count = $count")
    }
}

// 戻り値を持つコンポーザブル関数は、小文字から始まる名前にします。
@Composable
fun rememberCounter(): Int {
    // 状態の保持
    var count by remember { mutableStateOf(0) }

    // 状態を更新するビジネスロジック
    Button(onClick = { count++ }) {
        Text("Clicked $count times")
    }

    return count
}
```

<img src="./画像/戻り値を持つコンポーザブルの例.png" width="300">


## 戻り値を持つコンポーザブル関数の特徴

- コンポーザブル関数内部に 「状態」 と 「状態を更新するビジネスロジック」 を両方保持することが多いです。
  - 内部に保持していることにより、外部からカスタマイズすることが困難になります。
  - 逆に、カスタマイズが不要の場合は、再利用性が高まります。


## 具体的な使用例

### カラーピッカーダイアログ

```kotlin
@Composable
fun MyScreen() {

    Column(modifier = Modifier.padding(innerPadding)) {

        // ダイアログの表示 / 非表示を制御する状態
        var openDialog by remember {
            mutableStateOf(false)
        }

        // カラーピッカーダイアログ
        val color = colorPickerDialog(openDialog) { openDialog = false }

        // タップしたらダイアログを開くボタン
        Button(onClick = { openDialog = true }) {
            Text(text = "Open Dialog")
        }

        // 選択された色を使用する
        Text(text = "背景色を変更", modifier = Modifier.background(color))
    }

}

@Composable
fun colorPickerDialog(open: Boolean, onDismiss: () -> Unit): Color {
    // 選択された色の状態
    var selectedColor by remember { mutableStateOf(Color.Yellow) }

    if (open) {
        Dialog(onDismissRequest = {
            // コンテンツ外をタップした際に呼ばれるラムダ

            // ダイアログの表示制御は、親コンポーザブル内のボタンからも行われるため、
            // 表示制御を行う状態を親にホイスティングする必要がある。
            // よって、ダイアログの非表示処理は onDismiss で親にイベント伝搬し、
            // 親側で状態を更新する必要がある。
            onDismiss()
        }) {
            Column {
                listOf(Color.Red, Color.Green, Color.Blue).forEach { color ->
                    Box(
                        modifier = Modifier
                            .size(50.dp)
                            .background(color)
                            .clickable {
                                selectedColor = color
                                onDismiss()
                            }
                    )
                }
            }
        }
    }

    return selectedColor
}
```

以下は、初期状態です。

<img src="./画像/ダイアログサンプル 初期状態.png" width="400">

以下は、ダイアログ表示中の状態です。

<img src="./画像/ダイアログサンプル ダイアログ表示状態.png" width="400">

以下は、緑色をタップした後の状態です。

<img src="./画像/ダイアログサンプル 選択後の状態.png" width="400">


### ビジネスロジックを共通化する

次の例は、インプットとして与えられた価格と値引き率を使用して、値引き後の価格を計算するコンポーザブル関数です。

このように、画面に UI コンポーネントを表示しないコンポーザブル関数を作成する場合もあります。

```kotlin
@Composable
fun CalculateDiscount(price: Float, discountRate: Float): Float {
    val discount = price * discountRate
    return price - discount
}
```

コストのかからないビジネスロジックの場合は、コンポーザブル関数内で実行するのもありかと思います。


### 独自の状態管理を共通化する

状態とその状態の制御を一つのコンポーザブル関数にまとめる場合に有効です。

以下の例は、タップする度に ON と OFF が切り替わるボタンを実装しています。

```kotlin
@Composable
fun RememberToggleState(): Pair<Boolean, () -> Unit> {
    var isToggled by remember { mutableStateOf(false) }
    return Pair(isToggled) { isToggled = !isToggled }
}

@Composable
fun ExampleUsage() {
    val (isToggled, toggle) = RememberToggleState()
    Button(onClick = toggle) {
        Text(if (isToggled) "On" else "Off")
    }
}
```


### 多用する UI 要素を共通化する

次の例は、フォーム画面に表示される、テキスト入力可能な UI 要素を共通部品化する例です。

```kotlin
@Composable
fun MyScreen() {
    Column(modifier = Modifier.padding(innerPadding)) {
        Form()
    }
}

// テキストの入力が可能な共通部品
@Composable
fun textFieldWithState(): String {
    var text by remember { mutableStateOf("") }
    TextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Enter text") }
    )
    return text
}

// フォーム画面
@Composable
fun Form() {
    val username = textFieldWithState()
    val email = textFieldWithState()

    Button(onClick = { println("Username: $username, Email: $email") }) {
        Text("Submit")
    }
}
```

<img src="./画像/UI 要素の共通部品化の例.png" width="300">


