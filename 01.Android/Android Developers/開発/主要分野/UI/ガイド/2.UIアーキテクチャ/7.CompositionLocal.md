- [CompositionLocal](#compositionlocal)
  - [CompositionLocal とは](#compositionlocal-とは)
  - [既存の CompositionLocal の使用方法](#既存の-compositionlocal-の使用方法)
  - [独自の CompositionLocal の使用方法](#独自の-compositionlocal-の使用方法)
    - [CompositionLocal のデメリット](#compositionlocal-のデメリット)
    - [CompositionLocal の使いどころ](#compositionlocal-の使いどころ)
    - [CompositionLocal の作成](#compositionlocal-の作成)
    - [CompositionLocal に値を指定する](#compositionlocal-に値を指定する)
    - [CompositionLocal の使用](#compositionlocal-の使用)
    - [compositionLocalOf と staticCompositionLocalOf の違い](#compositionlocalof-と-staticcompositionlocalof-の違い)
      - [compositionLocalOf](#compositionlocalof)
      - [staticCompositionLocalOf](#staticcompositionlocalof)
  - [考慮すべき代替手段](#考慮すべき代替手段)
    - [明示的なパラメータを渡す](#明示的なパラメータを渡す)
    - [制御の反転](#制御の反転)
  - [具体的な使用例](#具体的な使用例)
    - [テーマ（Color / Typography など）](#テーマcolor--typography-など)
    - [ロガー（BaseActivity不要でログ出力）](#ロガーbaseactivity不要でログ出力)
    - [ナビゲーター（NavController をラップ）](#ナビゲーターnavcontroller-をラップ)
    - [権限状態（Permissions の結果をグローバルに共有）](#権限状態permissions-の結果をグローバルに共有)


# CompositionLocal

## CompositionLocal とは

コンポジション内でのみ有効なローカルプロパティの一種です。

通常のプロパティとの違いとしては、以下の点が上げられます。

- コンポジション内で明示的にパラメータを渡す必要がない。
  - パラメータを減らることができるため、コードが簡潔になる。
  - そのプロパティが必要ない中間レイヤーのコンポーザブルにまでパラメータを渡す手間が省ける。
- static ではない CompositionLocal を使用すれば、そのプロパティが変更された場合に、再コンポーズをトリガーすることができる。

定義済みの既存の CompositionLocal を使用することもできますし、自分で独自の CompositionLocal を定義することも可能です。

CompositionLocal のもう一つの重要な特性は、 **Activity の外部のファイルでも、** 同一コンポーザブル内部なら、その **プロパティが参照できる** 点です。

Jetpack Compose の導入以前のアーキテクチャでは、 Activity やそのスーパークラスである BaseActivity に保持する何らかのメンバーに、簡単にアクセスすることができました。しかし、 Jetpack Compose (宣言型の UI ) では、 Activity とは別のファイルに存在する UI からは、 Activity のメンバーにアクセスすることが難しくなりました。この欠点を補うのが、 CompositionLocal です。 CompositionLocal を使用すると、 「テーマ」「ユーザー情報」「ログイン状態」など、アプリ全体で共有したい “グローバル変数” のように使えます。


## 既存の CompositionLocal の使用方法

CompositionLocal の current 値は、 Composition の該当部分の祖先が設定する最も近い値を参照します。

CompositionLocal に新しい値を設定するには、 CompositionLocalProvider と、 provides 中置関数を使用します。 (詳細は後述します。)

```kotlin
@Composable
fun CompositionLocalExample() {
    // マテリアルテーマのデフォルトには ContentAlpha.high が設定されています。
    MaterialTheme {
        Column {
            Text("ここでは ContentAlpha.high が適用されます。")
            // LocalContentAlpha という定義済みのプロパティに
            // ContentAlpha.medium という値を設定します。
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                // このスコープ内で、 LocalContentAlpha.current を参照すると、
                // ContentAlpha.medium が取得できます。

                Text("ここでは ContentAlpha.medium が適用されます。")
                // これは、 Text コンポーザブル内部で、
                // LocalContentAlpha.current が参照されているためです。

                CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) {
                    DescendantExample()
                }
            }
        }
    }
}

@Composable
fun DescendantExample() {
    // ネストされたコンポーザブル関数内でも
    // 設定された値は有効です。
    Text("ContentAlpha.disabled が適用されます。")
}
```


## 独自の CompositionLocal の使用方法

CompositionLocal は、 Composition を通じてデータを暗黙的に伝えるためのツールです。

パラメータが横断的であり、実装の中間レイヤがその存在を意識すべきでない場合も、 CompositionLocal を活用できます。


### CompositionLocal のデメリット

CompositionLocal を使用すると、コンポーザブルの動作を理解することが難しくなります。暗黙的な依存関係ができるため、それを使用するコンポーザブルの呼び出し元で、すべての CompositionLocal の値が満たされていることを確認する必要があります。

さらに、この依存関係は Composition のどの部分でも変更される可能性があるため、この依存関係の信頼できる明確な情報源がなくなります。したがって、問題が起きたときにアプリをデバッグするのが難しくなります。 Composition をたどって current 値が設定された場所を確認する必要があるためです。 IDE の Find usages や Compose Layout Inspector などのツールを使用すれば、この問題を軽減するのに十分な情報を得ることができます。


### CompositionLocal の使いどころ

以下の場合は、 CompositionLocal を使用しない方が良いです。

- CompositionLocal に適切なデフォルト値が設定されていない。
  - 値が設定されていることを保証することは難しいため、不具合につながりやすいため。
- CompositionLocal を使用したいスコープが、ツリー構造ではない場合
  - CompositionLocal は、ツリー構造の子孫で使用されるときに効果を発揮しますが、それ以外の部分で使用すると、デメリットが目立ってしまいます。

不適切な利用の例として、特定の画面の ViewModel を保持する CompositionLocal を作成して、その画面のすべてのコンポーザブルが ViewModel への参照を取得してロジックを実行できるようにするというものがあります。特定の UI ツリーにあるすべてのコンポーザブルが ViewModel を認識する必要はないので、この方法は適切ではありません。コンポーザブルには、状態が下に流れ、イベントが登ってくるというパターンに沿って、必要な情報のみを渡すことをおすすめします。このやり方ならば、コンポーザブルは再利用しやすく、テストも容易になります。


### CompositionLocal の作成

CompositionLocal を作成するには、 `compositionLocalOf` もしくは `staticCompositionLocalOf` API を使用します。これらの違いについては、 [compositionLocalOf と staticCompositionLocalOf の違い](#compositionlocalof-と-staticcompositionlocalof-の違い) セクションで説明します。

```kotlin
// LocalElevations.kt file

data class Elevations(val card: Dp = 0.dp, val default: Dp = 0.dp)

// このインスタンスはアプリ内の全てのコンポーザブル関数からアクセス可能です。
val LocalElevations = compositionLocalOf { Elevations() }
```

LocalElevations というプロパティは、プロパティであるにも関わらず、頭文字が大文字で始まっています。これは、プロパティがグローバルにアクセス可能で、アプリ全体に影響を及ぼす可能性があります。そのため、重要な構成要素だということを認識できるように、大文字で始めるのが一般的です。


### CompositionLocal に値を指定する

provides 中置関数を使用して、値を指定します。

```kotlin
// MyActivity.kt file

class MyActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            // ダークテーマかどうかでエレベーションを計算する。
            val elevations = if (isSystemInDarkTheme()) {
                Elevations(card = 1.dp, default = 1.dp)
            } else {
                Elevations(card = 0.dp, default = 0.dp)
            }

            // LocalElevations に値を設定する。
            CompositionLocalProvider(LocalElevations provides elevations) {
                // コンテンツエリア

                // このスコープで LocalElevations.current を参照すると、 elevations インスタンスが取得できます。
            }
        }
    }
}
```


### CompositionLocal の使用

```kotlin
@Composable
fun SomeComposable() {
    // グローバル変数 LocalElevations に設定された Elevations オブジェクトから card プロパティを取得します。
    Card(elevation = LocalElevations.current.card) {
        // コンテンツ
    }
}
```


### compositionLocalOf と staticCompositionLocalOf の違い

`compositionLocalOf` と `staticCompositionLocalOf` の違いは、再コンポジションのタイミングです。


#### compositionLocalOf

- **動的な再コンポジション**が可能です。
- `compositionLocalOf` を使うと、その `CompositionLocal` の **値が変更された場合、その値を参照しているコンポーネントが、再コンポジションされます。** つまり、値が変更されると、変更に応じてUIも更新されます。
- 状態が頻繁に変わる場面や、コンポーネントに影響を与えたい場合に適しています。


#### staticCompositionLocalOf

- **静的な再コンポジション**が行われます。
- `staticCompositionLocalOf` は、値の変更に対して再コンポジションをトリガーしません。つまり、 **値が変わっても、コンポーネントは再コンポジションされません**。このため、頻繁に再コンポジションが必要でない（または避けたい）場合に使用します。
- 典型的なユースケースとしては、コンフィギュレーションや依存性注入など、アプリケーション全体で固定されることが期待される値を提供する場合に適しています。



## 考慮すべき代替手段

### 明示的なパラメータを渡す

コンポーザブル関数のパラメータとして、明示的にパラメータを渡すことを検討することができます。

もし、一つのコンポーザブルが肥大化した場合は、複数のコンポーザブルに分割することを検討してみてください。分割することで、渡す必要のないパラメータがあることに気が付くかもしれません。

また、分割することで、一つのコンポーザブル関数の明示的なパラメータの数が減り、コンポーザブルが扱いやすくなり、再利用性が高まることも期待できます。


### 制御の反転

コンポーザブルに不要な依存関係 (パラメータ) を渡さないようにするもう 1 つの方法は、制御の反転を使用することです。なんらかの処理を子孫が実行するのではなく、親側でそれを行います。

次のコードは、子孫がボタンタップ時の実装の詳細を知っています。これの制御を反転して、親が実装の詳細を握る方法を考えてみましょう。

```kotlin
@Composable
fun MyComposable(myViewModel: MyViewModel = viewModel()) {
    // ...
    MyDescendant(myViewModel)
}

@Composable
fun MyDescendant(myViewModel: MyViewModel) {
    Button(onClick = { myViewModel.loadData() }) {
        Text("Load data")
    }
}
```

次の実装では、 onClick リスナーを親で実装し、それを子に渡すことで、制御の反転を実現しています。  
こうすることで、子に ViewModel を渡す必要がなくなり、子の再利用性が高まるというメリットもあります。

```kotlin
@Composable
fun MyComposable(myViewModel: MyViewModel = viewModel()) {
    // ...
    ReusableLoadDataButton(
        onLoadClick = {
            myViewModel.loadData()
        }
    )
}

@Composable
fun ReusableLoadDataButton(onLoadClick: () -> Unit) {
    Button(onClick = onLoadClick) {
        Text("Load data")
    }
}
```

または、次のように、 @Composable コンテンツラムダを渡すことで、制御の反転を実現する方法もあります。

```kotlin
@Composable
fun MyComposable(myViewModel: MyViewModel = viewModel()) {
    // ...
    ReusablePartOfTheScreen(
        content = {
            Button(
                onClick = {
                    myViewModel.loadData()
                }
            ) {
                Text("Confirm")
            }
        }
    )
}

@Composable
fun ReusablePartOfTheScreen(content: @Composable () -> Unit) {
    Column {
        // ...
        content()
    }
}
```


## 具体的な使用例

### テーマ（Color / Typography など）

```kotlin
val LocalCustomColor = staticCompositionLocalOf { Color(0xFF6200EE) }

@Composable
fun AppTheme(content: @Composable () -> Unit) {
    CompositionLocalProvider(LocalCustomColor provides Color(0xFF3700B3)) {
        content()
    }
}

@Composable
fun ThemedText() {
    val color = LocalCustomColor.current
    Text("Hello Theme!", color = color)
}
```

`AppTheme` を `setContent` でラップすれば、どこでも使える！


### ロガー（BaseActivity不要でログ出力）

```kotlin
class Logger @Inject constructor() {
    fun log(msg: String) = Log.d("MyLogger", msg)
}

val LocalLogger = staticCompositionLocalOf<Logger> {
    error("Logger not provided")
}

@Composable
fun LoggingComposable() {
    val logger = LocalLogger.current
    LaunchedEffect(Unit) {
        logger.log("Composable表示中！")
    }
}
```

Activity の中で：

```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @Inject lateinit var logger: Logger

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            CompositionLocalProvider(LocalLogger provides logger) {
                LoggingComposable()
            }
        }
    }
}
```

Jetpack Compose を使用していない場合は、 BaseActivity などでロギングメソッドを実装することで、 Activity 内で、そのメソッドが使用可能でした。しかし、 Jetpack Compose を使用すると、 UI は、 Activity とは別のファイル内で Composable 関数によって定義されるため、 Composable 関数内から、 Activity にアクセスすることができなくなりました。よって、この CompositionLocal を使用する方法が一般的になっているようです。


### ナビゲーター（NavController をラップ）

```kotlin
val LocalNavController = staticCompositionLocalOf<NavController> {
    error("NavController not provided")
}

@Composable
fun MyScreen() {
    val navController = LocalNavController.current
    Button(onClick = { navController.navigate("next") }) {
        Text("次へ")
    }
}
```

Activity or NavHost Wrapper 側で渡す：

```kotlin
setContent {
    val navController = rememberNavController()
    CompositionLocalProvider(LocalNavController provides navController) {
        NavHost(navController, startDestination = "home") {
            composable("home") { MyScreen() }
            composable("next") { Text("次の画面") }
        }
    }
}
```


### 権限状態（Permissions の結果をグローバルに共有）

```kotlin
data class PermissionStatus(
    val hasCamera: Boolean,
    val hasLocation: Boolean
)

val LocalPermissionStatus = staticCompositionLocalOf<PermissionStatus> {
    error("PermissionStatus not provided")
}
```

Composable 側で：

```kotlin
@Composable
fun CameraView() {
    val permission = LocalPermissionStatus.current
    if (permission.hasCamera) {
        Text("カメラOK")
    } else {
        Text("カメラ使えません")
    }
}
```

Activity 側で状態チェックして流す：

```kotlin
setContent {
    val cameraGranted = remember { /* チェック処理 */ true }
    val locationGranted = remember { /* チェック処理 */ false }
    
    val permissions = PermissionStatus(cameraGranted, locationGranted)
    CompositionLocalProvider(LocalPermissionStatus provides permissions) {
        CameraView()
    }
}
```





