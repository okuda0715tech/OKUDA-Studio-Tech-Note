- [UI状態を保存する](#ui状態を保存する)
  - [UI ロジック](#ui-ロジック)
    - [シンプルなデータの例](#シンプルなデータの例)
    - [リストのスクロール状態の例](#リストのスクロール状態の例)
    - [ベストプラクティス](#ベストプラクティス)
    - [状態の復元を検証する](#状態の復元を検証する)
  - [ビジネスロジック](#ビジネスロジック)
    - [ベストプラクティス](#ベストプラクティス-1)
    - [SavedStateHandle API](#savedstatehandle-api)
    - [StateFlow](#stateflow)


# UI状態を保存する

## UI ロジック

### シンプルなデータの例

以下のコードは、アクティビティの再起動時、および、プロセスの再起動時に UI 状態を保持するサンプルです。 rememberSaveable を使用しています。

```kotlin
@Composable
fun ChatBubble(
    message: Message
) {
    var showDetails by rememberSaveable { mutableStateOf(false) }

    ClickableText(
        text = AnnotatedString(message.content),
        onClick = { showDetails = !showDetails }
    )

    if (showDetails) {
        Text(message.timestamp)
    }
}
```

https://github.com/okuda0715tech/Knowledge_Stock/assets/65774152/97644f86-0bea-4f74-b752-36103e7b6fe7


### リストのスクロール状態の例

```kotlin
@Composable
fun rememberLazyListState(
    initialFirstVisibleItemIndex: Int = 0,
    initialFirstVisibleItemScrollOffset: Int = 0
): LazyListState {
    return rememberSaveable(saver = LazyListState.Saver) {
        LazyListState(
            initialFirstVisibleItemIndex, initialFirstVisibleItemScrollOffset
        )
    }
}
```

`LazyListState.Saver` は、スクロール状態の保存と復元が可能なカスタムセーバーです。


### ベストプラクティス

当たり前の内容なので省略。


### 状態の復元を検証する

rememberSaveable で Compose 要素に保存された状態が、アクティビティまたはプロセスを再作成したときに正しく復元されることを検証できます。 [StateRestorationTester](https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/StateRestorationTester?_gl=1*1fk4248*_up*MQ..*_ga*MTk0MTI4MDI5NC4xNzE5OTgwMTIw*_ga_6HH9YJMN9M*MTcxOTk4MDExOS4xLjAuMTcxOTk4MDExOS4wLjAuMA..) など、これを行う専用の API があります。詳しくは、こちらの [テスト](https://developer.android.com/develop/ui/compose/testing?hl=ja&_gl=1*1fymm0g*_up*MQ..*_ga*MTgyNTM0NjkyMS4xNzE5ODk3NjM5*_ga_6HH9YJMN9M*MTcxOTg5NzYzOS4xLjAuMTcxOTg5NzYzOS4wLjAuMA..#verify_state_restoration) をご覧ください。


## ビジネスロジック

ビジネスロジックに必要であることから UI 要素の状態を ViewModel にホイスティングする場合は、 ViewModel の API を使用できます。


### ベストプラクティス

SavedStatehandl を使用したデータの復元には、少量のデータしか保存できません。そのため、データが大きくなりがちな画面 UI 状態を保存するのではなく、データ容量が小さくなりがちな UI 要素の状態を保存するのに使用するのが適切です。


### SavedStateHandle API

| 関数名         | レシーバ型       | 戻り値の型    |
| -------------- | ---------------- | ------------- |
| saveable()     | SavedStateHandle | T             |
| getStateFlow() | SavedStateHandle | StateFlow\<T> |

**saveable() API は 2024 年 7 月現在、試験運用中です。**

次のコードは、 saveable API の使用例です。

```kotlin
class ConversationViewModel(
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    var message by savedStateHandle.saveable(stateSaver = TextFieldValue.Saver) {
        mutableStateOf(TextFieldValue(""))
    }
        private set

    fun update(newMessage: TextFieldValue) {
        message = newMessage
    }

    /*...*/
}

val viewModel = ConversationViewModel(SavedStateHandle())

@Composable
fun UserInput(/*...*/) {
    TextField(
        value = viewModel.message,
        onValueChange = { viewModel.update(it) }
    )
}
```

TextFieldValue は、 androidx.compose.ui.text.input.TextFieldValue に定義されているものです。


### StateFlow

サンプルが難しいため、いったんパス。

