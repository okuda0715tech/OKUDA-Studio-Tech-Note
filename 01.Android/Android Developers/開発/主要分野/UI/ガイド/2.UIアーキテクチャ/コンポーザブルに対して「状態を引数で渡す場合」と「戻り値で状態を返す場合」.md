- [コンポーザブルに対して「状態を引数で渡す場合」と「戻り値で状態を返す場合」](#コンポーザブルに対して状態を引数で渡す場合と戻り値で状態を返す場合)
  - [概要](#概要)
  - [状態が引数で渡される場合のメリット](#状態が引数で渡される場合のメリット)
    - [単一責任の原則を守れる](#単一責任の原則を守れる)
    - [テストが容易になる](#テストが容易になる)
    - [カスタマイズ性の向上](#カスタマイズ性の向上)
    - [状態の管理場所のバリエーションが広がる](#状態の管理場所のバリエーションが広がる)


# コンポーザブルに対して「状態を引数で渡す場合」と「戻り値で状態を返す場合」

## 概要

状態は、コンポーザブル関数に対して、 「引数で渡される場合」 と 「戻り値で返される場合」 があります。一般的には、 「引数で渡される場合」 がほとんどです。

次のコードは、 「引数で渡される場合」 の例です。

```kotlin
@Composable
fun Parent() {
    var state by remember {
        mutableStateOf("")
    }

    Child(state)
}

@Composable
fun Child(state: String) {
    // Child コンポーザブルの引数に、状態が渡されています。
}
```

次のコードは、 「戻り値で返される場合」 の例です。

```kotlin
@Composable
fun Parent() {

    val state = Child()

}

@Composable
fun Child(): String {

    var state by remember {
        mutableStateOf("")
    }

    // Child コンポーザブルの戻り値で、状態が返されています。
    return state
}
```

このドキュメントでは、この二つについて、どのような違いがあるのかを説明してきます。


## 状態が引数で渡される場合のメリット

### 単一責任の原則を守れる

Jetpack Compose では、 Kotlin のコードで UI とビジネスロジックを記述することが可能です。そのため、各関数が 「 UI の描画」 と 「ビジネスロジックの実装」 という、複数の責任を負ってしまうことがあります。しかし、状態を引数で渡すことで、これらの責任を分離することが可能になります。

例えば、ボタンをタップすると、タップした回数をカウントし、その回数を画面に表示するボタンがあったとします。コードは次のようになります。

```kotlin
@Composable
fun Counter(count: Int, onIncrement: () -> Unit) {
    Button(onClick = onIncrement) {
        Text("Count: $count")
    }
}
```

これは、状態が Counter コンポーザブルの親で管理されているため、 Counter コンポーザブル自体は、状態 ( count ) を更新することはできません。つまり、ビジネスロジックを Counter コンポーザブル内に記述することができません。これにより、必然的に責任の分離が可能になります。

もし、同様の機能を 「状態を戻り値で返す」 コンポーザブル関数で実装した場合は、次のようになります。

```kotlin
@Composable
fun rememberCounter(): Int {

    var count by remember { mutableStateOf(0) }

    Button(onClick = { count++ }) {
        Text("Count: $count")
    }

    return count
}
```

この場合は、ビジネスロジックがコンポーザブル関数内に含まれていることがわかります。


### テストが容易になる

UI とビジネスロジックが分離されることにより、テスト用のデータ注入が簡単にできるようになったりして、テストが簡単になるようです。詳しくは、テストについて、もう少し勉強してみないと、わかりません。


### カスタマイズ性の向上

「状態」 や 「その状態の制御」 を引数で渡せると、何を渡すかによって、コンポーザブルの 「初期値」 や 「状態の制御ロジック」 をカスタマイズすることが可能です。

```kotlin
@Composable
fun Parent() {
    var count by remember { mutableStateOf(0) }

    Counter(
        count = count, // 状態
        onIncrement = { count++ } // 状態の制御
    )
}
```


### 状態の管理場所のバリエーションが広がる

状態は、コンポーザブル関数内に限らず、プレーンな状態クラスで管理したり、 ViewModel で管理することも可能です。そのようにするには、状態を 「コンポーザブル関数の引数で渡す」 必要があります。



