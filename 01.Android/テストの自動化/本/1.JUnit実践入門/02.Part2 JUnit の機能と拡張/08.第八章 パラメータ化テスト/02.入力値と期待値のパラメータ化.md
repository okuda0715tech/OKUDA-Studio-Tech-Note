- [02.入力値と期待値のパラメータ化](#02入力値と期待値のパラメータ化)
  - [最もシンプルな例](#最もシンプルな例)
  - [複数のテストメソッドがある場合の例](#複数のテストメソッドがある場合の例)
    - [最もシンプルな例](#最もシンプルな例-1)
    - [Enclosed テストランナーでクラスを分割した例](#enclosed-テストランナーでクラスを分割した例)
  - [複数のパラメータを持つテストメソッドの例](#複数のパラメータを持つテストメソッドの例)
  - [複数の同じ型のパラメータを持つテストメソッドの例](#複数の同じ型のパラメータを持つテストメソッドの例)
  - [任意のオブジェクトでパラメータをまとめる例](#任意のオブジェクトでパラメータをまとめる例)
  - [複数のテストパターンを配列として管理する例](#複数のテストパターンを配列として管理する例)
  - [外部リソースを使用した例](#外部リソースを使用した例)


# 02.入力値と期待値のパラメータ化

## 最もシンプルな例

本書の P.129 にあるリスト 8.8 の例を以下に示します。これは、パラメータ化テストの最もシンプルな例です。

```java
@RunWith(Theories.class)
public class ParameterizedTest {
    @DataPoint
    public static int INT_PARAM_1 = 3;
    @DataPoint
    public static int INT_PARAM_2 = 4;
    
    public ParameterizedTest() {
        System.out.println("初期化");
    }

    @Theory
    public void 引数を持つテストメソッド(int param) throws Exception {
        System.out.println("引数を持つテストメソッド(" + param + ")");
    }
}
```

- `@RunWith(Theories.class)`
  - パラメータ化テストを定義するテストクラスに、このアノテーションを付与します。
- `@DataPoint`
  - パラメータ化テストでパラメータとして与えたい変数に、このアノテーションを付与します。
- `@Theory`
  - パラメータ化テストでは、テストメソッドに `@Test` アノテーションではなく、 `@Theory` アノテーションを付与します。


## 複数のテストメソッドがある場合の例

### 最もシンプルな例

本書の P.130 にあるリスト 8.9 の例を以下に示します。

パラメータ化テストでは、テストクラス内に複数のテストメソッドが存在する場合には、パラメータの型で、どのパラメータがどのメソッドに使用されるのかが決定します。つまり、 @DataPoint が付与されたフィールドの型と、 @Theory が付与されたメソッドの引数の型が一致すると、そのフィールドがそのメソッドのパラメータとして使用されます。

```java
@RunWith(Theories.class)
public class ParameterizedTypeTest {
    @DataPoint
    public static int INT_PARAM_1 = 3;
    @DataPoint
    public static int INT_PARAM_2 = 4;
    @DataPoint
    public static String STRING_PARAM_1 = "Hello";
    @DataPoint
    public static String STRING_PARAM_2 = "World";

    @Theory
    public void 引数がint型のテストメソッド(int param) throws Exception {
        System.out.println("引数がint型のテストメソッド(" + param + ")");
    }

    @Theory
    public void 引数がString型のテストメソッド(String param) throws Exception {
        System.out.println("引数がString型のテストメソッド(" + param + ")");
    }
}
```


### Enclosed テストランナーでクラスを分割した例

前のセクションの最もシンプルな例では、パラメータの型さえ一致してしまえば、その値が、テストメソッドに使用されてしまいます。しかし、それでは、想定外のメソッドのパラメータに使用される可能性があります。これを解決するには、 Enclosed テストランナーを併用する方法があります。

本書の P.131 にあるリスト 8.10 の例を以下に示します。

```java
@RunWith(Enclosed.class)
public class EnclosedParameterizedTypeTest {
    @RunWith(Theories.class)
    public static class intのパラメータ化テスト {
        @DataPoint
        public static int INT_PARAM_1 = 3;
        @DataPoint
        public static int INT_PARAM_2 = 4;

        @Theory
        public void 引数がint型のテストメソッド(int param) throws Exception {
            System.out.println("引数がint型のテストメソッド(" + param + ")");
        }
    }

    @RunWith(Theories.class)
    public static class Stringのパラメータ化テスト {
        @DataPoint
        public static String STRING_PARAM_1 = "Hello";
        @DataPoint
        public static String STRING_PARAM_2 = "World";

        @Theory
        public void 引数がString型のテストメソッド(String param) throws Exception {
            System.out.println("引数がString型のテストメソッド(" + param + ")");
        }
    }
}
```


## 複数のパラメータを持つテストメソッドの例

本書の P.133 にあるリスト 8.11 の例を以下に示します。

テストメソッドが、複数のパラメータを持つ場合は、すべての組み合わせのテストが実行されます。

```java
@RunWith(Theories.class)
public class ParameterizedMultiParamsTest {
    @DataPoint
    public static int INT_PARAM_1 = 3;
    @DataPoint
    public static int INT_PARAM_2 = 4;
    @DataPoint
    public static String STRING_PARAM_1 = "Hello";
    @DataPoint
    public static String STRING_PARAM_2 = "World";

    @Theory
    public void テストメソッド(int intParam, String strParam) throws Exception {
        System.out.println("テストメソッド(" + intParam + ", " + strParam + ")");
    }
}
```

```
実行結果

テストメソッド(3, Hello)
テストメソッド(3, World)
テストメソッド(4, Hello)
テストメソッド(4, World)
```


## 複数の同じ型のパラメータを持つテストメソッドの例

本書の P.133 にあるリスト 8.12 の例を以下に示します。

テストメソッドが、複数の同じ型のパラメータを持つ場合も、全ての組み合わせのテストが実行されます。

```java
@RunWith(Theories.class)
public class ParameterizedMultiSameTypeParamsTest {
    @DataPoint
    public static int INT_PARAM_1 = 3;
    @DataPoint
    public static int INT_PARAM_2 = 4;

    @Theory
    public void テストメソッド(int x, int y) throws Exception {
        System.out.println("テストメソッド(" + x + ", " + y + ")");
    }
}
```

```
実行結果

テストメソッド(3, 3)
テストメソッド(3, 4)
テストメソッド(4, 3)
テストメソッド(4, 4)
```


## 任意のオブジェクトでパラメータをまとめる例

本書の P.133 にあるリスト 8.13 の例を以下に示します。

任意のオブジェクト (以下の例では、 Fixture オブジェクト) で、パラメータをまとめることも可能です。これにより、パラメータが意図せぬ場所で使用されるのを防ぐことができます。

```java
@RunWith(Theories.class)
public class CalculatorDataPointTest {
    @DataPoint
    public static Fixture PARAM_1 = new Fixture(3, 4, 7);
    @DataPoint
    public static Fixture PARAM_2 = new Fixture(0, 5, 5);
    @DataPoint
    public static Fixture PARAM_3 = new Fixture(-3, 1, -2);

    @Theory
    public void add(Fixture p) throws Exception {
        Calculator sut = new Calculator();
        assertThat(sut.add(p.x, p.y), is(p.expected));
    }

    static class Fixture {
        int x;
        int y;
        int expected;

        Fixture(int x, int y, int expected) {
            this.x = x;
            this.y = y;
            this.expected = expected;
        }
    }
}
```


## 複数のテストパターンを配列として管理する例

本書の P.135 にあるリスト 8.14 の例を以下に示します。

複数のテストパターンを配列として定義することも可能です。個別のフィールドとして定義するよりは、明確なグループ化により関連性が連想しやすいため、可読性が向上します。配列化可能なフィクスチャは、なるべく配列化した方が良いと思われます。

```java
@RunWith(Theories.class)
public class CalculatorDataPointsTest {

    @DataPoints
    public static Fixture[] PARAMs = { 
        new Fixture(3, 4, 7), 
        new Fixture(0, 5, 5), 
        new Fixture(-3, 1, -2), };

    @Theory
    public void add(Fixture p) throws Exception {
        Calculator sut = new Calculator();
        assertThat(sut.add(p.x, p.y), is(p.expected));
    }

    static class Fixture {
        int x;
        int y;
        int expected;

        Fixture(int x, int y, int expected) {
            this.x = x;
            this.y = y;
            this.expected = expected;
        }
    }
}
```


## 外部リソースを使用した例

テストフィクスチャを外部リソース化 (主にファイル化) することで、プログラムの変更なしにデータの変更ができるようになります。

本書の P.135 にあるリスト 8.15 の例を以下に示します。

```java
@RunWith(Theories.class)
public class CalculatorDataPointsYamlTest {

    @SuppressWarnings("unchecked")
    @DataPoints
    public static Fixture[] getParams() {
        InputStream in = CalculatorDataPointsYamlTest.class.getResourceAsStream("params.yaml");
        return ((List<Fixture>) new Yaml().load(in)).toArray(new Fixture[0]);
    }

    @Theory
    public void add(Fixture p) throws Exception {
        Calculator sut = new Calculator();
        assertThat(sut.add(p.x, p.y), is(p.expected));
    }

    public static class Fixture {
        public int x;
        public int y;
        public int expected;
    }
}
```

```yaml
!!seq [ 
!!ch08.CalculatorDataPointsYamlTest$Fixture
  { x: 3, y: 4, expected: 7 }, 
!!ch08.CalculatorDataPointsYamlTest$Fixture
  { x: 0, y: 5, expected: 5 }, 
!!ch08.CalculatorDataPointsYamlTest$Fixture
  { x: -3, y: 1, expected: -2 },
]
```



