- [StateFlow と SharedFlow](#stateflow-と-sharedflow)
  - [StateFlow](#stateflow)
    - [StateFlow , Flow , LiveData](#stateflow--flow--livedata)
  - [shareIn を使用したコールド Flow のホット化](#sharein-を使用したコールド-flow-のホット化)
    - [(※ 1 ) replay 引数の意味](#-1--replay-引数の意味)
  - [SharedFlow](#sharedflow)


# StateFlow と SharedFlow

StateFlow は Flow から状態の最新情報を適切に出力するための、また SharedFlow は Flow から値を複数のコンシューマに出力するための Flow API です。


## StateFlow

StateFlow は、現在の状態と新しい状態の更新をコレクタに出力する、状態を保持する監視可能な Flow です。現在の状態値は、 value プロパティを通じて読み取ることもできます。状態を更新してこの Flow に送信するには、 MutableStateFlow クラスの value プロパティに新しい値を割り当てます。

Android において、 StateFlow は状態を変更可能かつ監視可能に維持する必要のあるクラスに最適です。

[概要(Android での Kotlin Flow)](./1.概要(Android%20での%20Kotlin%20Flow).md) の例の続きで、 StateFlow を LatestNewsViewModel から公開し、 View が UI 状態の更新をリッスンできるようにすることで、値を変更しても画面の状態が正常に維持されるようにできます。

```kotlin
class LatestNewsViewModel(
    private val newsRepository: NewsRepository
) : ViewModel() {

    // バッキングプロパティが他のクラスから更新されるのを避けます
    private val _uiState = MutableStateFlow(LatestNewsUiState.Success(emptyList()))
    // UI は、この StateFlow から状態を収集します。
    val uiState: StateFlow<LatestNewsUiState> = _uiState

    init {
        viewModelScope.launch {
            newsRepository.favoriteLatestNews
                // 最新のお気に入りのニュースで UI を更新します。
                // MutableStateFlow の value プロパティに値を書き込みます。
                // flow に新しい要素を追加して、それを収集している全てのコレクターを更新します。
                .collect { favoriteNews ->
                    _uiState.value = LatestNewsUiState.Success(favoriteNews)
                }
        }
    }
}

// LatestNews 画面の異なる状態を表します。
sealed class LatestNewsUiState {
    data class Success(val news: List<ArticleHeadline>): LatestNewsUiState()
    data class Error(val exception: Throwable): LatestNewsUiState()
}
```

**flow ビルダーを使用して作成された 「コールド」 Flow とは異なり、 StateFlow は 「ホット」 です。つまり、この Flow から収集してもプロデューサコードはトリガーされません。**

**StateFlow は常にアクティブでメモリに常駐しており、ガベージコレクションの対象となるのはガベージコレクションルートからの参照が他にない場合のみです。**

新しいコンシューマは、 Flow からの収集を開始すると、ストリームの最後の状態とその後の状態を受け取ります。この動作は、 LiveData などの他の監視可能なクラスと同様です。

View による StateFlow のリッスンは、他の Flow の場合と同様、次のように行います。

```kotlin
class LatestNewsActivity : AppCompatActivity() {
    private val latestNewsViewModel = // getViewModel()

    override fun onCreate(savedInstanceState: Bundle?) {
        // ...

        // lifecycle scope で、コルーチンを開始します。
        lifecycleScope.launch {
            // repeatOnLifecycle は、 lifecycle が STARTED か (それ以上) になる度に毎回新しいコルーチンを生成し、その中で、ラムダブロックの処理を開始します。
            // lifecycle が STOPPED になった際に、コルーチンをキャンセルします。
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // flow をトリガーし、 value の変更の監視を開始します。
                // 監視 ( flow の収集) は、 lifecycle が STARTED になった際に開始し、 STOPPED になった際に停止します。
                latestNewsViewModel.uiState.collect { uiState ->
                    // 新しい value を収集した際の動作
                    when (uiState) {
                        is LatestNewsUiState.Success -> showFavoriteNews(uiState.news)
                        is LatestNewsUiState.Error -> showError(uiState.exception)
                    }
                }
            }
        }
    }
}
```

UI を更新する必要がある場合は、上記のように repeatOnLifecycle API を使用します。 launch または launchIn 拡張関数を使用して UI から直接 Flow を収集しないでください。 launch や launchIn 関数は、ビューが表示されていなくてもイベントを処理します。その結果、アプリがクラッシュする可能性があります。

repeatOnLifecycle API は、 androidx.lifecycle:lifecycle-runtime-ktx:2.4.0 以上のバージョンのライブラリでのみ使用できます。

Flow を StateFlow に変換するには、 [stateIn](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html) 中間演算子を使用します。 stateIn 中間演算子は、そのアップストリームにある flow を StateFlow に変換することで、ダウンストリームでは、 StateFlow ととして扱うことが可能になります。

StateFlows のテスト (特に stateIn で作成された場合) には、特別な注意が必要です。詳しくは、 Android での [Kotlin Flow のテスト](https://developer.android.com/kotlin/flow/test?hl=ja&_gl=1*nacfbe*_up*MQ..*_ga*MTMyNjk3MzAxOS4xNzIwNTM1Mjc3*_ga_6HH9YJMN9M*MTcyMDUzNTI3Ni4xLjAuMTcyMDUzNTI3Ni4wLjAuMA..#stateflows) のページをご覧ください。


### StateFlow , Flow , LiveData

StateFlow と LiveData は類似しています。どちらも監視可能なデータホルダー クラスであり、アプリ アーキテクチャでは同様のパターンで使用されます。

ただし、StateFlow と LiveData の動作は異なります。

- StateFlow では初期状態をコンストラクタに渡す必要がありますが、LiveData ではその必要はありません。
- LiveData.observe() では、ビューが STOPPED 状態になるとコンシューマが自動的に登録解除されますが、 StateFlow またはその他の Flow からの収集では、収集は自動的には停止されません。同じ動作を実現するには、 Lifecycle.repeatOnLifecycle ブロックからフローの収集を制御する必要があります。


## shareIn を使用したコールド Flow のホット化

Flow のコールドとホットの違いについては、 [こちら](./Flow%20のコールドとホットの違い.md) を参照してください。

StateFlow は、 「ホット」 Flow です。つまり、収集されている間やガベージコレクションルートからの参照が他に存在する場合は、メモリ内に常駐します。コールド Flow をホットにするには、 shareIn 演算子を使用します。

Kotlin Flow で作成した callbackFlow を例にとると、各コレクタで新しい Flow を作成する代わりに、 shareIn を使用することで Firestore から取得したデータをコレクタ間で共有できます。それには、次の情報を渡す必要があります。

- Flow の共有に使用する CoroutineScope 。このスコープは、共有 Flow を必要な期間存続させるために、どのコンシューマよりも長く存続させる必要があります。
- 新しいコレクタそれぞれに対してリプレイするアイテムの数。 (※ 1 )
- 開始動作ポリシー。

```kotlin
class NewsRemoteDataSource(...,
    private val externalScope: CoroutineScope,
) {
    val latestNews: Flow<List<ArticleHeadline>> = flow {
        ...
    }.shareIn(
        externalScope,
        replay = 1,
        started = SharingStarted.WhileSubscribed()
    )
}
```

この例では、latestNews Flow は、最後に出力されたアイテムを新しいコレクタにリプレイし、 externalScope とアクティブなコレクタが存在する限りアクティブな状態を維持します。

開始ポリシーには、以下のものがあります。

- SharingStarted.WhileSubscribed()
  - アクティブなサブスクライバが存在する間は、アップストリーム プロデューサをアクティブに保ちます。
- SharingStarted.Eagerly
  - プロデューサをすぐに開始する。
- SharingStarted.Lazily
  - 最初のサブスクライバが現れたときに共有を開始し、 Flow を永続的にアクティブに保つ。

externalScope のパターンについて詳しくは、 [こちらの記事 (※1)](https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad) をご覧ください。

※1 : Coroutines & Patterns for work that shouldn’t be cancelled


### (※ 1 ) replay 引数の意味

shareIn 関数の引数である replay は、ホット Flow が過去に放出した最新の値をどれだけ保持するかを指定します。具体的には、以下のような効果があります。

- replay = 0 の場合
  - ホット Flow は過去の値を保持しません。新しいサブスクライバーは、サブスクライブした後に放出された値のみを受け取ります。
- replay が 0 より大きい場合
  - ホット Flow は指定された数の最新の値を保持します。新しいサブスクライバーは、サブスクライブ時に保持されている最新の値をすべて受け取ります。

例えば、以下のコードは replay を 2 に設定しています。これにより、新しいサブスクライバーは最新の 2 つの値を受け取ります。

```kotlin
val hotFlow = coldFlow.shareIn(
    scope = CoroutineScope(Dispatchers.Default),
    started = SharingStarted.WhileSubscribed(),
    replay = 2
)
```

この例では、 coldFlow が `Flow<Int>` であると仮定しています。 hotFlow はホットな Flow になり、過去の 2 つの値を新しいサブスクライバーに提供します。


## SharedFlow

shareIn 関数からは SharedFlow が返されます。これはホット Flow で、そこからの収集を行うすべてのコンシューマに値を出力します。 SharedFlow は、 StateFlow を一般化して詳細な設定を可能にしたものです。

SharedFlow は、 shareIn を使用せずに作成できます。以下の例では、 MutableSharedFlow を使用して作成しています。

SharedFlow を使用すると、アプリ内の複数の部分に一定時間ごとにイベント (ティック) を送信して、定期的な動作を行うことが可能になります。例えば、一定時間ごとに複数個所でコンテンツを更新するといったことが可能になります。

```kotlin
// アプリのコンテンツを更新する必要があるタイミングを一元管理するクラス
class TickHandler(
    private val externalScope: CoroutineScope,
    private val tickIntervalMs: Long = 5000
) {
    // 他のクラスから flow の要素が発行されるのを避けるためのバッキングプロパティ
    private val _tickFlow = MutableSharedFlow<Unit>(replay = 0)
    val tickFlow: SharedFlow<Event<String>> = _tickFlow

    init {
        externalScope.launch {
            while(true) {
                _tickFlow.emit(Unit)
                delay(tickIntervalMs)
            }
        }
    }
}

class NewsRepository(
    ...,
    private val tickHandler: TickHandler,
    private val externalScope: CoroutineScope
) {
    init {
        externalScope.launch {
            // ティックの更新を受け取る
            // この例では、 Flow の要素に発行されるデータが Unit であるため、このラムダブロックは、単に一定間隔ごとに呼ばれるコールバックの役割です。
            tickHandler.tickFlow.collect {
                refreshLatestNews()
            }
        }
    }

    suspend fun refreshLatestNews() { ... }
    
}
```

SharedFlow の動作は、次の方法でカスタマイズできます。

- replay
  - 以前に出力された複数の値を新しいサブスクライバに再送信できます。
- onBufferOverflow
  - バッファが送信アイテムでいっぱいになったときのポリシーを指定できます。
    - BufferOverflow.SUSPEND : 呼び出し元を停止します。 (デフォルト値)
    - DROP_LATEST
    - DROP_OLDEST
  - subscriptionCount プロパティ
    - アクティブなコレクタの数を示す。
    - ビジネスロジックを最適化するのに役立ちます。
  - resetReplayCache
    - Flow に送信された最新情報をリプレイしない場合に使用します。





