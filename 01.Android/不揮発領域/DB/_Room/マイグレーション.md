<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [マイグレーション](#マイグレーション)
	- [基本形](#基本形)
	- [マイグレーションSQLサンプル](#マイグレーションsqlサンプル)
		- [テーブルの新規作成](#テーブルの新規作成)
		- [列の追加](#列の追加)
		- [テーブルの削除](#テーブルの削除)
		- [テーブル名の変更](#テーブル名の変更)
		- [デフォルト値の設定](#デフォルト値の設定)
		- [データ移行サンプル](#データ移行サンプル)
	- [既存のSQLiteDatabaseにRoomを適用する](#既存のsqlitedatabaseにroomを適用する)

<!-- /TOC -->


# マイグレーション

## 基本形

以下の1〜4の手順を実施することで、テーブルの定義更新を実施できる。

1. DDL（データ定義言語：データ構造を定義する言語）を記述したMigrationオブジェクトを準備する。
2. 準備したMigrationオブジェクトをデータベースのビルド時に`addMigrations(Migration)`メソッドで追加する。

**AppDatabaseSingleton.java**

```Java
public class AppDatabaseSingleton {

    private static AppDatabase database;

    private AppDatabaseSingleton() {
        // do nothing.
    }

    // Migrationオブジェクトを準備する
    // new Migration(変更前のバージョン, 変更後のバージョン)
    static final Migration MIGRATION_1_2 = new Migration(1, 2) {
        // migrateメソッドは、addMigrationsメソッドを呼び出した直後には呼び出されず、
        // その後、SELECTやDELETEなどのSQLを実行した際に、SQL実行の直前に呼び出される。
        @Override
        public void migrate(@NonNull SupportSQLiteDatabase database) {
            database.execSQL("CREATE TABLE `Fruit` (`id` INTEGER NOT NULL, `name` TEXT, PRIMARY KEY(`id`))");
        }
    };

    public static AppDatabase getInstance(Context context) {
        if (database == null) {
            database = Room.databaseBuilder(context,
                    AppDatabase.class, "database-name")
                    // Migrationオブジェクトを渡す
                    .addMigrations(MIGRATION_1_2)
                    // 複数のマイグレーションがある場合
                    // .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
                    .build();
        }
        return database;
    }
}
```


3. DDLに合わせてEntityオブジェクトを準備する。

**Fruit.java**

```Java
@Entity
public class Fruit {
    @PrimaryKey
    public int id;

    public String name;
}
```


4. `@Database`アノテーションの`version`を変更したいバージョンに上げる。

**AppDatabase.java**

```Java
// テーブルの新規作成や削除がある場合は、@Databaseアノテーションのentities属性の追加や削除も忘れずに！
@Database(entities = {User.class, Fruit.class}, version = 3)
public abstract class AppDatabase.java extends RoomDatabase {
    public abstract UserDao userDao();
}
```


## マイグレーションSQLサンプル

### テーブルの新規作成

```java
// プライマリーキーの指定方法1
"CREATE TABLE `Fruit` (`id` INTEGER NOT NULL, `name` TEXT, PRIMARY KEY(`id`))"

// プライマリーキーの指定方法2
"CREATE TABLE `Fruit` (`id` INTEGER PRIMARY KEY NOT NULL, `name` TEXT)"
```


### 列の追加

```java
"ALTER TABLE `User` ADD COLUMN `address` TEXT"
```


### テーブルの削除

```java
"DROP TABLE User"
```


### テーブル名の変更

```java
"ALTER TABLE User1 RENAME TO User2"
```


### デフォルト値の設定

```java
"CREATE TABLE `AppTable`
(`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
`name` TEXT NOT NULL DEFAULT 'AAA',
`parent_item_id` INTEGER NOT NULL DEFAULT 1)"
```

テーブル名や列名はバッククォーテーション（「`」Shift + @）で囲むのに対し、デフォルト値はシングルクォーテーション（「'」Shift + 7）で囲む。

INTEGER型の場合は、シングルクォーテーションで囲まない。


### データ移行サンプル

テーブルに新しい列を追加した時に、デフォルト値を指定しつつ古いテーブルから新しいテーブルにデータを流し込む際などに役に立つ。

```java
static final Migration MIGRATION_2_3 = new Migration(2, 3) {
		@Override
		public void migrate(SupportSQLiteDatabase database) {
				database.execSQL("CREATE TABLE new_Song (" +
								// Entityに「@PrimaryKey」アノテーションがついている列には、
								// ここに「PRIMARY KEY」が指定されていても「NOT NULL」が必要です。
								"id INTEGER PRIMARY KEY NOT NULL," +
								"name TEXT," +
								"tag TEXT NOT NULL DEFAULT '')");
				database.execSQL("INSERT INTO new_Song (id, name, tag) " +
								"SELECT id, name, tag FROM Song");
				database.execSQL("DROP TABLE Song");
				database.execSQL("ALTER TABLE new_Song RENAME TO Song");
		}
};
```


## 既存のSQLiteDatabaseにRoomを適用する

すでにSQLiteDatabaseを使用しているプロジェクトにRoomを追加する場合は、Entityの定義さえ合っていればそのまま既存のDBを使用できます。
注意する点としては、DBのスキーマバージョンを上げることと、上げたバージョンに対応する空のMigrationを定義することです。

例えば、元のスキーマバージョンが5の場合は
- Room適用時にバージョンを6に上げる
- 5から6へのMigrationクラスを定義する
- Migration5_6#migrateメソッドの中に処理は書かない

となります。
Roomが管理用のマスタテーブルを追加することでスキーマの構成が変わるので、バージョンを上げる必要があるためです。
