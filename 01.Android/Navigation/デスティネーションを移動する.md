<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [デスティネーションを移動する](#デスティネーションを移動する)
  - [実装の概要](#実装の概要)
  - [NavController の取得方法](#navcontroller-の取得方法)
    - [FragmentContainerView を使用した場合の NavController の取得方法](#fragmentcontainerview-を使用した場合の-navcontroller-の取得方法)
  - [navigate メソッドにアクションを渡して呼び出す方法](#navigate-メソッドにアクションを渡して呼び出す方法)
    - [アクションのIDを直接指定する場合](#アクションのidを直接指定する場合)
    - [Safe Args を使用してアクションを取得する場合](#safe-args-を使用してアクションを取得する場合)
  - [navigate メソッドに遷移先デスティネーションのIDを渡して呼び出す方法](#navigate-メソッドに遷移先デスティネーションのidを渡して呼び出す方法)
  - [ボタンタップ時のデスティネーション遷移は略式の実装が可能](#ボタンタップ時のデスティネーション遷移は略式の実装が可能)
  - [トップアプリバーを使用した遷移方法](#トップアプリバーを使用した遷移方法)
    - [例 1 onNavDestinationSelected() メソッドを使用](#例-1-onnavdestinationselected-メソッドを使用)
  - [ボトムナビゲーションなど、他の一般的な UI コンポーネントの遷移方法](#ボトムナビゲーションなど他の一般的な-ui-コンポーネントの遷移方法)
  - [戻るボタン・上へボタンの動作](#戻るボタン上へボタンの動作)
  - [バックスタックから削除しながら遷移する](#バックスタックから削除しながら遷移する)
<!-- TOC END -->


# デスティネーションを移動する

## 実装の概要

デスティネーションを移動する大まかな流れは、以下の通りです。

1. `NavController` を取得する。
2. `NavController` の `navigate()` メソッドに `アクション` を渡すか、もしくは、 `移動先のデスティネーションID` を渡してメソッドを呼び出す。（※１）

（※１）  
`navigate()` メソッドのパラメータには、 `アクション` を渡すことが推奨されます。その理由は以下の通りです。

- Android Studio のナビゲーショングラフエディタで、デスティネーション同士の接続を視覚化できるため。
- Safe Args を使用した実装が可能になり、その恩恵を受けることができようになるため。（コンパイル時の安全性が高まる）
- デスティネーション間の遷移をアニメーション化することが可能になるため。


## NavController の取得方法

`NavController` の取得方法は、以下の4通りです。

- NavHostFragment.findNavController(Fragment)
- Navigation.findNavController(Activity, @IdRes int viewId)
- Navigation.findNavController(View)
- navHostFragment.getNavController()


### FragmentContainerView を使用した場合の NavController の取得方法

`FragmentContainerView` を使用しする場合は、アクティビティの `onCreate()` から
`Navigation.findNavController(Activity, @IdRes int)` で `NavController` を取得することはできません。  
以下の方法で、 `NavHostFragment` から直接 `NavController` を取得してください。

```java
// in Activity
FragmentManager supportFragmentManager = getSupportFragmentManager();
NavHostFragment navHostFragment = (NavHostFragment) supportFragmentManager.findFragmentById(R.id.nav_host_fragment);
NavController navController;
if (navHostFragment != null) {
    navController = navHostFragment.getNavController();
}
```


## navigate メソッドにアクションを渡して呼び出す方法

### アクションのIDを直接指定する場合

```java
Navigation.findNavController(v).navigate(R.id.action_nestedGraphBlankFragment1_to_nestedGraphBlankFragment2);
```


### Safe Args を使用してアクションを取得する場合

#### 準備

プロジェクトのbuild.gradleファイルに以下を追加します。

```javascript
buildscript {
    repositories {
        google()
    }
    dependencies {
        def nav_version = "2.3.5"
        classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"
    }
}
```

アプリ、または、モジュールのbuild.gradleファイルに以下を追加します。

```javascript
// Javaのみ使用する場合
apply plugin: "androidx.navigation.safeargs"

// Kotlinも使用する場合
apply plugin: "androidx.navigation.safeargs.kotlin"
```

gradle.propertiesファイルに以下を追加します。

```javascript
android.useAndroidX=true
```


#### サンプル＆解説

```java
@Override
public void onClick(View view) {
    // SpecifyAmountFragmentDirectionsは、Safe Argsによって自動生成されたクラス
    NavDirections action =
        SpecifyAmountFragmentDirections
            .actionSpecifyAmountFragmentToConfirmationFragment();
    Navigation.findNavController(view).navigate(action);
}
```

上記は、遷移元（アクション送信側）のクラス名が `SpecifyAmountFragment` 、  
遷移先（アクション受信側）のクラス名が `ConfirmationFragment` である場合のサンプルです。

Safe Args を有効にすると、以下のことが行われます。

- アクションの送信側デスティネーションごとに、末尾に `Directions` のついたクラスを自動生成します。
- 自動生成されたクラスには、定義したアクションにもとづいた `送信側クラス名 To 受信側クラス名` の名前のメソッドが生成されます。

自動生成された `送信側クラス名 To 受信側クラス名` のメソッドを呼び出すと、 `NavDirections` オブジェクトが返されます。  
返された `NavDirections` オブジェクトを `NavController` の `navigate(NavDirections)` メソッドに渡します。  
こうすることで、デスティネーションを移動することができます。


## navigate メソッドに遷移先デスティネーションのIDを渡して呼び出す方法

他の `navigate()` メソッドのサンプルを参照してください。  
そのメソッドのパラメータに、遷移先デスティネーションIDを渡すように変更するだけで実装完了です。


## ボタンタップ時のデスティネーション遷移は略式の実装が可能

```java
button.setOnClickListener(Navigation.createNavigateOnClickListener(R.id.next_fragment, null));
```


## トップアプリバーを使用した遷移方法

### 例 1 onNavDestinationSelected() メソッドを使用

```java
public class MainActivity extends AppCompatActivity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);

      Toolbar toolbar = findViewById(R.id.toolbar);
      setSupportActionBar(toolbar);
      DrawerLayout drawer = findViewById(R.id.drawer_layout);

      NavigationView navigationView = findViewById(R.id.nav_view);
      mAppBarConfiguration = new AppBarConfiguration.Builder(
        R.id.nav_position_edit_screen,
        R.id.nav_use_status_management_screen,
        R.id.nav_announcements_screen,
        R.id.nav_settings_screen,
        R.id.nav_twitter_screen,
        R.id.nav_inquiry_screen,
        R.id.nav_privacy_policy_screen)
        .setOpenableLayout(drawer)
        .build();
      NavController navController = Navigation.findNavController(activity, R.id.nav_host_fragment);
      NavigationUI.setupActionBarWithNavController(this, navController, mAppBarConfiguration);
      NavigationUI.setupWithNavController(navigationView, navController);

      MenuItem menuItem = navigationView.getMenu().getItem(4);
      // パラメータで指定したメニューアイテムを選択された状態の表示にする。
      menuItem.setChecked(true);
      // 画面を遷移する。
      NavigationUI.onNavDestinationSelected(menuItem, navController);
  }

  @Override
  public boolean onSupportNavigateUp() {
    navController = Navigation.findNavController(this, R.id.nav_host_fragment);
    return NavigationUI.navigateUp(navController, mAppBarConfiguration)
          || super.onSupportNavigateUp();
  }
}
```

**activity_main.xml**

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.drawerlayout.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/drawer_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:openDrawer="start">

    <include layout="@layout/app_bar_main" />

    <com.google.android.material.navigation.NavigationView
        android:id="@+id/nav_view"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:fitsSystemWindows="false"
        app:headerLayout="@layout/nav_header_main"
        app:menu="@menu/activity_main_drawer" />

</androidx.drawerlayout.widget.DrawerLayout>
```


## ボトムナビゲーションなど、他の一般的な UI コンポーネントの遷移方法

（後日記載予定）


## 戻るボタン・上へボタンの動作

「上へ」ボタンをタップした場合は、 `NavController.navigateUp()` が呼ばれます。  
「戻る」ボタンをタップした場合は、 `NavController.popBackStack()` が呼ばれます。  
これらのメソッドが呼ばれ、バックスタックの最上部のデスティネーションが削除（ポップ）されます。

`NavController.popBackStack()` は、正常にポップされて別のデスティネーションに戻ったかどうか  
を示すブール値を返します。 `false` が返される最も一般的なケースは、グラフの開始デスティネーションを  
手動でポップした場合です。

このメソッドが `false` を返すと、`NavController.getCurrentDestination()` は `null` を返します。  
新しいデスティネーションに移動するか、アクティビティに対して finish() を呼び出してポップを処理する  
必要があります。以下の例をご覧ください。

```java
...

if (!navController.popBackStack()) {
    // Call finish() on your Activity
    finish();
}
```


## バックスタックから削除しながら遷移する

バックスタックから自分自身のデスティネーション、及び、それ以前のデスティネーションを削除しながら  
別のデスティネーションへ遷移することができます。

例えば、 [ A -> B -> C ] と遷移した後、 A ～ C までを削除しつつ、 D へ遷移したい場合に使用します。  
これは例えば、 A ～ C までがログインフローで、 D 以降が本線の場合に使用されます。
その場合は、以下のようなアクションを定義してください。

```xml
<fragment android:id="@+id/c"
    <action
        android:id="@+id/action_c_to_d"
        app:destination="@id/d"
        app:popUpTo="@id/A"
        app:popUpToInclusive="true" />
/>
```

`app:popUpTo` は、パラメータで指定したデスティネーションの一つ上のデスティネーションまで  
を削除（ポップ）することを意味します。  
`app:popUpToInclusive="true"` は、パラメータで指定したデスティネーションも含めて削除（ポップ）  
することを意味します。

また、この「バックスタックから削除しながら遷移する」方法を使用することで、  
 [ A -> B -> C -> A -> B -> C -> A ] のような「循環型の遷移」を重複を避けて遷移することが可能になります。
