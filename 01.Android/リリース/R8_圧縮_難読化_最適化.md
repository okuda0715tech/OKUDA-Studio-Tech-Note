<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [R8\_圧縮\_難読化\_最適化](#r8_圧縮_難読化_最適化)
  - [R8 とは](#r8-とは)
  - [R8 の圧縮、難読化、最適化機能を有効化する](#r8-の圧縮難読化最適化機能を有効化する)
    - [ルールファイル（proguard-rules.pro）の格納先](#ルールファイルproguard-rulesproの格納先)
  - [すべてのルールファイルを一つのファイルに統合する](#すべてのルールファイルを一つのファイルに統合する)
  - [新しいルールを作成する](#新しいルールを作成する)
  - [コードの圧縮](#コードの圧縮)
    - [コードの圧縮アルゴリズム](#コードの圧縮アルゴリズム)
    - [keep ルールによるコード圧縮抑制](#keep-ルールによるコード圧縮抑制)
    - [Keep アノテーションによるコード圧縮抑制](#keep-アノテーションによるコード圧縮抑制)
    - [予期せぬコード圧縮に対処する](#予期せぬコード圧縮に対処する)
  - [リソース圧縮](#リソース圧縮)
    - [保持するリソース、破棄するリソースのカスタマイズ](#保持するリソース破棄するリソースのカスタマイズ)
    - [破棄するリソースをなぜ直接削除しないのか](#破棄するリソースをなぜ直接削除しないのか)
  - [コードの難読化](#コードの難読化)
    - [難読化のメリット](#難読化のメリット)
    - [難読化後の例](#難読化後の例)
    - [keep ルール、 keep アノテーションによるコード難読化抑制](#keep-ルール-keep-アノテーションによるコード難読化抑制)
    - [難読化されたスタックトレースのデコード](#難読化されたスタックトレースのデコード)
      - [Google Play Console のエラーログをデコードする](#google-play-console-のエラーログをデコードする)
      - [Firebase Crashlytics のエラーログをデコードする](#firebase-crashlytics-のエラーログをデコードする)
  - [コードの最適化](#コードの最適化)
  - [ルールファイルを使用した keep の方法](#ルールファイルを使用した-keep-の方法)
    - [パッケージ指定でその配下のクラスを全て keep 対象とする](#パッケージ指定でその配下のクラスを全て-keep-対象とする)
  - [R8 で発生した問題の分析を行う](#r8-で発生した問題の分析を行う)
    - [削除されたコードのレポートを確認する](#削除されたコードのレポートを確認する)
    - [保持 ( keep ) されたコードのレポートを生成する](#保持--keep--されたコードのレポートを生成する)
    - [アプリログを解析する](#アプリログを解析する)
<!-- TOC END -->


# R8_圧縮_難読化_最適化

## R8 とは

`R8` とは、 `ProGuard` の後継となる、 **難読化、最適化、圧縮、コンパイルツール** です。  
ProGuard は、 GuardSquare 社が開発していますが、 R8 は、 Google 社が開発しています。  
R8 は Java バイトコードを Android プラットフォームで実行可能な DEX 形式に変換します。

Android Studio 3.4 または Android Gradle プラグイン 3.4.0 以上を使用する場合、
R8 がデフォルトのコンパイラになります。


## R8 の圧縮、難読化、最適化機能を有効化する

新しいプロジェクトを作成した場合、圧縮、難読化、コードの最適化はデフォルトでは有効になっていません。  
圧縮、難読化、最適化を有効にするには、プロジェクト レベルの build.gradle ファイルに以下を記述します。

```java
android {
  buildTypes {
    // リリースビルドでのみ設定を有効にします
    release {
      // コード圧縮、難読化、コードの最適化を有効にします
      minifyEnabled true

      // リソース圧縮を有効にします
      // 【注意】
      // いったん minifyEnabled を true にしてビルドを行ってから
      // shrinkResources true を記述して、再度ビルドを行うこと。
      // 理由は、 minifyEnabled true を実行した時にルールファイル proguard-rules.pro を
      // 編集しなければならない可能性があるためです。
      shrinkResources true

      // ProGuard ルールファイルを読み込みます。 R8 でも ProGuard ルールファイルを参照します
      proguardFiles
          // 以下のうち、「最適化あり」もしくは「最適化なし」のどちらかの記述だけを残すこと。
          // 最適化あり
          getDefaultProguardFile('proguard-android-optimize.txt'),
          // 最適化なし
          getDefaultProguardFile('proguard-android.txt'),
          // ルールファイル (最適化ありの場合も、なしの場合も必要)
          'proguard-rules.pro'
    }
  }
  ...
}
```

通常は、リリースビルドのみで機能を有効化します。その理由は、プロジェクトのビルド時間が長くなったり、  
保持 (保持については後述) するコードのカスタマイズが十分でない場合にバグが発生する可能性があるためです。


### ルールファイル（proguard-rules.pro）の格納先

ルールファイルは、 次のパスの直下に格納されています。

`{プロジェクト名}\app`


## すべてのルールファイルを一つのファイルに統合する

R8 がプロジェクトのビルド時に適用するすべてのルールを結合したファイルを出力するには、  
モジュールの proguard-rules.pro ファイルに以下を追加します。

```
// フォルダ名やファイルを出力する場所は任意に指定することができます
-printconfiguration E:/xxx/yyy/full-r8-config.txt
```

一つのファイルに統合することで見やすくなり、メンテナンスがしやすいというメリットがあります。


## 新しいルールを作成する

特定のビルドタイプ、特定のプロダクトフレーバーに対して、追加のルールを作成し、適用するこができます。

```java
android {
  buildTypes {
    release {
      minifyEnabled true
      proguardFiles
          getDefaultProguardFile('proguard-android-optimize.txt'),
          // 特定のビルドタイプにルールを追加したい場合は、以下のファイル内に
          // ルールを追加します。
          'proguard-rules.pro'
    }
  }

  flavorDimensions "version"
  productFlavors {
    flavor1 {}
    flavor2 {
      // 特定のプロダクトフレーバーにルールを追加したい場合は、以下のように
      // 新しいルールファイルを作成して、その中にルールを追加します。
      proguardFile 'flavor2-rules.pro'
    }
  }
}
```


## コードの圧縮

`minifyEnabled` プロパティを `true` に設定すると、R8 によるコードの圧縮が有効になります。  
コードの圧縮とは、実行時に到達しないコードを R8 が判断して削除するプロセスです。

「コードを削除する」 という観点では、コードの圧縮はコードの最適化と似ていますが、  
コードの圧縮では、特に、 **参照されないクラス、参照されないフィールド、呼び出されないメソッド  
の三つについての削除を行います。**


### コードの圧縮アルゴリズム

R8 は、 `Activity` や `Service` などのアプリのエントリーポイントをすべてを特定します。  
そこから呼び出されているメソッドを順にたどっていき、すべて辿り終えたときに、  
一度も到達しなかったコードを 「到達不能」 とみなし、アプリから削除します。


### keep ルールによるコード圧縮抑制

R8 は、プロジェクトの R8 構成ファイルの `-keep` ルールを通じてエントリポイントを特定します。  
つまり、アプリの圧縮時に R8 が破棄してはならないクラスを keep ルールで指定すると、  
R8 はそれらのクラスをアプリへの想定されるエントリポイントとみなし、アプリにそのクラスを残します。

`-keep` ルールの設定例

```
-keep public class MyClass
```


### Keep アノテーションによるコード圧縮抑制

保持するコードに `@Keep` アノテーションを追加することもできます。

クラスに `@Keep` を追加すると、クラス全体がそのまま保持されます。

メソッドまたはフィールドに `@Keep` を追加すると、メソッドまたはフィールド  
（およびその名前）に加え、クラス名もそのまま保持されます。このアノテーションを使用できるのは、  
AndroidX Annotations Library を使用している場合と、 build.gradle に ProGuard ルールファイルを  
追加した場合だけです。


### 予期せぬコード圧縮に対処する

使用されていないコードのみを R8 で削除する場合、通常はデフォルトの ProGuard ルールファイル  
( proguard-android- optimize.txt ) で十分です。ただし、R8 で正確に分析することが困難な場合もあり、  
アプリが実際に必要とするコードが削除されてしまうこともあります。  
以下のようなケースでは、R8 が誤ってコードを削除する可能性があります。

- アプリが Java Native Interface（ JNI ）からメソッドを呼び出す場合
- アプリが実行時にコードを検索する場合（リフレクションの使用時など）


## リソース圧縮

`shrinkResources` プロパティを `true` に設定すると、R8 によるリソースの圧縮が有効になります。  
リソースの圧縮とは、実行時に必要のないリソースを R8 が判断して削除するプロセスです。

リソースの圧縮は、必ずコードの圧縮と連動して機能します。コード圧縮ツールによって未使用の  
コードがすべて削除された後、アプリがもう使用しなくなったリソースを特定できます。

これは、リソースが含まれるライブラリを追加した場合に特に当てはまります。  
使用されないライブラリコードを削除すると、ライブラリリソースが参照されなくなり、  
リソース圧縮ツールでライブラリリソースを削除できるようになります。


### 保持するリソース、破棄するリソースのカスタマイズ

保持するリソース、破棄するリソースをカスタマイズするには、それを定義した専用のリソースファイルを作成します。  
専用のリソースファイルは、プロジェクトの `res` フォルダ配下のどこかに配置します。  

（例）`res/raw/keep.xml`

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools"
  tools:keep="@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*"
  tools:discard="@layout/unused2" />
```

保持する各リソースを `tools:keep` 属性で指定します。  
破棄する各リソースを `tools:discard` 属性で指定します。

どちらの属性も、リソース名をカンマ区切りで複数指定することができます。  
また、アスタリスク文字をワイルドカードとして使用できます。


### 破棄するリソースをなぜ直接削除しないのか

リソースを直接削除できるのに、そうせずに破棄するリソースを指定することは意味がないように思えますが、  
この作業はビルドバリアントを使用するときに役に立つ場合があります。たとえば、あるリソースがコードで  
使用されていても、実際は特定のビルドバリアントでは使用されないことがわかっている場合、すべての  
リソースを共通のプロジェクトディレクトリに格納してから、各ビルドバリアントごとに別の keep.xml  
ファイルを作成することが考えられます。

また、ビルドツールが誤ってリソースを必要であると識別する可能性もあります。これは、コンパイラが  
リソース ID をインラインで追加したことで、元来参照されるリソースと、偶然同じ値になったコード内の  
整数値の違いをリソースアナライザが認識できないことが原因で発生する可能性があります。


## コードの難読化

`minifyEnabled` プロパティを `true` に設定すると、R8 によるコードの難読化が有効になります。  
コードの難読化とは、アプリのクラス、メソッド、フィールドの名前を短く、複雑なものにすることです。

**「 "難読化" と聞くと、逆コンパイルされたときにコードを解析されるのを防ぐためのもの」  
というイメージがしますが、実際には、解析ができないほどの複雑な難読化は行っていません。  
必要に応じてさらに複雑な難読化ツールを使用することを検討してください。**

### 難読化のメリット

短い名前に変換することで、コードを大幅に削減することができます。  
命名規則を無視した名前に変換することで、逆コンパイルされた時に多少コードの解析が行われにくくなります。


### 難読化後の例

R8 を使用した難読化の例を次に示します。

```
androidx.appcompat.app.ActionBarDrawerToggle$DelegateProvider -> a.a.a.b:
androidx.appcompat.app.AlertController -> androidx.appcompat.app.AlertController:
  android.content.Context mContext -> a
  int mListItemLayout -> O
  int mViewSpacingRight -> l
  android.widget.Button mButtonNeutral -> w
  int mMultiChoiceItemLayout -> M
  boolean mShowTitle -> P
  int mViewSpacingLeft -> j
  int mButtonPanelSideLayout -> K
```


### keep ルール、 keep アノテーションによるコード難読化抑制

コード圧縮同様に、 keep ルール、 keep アノテーションによって、コード難読化を抑制することができます。

リフレクションを使用している場合や、クラス名等の命名規則を保持したい場合には、  
keep を使用して、抑制を行います。


### 難読化されたスタックトレースのデコード

#### Google Play Console のエラーログをデコードする

アプリで発生したクラッシュと ANR については、ユーザが許可していれば OS が自動的にサーバへ  
エラーログ (スタックトレース) を送信します。ビルド時にアプリの難読化を行っている場合には、  
ログも難読化されているため、ログの難読化を解除する必要があります。

そのためには、次の keep ルールをモジュールの `proguard-rules.pro` ファイルに追加してください。  
詳しくは、 「運用・管理」 フォルダの `クラッシュ_ANRのレポート.md` ファイルを参照してください。

```
-keepattributes LineNumberTable,SourceFile
```


#### Firebase Crashlytics のエラーログをデコードする

Firebase Crashlytics でエラーログを確認する場合には、他の難読化解除手順が必要かもしれません。  
Firebase Crashlytics での解除方法については、まだ調べていませんが、  
`retrace` というコマンドラインツールを使用して、自分で難読化を解除できるそうなので、  
それを利用すれば、少なくとも難読化解除できるでしょう。おそらく、 Firebase 側にもっと便利な  
機能があるとは思いますが...。以下のリンクは、 `retrace` ツールの説明へ言及しているリンクです。

[難読化されたスタックトレースのデコード](https://developer.android.com/studio/build/shrink-code?hl=ja#decode-stack-trace)


## コードの最適化

`minifyEnabled` プロパティを `true` に設定すると、R8 によるコードの最適化が有効になります。  
コードの最適化とは、実行時に必要のないコードを削除したり、コードを書き直したりして、  
アプリサイズを小さくしたり、コードの冗長性を排除します。

「コードを削除する」 という観点では、コードの最適化はコードの圧縮と似ていますが、  
コードの圧縮では、特に、 **参照されないクラス、参照されないフィールド、呼び出されないメソッド  
の三つについての削除を行う** のに対して、コードの最適化では、 **より多くの観点でコードが見直されます。**

詳しくは、Jake Wharton 氏のブログ記事の中から、 R8 の最適化に関する投稿をピックアップして参照してください。

[ [Jake Wharton 氏のブログ](https://jakewharton.com/blog/) ]


## ルールファイルを使用した keep の方法

### パッケージ指定でその配下のクラスを全て keep 対象とする

```
-keep class com.example.appname.** { *; }
```


## R8 で発生した問題の分析を行う

### 削除されたコードのレポートを確認する

R8 によってアプリから削除されたすべてのコードのレポートを確認すると役に立つ場合があります。

このレポートを生成するモジュールごとに、 `-printusage <output-dir>/usage.txt` を  
カスタムルールファイルに追加してください。 R8 を有効にしてアプリをビルドすると、  
指定したファイル名のレポートが指定したパスに R8 から出力されます。

上記の設定を行わなくても、レポートは以下の場所に自動的に生成されます。  
`{プロジェクトディレクトリ}/app/build/outputs/mapping[/{フレーバー名}]/{ビルドタイプ}/usage.txt`

削除されたコードのレポートは次のような形式です。

```
androidx.drawerlayout.R$attr
androidx.vectordrawable.R
androidx.appcompat.app.AppCompatDelegateImpl
    public void setSupportActionBar(androidx.appcompat.widget.Toolbar)
    public boolean hasWindowFeature(int)
    public void setHandleNativeActionModesEnabled(boolean)
    android.view.ViewGroup getSubDecor()
    public void setLocalNightMode(int)
    final androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager getAutoNightModeManager()
    public final androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate()
    private static final boolean DEBUG
    private static final java.lang.String KEY_LOCAL_NIGHT_MODE
    static final java.lang.String EXCEPTION_HANDLER_MESSAGE_SUFFIX
```

ここに記載されているクラス、メソッド、フィールドは、すべて削除されたものです。

インデントなしで記載されている行は、クラスを示しており、  
インデントありで記載されている行は、メソッド or フィールドを示しています。

クラスを示す行の下にメソッド or フィールドを示す行が存在する場合は、そのクラス自体は  
削除されておらず、対象のメソッド or フィールドのみが削除されています。  
クラスを示す行の下に、別のクラスを示す行が存在している場合は、そのクラス自体が削除されています。

**`public void <init>()` の意味**  
レポート内のメソッドを示す部分に `public void <init>()` の記述がある場合があります。  
これは、 `<init>` はコンストラクターを示しています。


### 保持 ( keep ) されたコードのレポートを生成する

プロジェクトの keep ルールから R8 によって特定されたエントリポイントのレポートを表示する場合は、  
カスタムルールファイルに `-printseeds <output-dir>/seeds.txt` を含めてください。  
R8 を有効にしてアプリをビルドすると、指定したファイル名のレポートが指定したパスに R8 から出力されます。  

上記の設定を行わなくても、レポートは以下の場所に自動的に生成されます。  
`{プロジェクトディレクトリ}/app/build/outputs/mapping[/{フレーバー名}]/{ビルドタイプ}/seeds.txt`

保持されたエントリポイントのレポートは次のような形式になります。

```
com.example.myapplication.MainActivity
androidx.appcompat.R$layout: int abc_action_menu_item_layout
androidx.appcompat.R$attr: int activityChooserViewStyle
androidx.appcompat.R$styleable: int MenuItem_android_id
androidx.appcompat.R$styleable: int[] CoordinatorLayout_Layout
androidx.lifecycle.FullLifecycleObserverAdapter
```


### アプリログを解析する

アプリログは難読化されているため、そのままでは、どのクラスやどのメソッドでエラーが発生しているかがわかりません。  
難読化されたログを解析するためには以下の場所に生成されるマッピングファイルを確認します。

```
{プロジェクトディレクトリ}/app/build/outputs/mapping[/{フレーバー名}]/{ビルドタイプ}/mapping.txt
```
